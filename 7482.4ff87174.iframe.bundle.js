(self.webpackChunkleafygreen_ui=self.webpackChunkleafygreen_ui||[]).push([[7482,8354],{"./node_modules/@testing-library/dom/dist/@testing-library/dom.esm.js":(module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildQueries: () => (/* binding */ buildQueries),\n/* harmony export */   configure: () => (/* binding */ configure),\n/* harmony export */   createEvent: () => (/* binding */ createEvent),\n/* harmony export */   findAllByAltText: () => (/* binding */ findAllByAltText),\n/* harmony export */   findAllByDisplayValue: () => (/* binding */ findAllByDisplayValue),\n/* harmony export */   findAllByLabelText: () => (/* binding */ findAllByLabelText),\n/* harmony export */   findAllByPlaceholderText: () => (/* binding */ findAllByPlaceholderText),\n/* harmony export */   findAllByRole: () => (/* binding */ findAllByRole),\n/* harmony export */   findAllByTestId: () => (/* binding */ findAllByTestId),\n/* harmony export */   findAllByText: () => (/* binding */ findAllByText),\n/* harmony export */   findAllByTitle: () => (/* binding */ findAllByTitle),\n/* harmony export */   findByAltText: () => (/* binding */ findByAltText),\n/* harmony export */   findByDisplayValue: () => (/* binding */ findByDisplayValue),\n/* harmony export */   findByLabelText: () => (/* binding */ findByLabelText),\n/* harmony export */   findByPlaceholderText: () => (/* binding */ findByPlaceholderText),\n/* harmony export */   findByRole: () => (/* binding */ findByRole),\n/* harmony export */   findByTestId: () => (/* binding */ findByTestId),\n/* harmony export */   findByText: () => (/* binding */ findByText),\n/* harmony export */   findByTitle: () => (/* binding */ findByTitle),\n/* harmony export */   fireEvent: () => (/* binding */ fireEvent),\n/* harmony export */   getAllByAltText: () => (/* binding */ getAllByAltText),\n/* harmony export */   getAllByDisplayValue: () => (/* binding */ getAllByDisplayValue),\n/* harmony export */   getAllByLabelText: () => (/* binding */ getAllByLabelTextWithSuggestions),\n/* harmony export */   getAllByPlaceholderText: () => (/* binding */ getAllByPlaceholderText),\n/* harmony export */   getAllByRole: () => (/* binding */ getAllByRole),\n/* harmony export */   getAllByTestId: () => (/* binding */ getAllByTestId),\n/* harmony export */   getAllByText: () => (/* binding */ getAllByText),\n/* harmony export */   getAllByTitle: () => (/* binding */ getAllByTitle),\n/* harmony export */   getByAltText: () => (/* binding */ getByAltText),\n/* harmony export */   getByDisplayValue: () => (/* binding */ getByDisplayValue),\n/* harmony export */   getByLabelText: () => (/* binding */ getByLabelTextWithSuggestions),\n/* harmony export */   getByPlaceholderText: () => (/* binding */ getByPlaceholderText),\n/* harmony export */   getByRole: () => (/* binding */ getByRole),\n/* harmony export */   getByTestId: () => (/* binding */ getByTestId),\n/* harmony export */   getByText: () => (/* binding */ getByText),\n/* harmony export */   getByTitle: () => (/* binding */ getByTitle),\n/* harmony export */   getConfig: () => (/* binding */ getConfig),\n/* harmony export */   getDefaultNormalizer: () => (/* binding */ getDefaultNormalizer),\n/* harmony export */   getElementError: () => (/* binding */ getElementError),\n/* harmony export */   getMultipleElementsFoundError: () => (/* binding */ getMultipleElementsFoundError),\n/* harmony export */   getNodeText: () => (/* binding */ getNodeText),\n/* harmony export */   getQueriesForElement: () => (/* binding */ getQueriesForElement),\n/* harmony export */   getRoles: () => (/* binding */ getRoles),\n/* harmony export */   getSuggestedQuery: () => (/* binding */ getSuggestedQuery),\n/* harmony export */   isInaccessible: () => (/* binding */ isInaccessible),\n/* harmony export */   logDOM: () => (/* binding */ logDOM),\n/* harmony export */   logRoles: () => (/* binding */ logRoles),\n/* harmony export */   makeFindQuery: () => (/* binding */ makeFindQuery),\n/* harmony export */   makeGetAllQuery: () => (/* binding */ makeGetAllQuery),\n/* harmony export */   makeSingleQuery: () => (/* binding */ makeSingleQuery),\n/* harmony export */   prettyDOM: () => (/* binding */ prettyDOM),\n/* harmony export */   prettyFormat: () => (/* reexport module object */ pretty_format__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   queries: () => (/* binding */ queries),\n/* harmony export */   queryAllByAltText: () => (/* binding */ queryAllByAltTextWithSuggestions),\n/* harmony export */   queryAllByAttribute: () => (/* binding */ queryAllByAttribute),\n/* harmony export */   queryAllByDisplayValue: () => (/* binding */ queryAllByDisplayValueWithSuggestions),\n/* harmony export */   queryAllByLabelText: () => (/* binding */ queryAllByLabelTextWithSuggestions),\n/* harmony export */   queryAllByPlaceholderText: () => (/* binding */ queryAllByPlaceholderTextWithSuggestions),\n/* harmony export */   queryAllByRole: () => (/* binding */ queryAllByRoleWithSuggestions),\n/* harmony export */   queryAllByTestId: () => (/* binding */ queryAllByTestIdWithSuggestions),\n/* harmony export */   queryAllByText: () => (/* binding */ queryAllByTextWithSuggestions),\n/* harmony export */   queryAllByTitle: () => (/* binding */ queryAllByTitleWithSuggestions),\n/* harmony export */   queryByAltText: () => (/* binding */ queryByAltText),\n/* harmony export */   queryByAttribute: () => (/* binding */ queryByAttribute),\n/* harmony export */   queryByDisplayValue: () => (/* binding */ queryByDisplayValue),\n/* harmony export */   queryByLabelText: () => (/* binding */ queryByLabelText),\n/* harmony export */   queryByPlaceholderText: () => (/* binding */ queryByPlaceholderText),\n/* harmony export */   queryByRole: () => (/* binding */ queryByRole),\n/* harmony export */   queryByTestId: () => (/* binding */ queryByTestId),\n/* harmony export */   queryByText: () => (/* binding */ queryByText),\n/* harmony export */   queryByTitle: () => (/* binding */ queryByTitle),\n/* harmony export */   queryHelpers: () => (/* binding */ queryHelpers),\n/* harmony export */   screen: () => (/* binding */ screen),\n/* harmony export */   waitFor: () => (/* binding */ waitForWrapper),\n/* harmony export */   waitForElementToBeRemoved: () => (/* binding */ waitForElementToBeRemoved),\n/* harmony export */   within: () => (/* binding */ getQueriesForElement),\n/* harmony export */   wrapAllByQueryWithSuggestion: () => (/* binding */ wrapAllByQueryWithSuggestion),\n/* harmony export */   wrapSingleQueryWithSuggestion: () => (/* binding */ wrapSingleQueryWithSuggestion)\n/* harmony export */ });\n/* harmony import */ var pretty_format__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/@testing-library/dom/node_modules/pretty-format/build/index.js\");\n/* harmony import */ var dom_accessibility_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/dom-accessibility-api/dist/index.mjs\");\n/* harmony import */ var aria_query__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./node_modules/@testing-library/dom/node_modules/aria-query/lib/index.js\");\n/* harmony import */ var lz_string__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./node_modules/lz-string/libs/lz-string.js\");\n/* harmony import */ var lz_string__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lz_string__WEBPACK_IMPORTED_MODULE_3__);\n/* module decorator */ module = __webpack_require__.hmd(module);\n/* provided dependency */ var process = __webpack_require__(\"./node_modules/process/browser.js\");\n\n\n\n\n\n\n/**\n * Source: https://github.com/facebook/jest/blob/e7bb6a1e26ffab90611b2593912df15b69315611/packages/pretty-format/src/plugins/DOMElement.ts\n */\n/* eslint-disable -- trying to stay as close to the original as possible */\n/* istanbul ignore file */\n\nfunction escapeHTML(str) {\n  return str.replace(/</g, '&lt;').replace(/>/g, '&gt;');\n}\n// Return empty string if keys is empty.\nconst printProps = (keys, props, config, indentation, depth, refs, printer) => {\n  const indentationNext = indentation + config.indent;\n  const colors = config.colors;\n  return keys.map(key => {\n    const value = props[key];\n    let printed = printer(value, config, indentationNext, depth, refs);\n    if (typeof value !== 'string') {\n      if (printed.indexOf('\\n') !== -1) {\n        printed = config.spacingOuter + indentationNext + printed + config.spacingOuter + indentation;\n      }\n      printed = '{' + printed + '}';\n    }\n    return config.spacingInner + indentation + colors.prop.open + key + colors.prop.close + '=' + colors.value.open + printed + colors.value.close;\n  }).join('');\n};\n\n// https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType#node_type_constants\nconst NodeTypeTextNode = 3;\n\n// Return empty string if children is empty.\nconst printChildren = (children, config, indentation, depth, refs, printer) => children.map(child => {\n  const printedChild = typeof child === 'string' ? printText(child, config) : printer(child, config, indentation, depth, refs);\n  if (printedChild === '' && typeof child === 'object' && child !== null && child.nodeType !== NodeTypeTextNode) {\n    // A plugin serialized this Node to '' meaning we should ignore it.\n    return '';\n  }\n  return config.spacingOuter + indentation + printedChild;\n}).join('');\nconst printText = (text, config) => {\n  const contentColor = config.colors.content;\n  return contentColor.open + escapeHTML(text) + contentColor.close;\n};\nconst printComment = (comment, config) => {\n  const commentColor = config.colors.comment;\n  return commentColor.open + '\x3c!--' + escapeHTML(comment) + '--\x3e' + commentColor.close;\n};\n\n// Separate the functions to format props, children, and element,\n// so a plugin could override a particular function, if needed.\n// Too bad, so sad: the traditional (but unnecessary) space\n// in a self-closing tagColor requires a second test of printedProps.\nconst printElement = (type, printedProps, printedChildren, config, indentation) => {\n  const tagColor = config.colors.tag;\n  return tagColor.open + '<' + type + (printedProps && tagColor.close + printedProps + config.spacingOuter + indentation + tagColor.open) + (printedChildren ? '>' + tagColor.close + printedChildren + config.spacingOuter + indentation + tagColor.open + '</' + type : (printedProps && !config.min ? '' : ' ') + '/') + '>' + tagColor.close;\n};\nconst printElementAsLeaf = (type, config) => {\n  const tagColor = config.colors.tag;\n  return tagColor.open + '<' + type + tagColor.close + ' …' + tagColor.open + ' />' + tagColor.close;\n};\nconst ELEMENT_NODE$1 = 1;\nconst TEXT_NODE$1 = 3;\nconst COMMENT_NODE$1 = 8;\nconst FRAGMENT_NODE = 11;\nconst ELEMENT_REGEXP = /^((HTML|SVG)\\w*)?Element$/;\nconst testNode = val => {\n  const constructorName = val.constructor.name;\n  const {\n    nodeType,\n    tagName\n  } = val;\n  const isCustomElement = typeof tagName === 'string' && tagName.includes('-') || typeof val.hasAttribute === 'function' && val.hasAttribute('is');\n  return nodeType === ELEMENT_NODE$1 && (ELEMENT_REGEXP.test(constructorName) || isCustomElement) || nodeType === TEXT_NODE$1 && constructorName === 'Text' || nodeType === COMMENT_NODE$1 && constructorName === 'Comment' || nodeType === FRAGMENT_NODE && constructorName === 'DocumentFragment';\n};\nfunction nodeIsText(node) {\n  return node.nodeType === TEXT_NODE$1;\n}\nfunction nodeIsComment(node) {\n  return node.nodeType === COMMENT_NODE$1;\n}\nfunction nodeIsFragment(node) {\n  return node.nodeType === FRAGMENT_NODE;\n}\nfunction createDOMElementFilter(filterNode) {\n  return {\n    test: val => {\n      var _val$constructor2;\n      return (val == null ? void 0 : (_val$constructor2 = val.constructor) == null ? void 0 : _val$constructor2.name) && testNode(val);\n    },\n    serialize: (node, config, indentation, depth, refs, printer) => {\n      if (nodeIsText(node)) {\n        return printText(node.data, config);\n      }\n      if (nodeIsComment(node)) {\n        return printComment(node.data, config);\n      }\n      const type = nodeIsFragment(node) ? \"DocumentFragment\" : node.tagName.toLowerCase();\n      if (++depth > config.maxDepth) {\n        return printElementAsLeaf(type, config);\n      }\n      return printElement(type, printProps(nodeIsFragment(node) ? [] : Array.from(node.attributes).map(attr => attr.name).sort(), nodeIsFragment(node) ? {} : Array.from(node.attributes).reduce((props, attribute) => {\n        props[attribute.name] = attribute.value;\n        return props;\n      }, {}), config, indentation + config.indent, depth, refs, printer), printChildren(Array.prototype.slice.call(node.childNodes || node.children).filter(filterNode), config, indentation + config.indent, depth, refs, printer), config, indentation);\n    }\n  };\n}\n\n// We try to load node dependencies\nlet chalk = null;\nlet readFileSync = null;\nlet codeFrameColumns = null;\ntry {\n  const nodeRequire = module && module.require;\n  readFileSync = nodeRequire.call(module, 'fs').readFileSync;\n  codeFrameColumns = nodeRequire.call(module, '@babel/code-frame').codeFrameColumns;\n  chalk = nodeRequire.call(module, 'chalk');\n} catch {\n  // We're in a browser environment\n}\n\n// frame has the form \"at myMethod (location/to/my/file.js:10:2)\"\nfunction getCodeFrame(frame) {\n  const locationStart = frame.indexOf('(') + 1;\n  const locationEnd = frame.indexOf(')');\n  const frameLocation = frame.slice(locationStart, locationEnd);\n  const frameLocationElements = frameLocation.split(':');\n  const [filename, line, column] = [frameLocationElements[0], parseInt(frameLocationElements[1], 10), parseInt(frameLocationElements[2], 10)];\n  let rawFileContents = '';\n  try {\n    rawFileContents = readFileSync(filename, 'utf-8');\n  } catch {\n    return '';\n  }\n  const codeFrame = codeFrameColumns(rawFileContents, {\n    start: {\n      line,\n      column\n    }\n  }, {\n    highlightCode: true,\n    linesBelow: 0\n  });\n  return chalk.dim(frameLocation) + \"\\n\" + codeFrame + \"\\n\";\n}\nfunction getUserCodeFrame() {\n  // If we couldn't load dependencies, we can't generate the user trace\n  /* istanbul ignore next */\n  if (!readFileSync || !codeFrameColumns) {\n    return '';\n  }\n  const err = new Error();\n  const firstClientCodeFrame = err.stack.split('\\n').slice(1) // Remove first line which has the form \"Error: TypeError\"\n  .find(frame => !frame.includes('node_modules/')); // Ignore frames from 3rd party libraries\n\n  return getCodeFrame(firstClientCodeFrame);\n}\n\n// Constant node.nodeType for text nodes, see:\n// https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType#Node_type_constants\nconst TEXT_NODE = 3;\nfunction jestFakeTimersAreEnabled() {\n  /* istanbul ignore else */\n  // eslint-disable-next-line\n  if (typeof jest !== 'undefined' && jest !== null) {\n    return (\n      // legacy timers\n      setTimeout._isMockFunction === true ||\n      // modern timers\n      // eslint-disable-next-line prefer-object-has-own -- not supported by our support matrix\n      Object.prototype.hasOwnProperty.call(setTimeout, 'clock')\n    );\n  }\n  // istanbul ignore next\n  return false;\n}\nfunction getDocument() {\n  /* istanbul ignore if */\n  if (typeof window === 'undefined') {\n    throw new Error('Could not find default container');\n  }\n  return window.document;\n}\nfunction getWindowFromNode(node) {\n  if (node.defaultView) {\n    // node is document\n    return node.defaultView;\n  } else if (node.ownerDocument && node.ownerDocument.defaultView) {\n    // node is a DOM node\n    return node.ownerDocument.defaultView;\n  } else if (node.window) {\n    // node is window\n    return node.window;\n  } else if (node.ownerDocument && node.ownerDocument.defaultView === null) {\n    throw new Error(\"It looks like the window object is not available for the provided node.\");\n  } else if (node.then instanceof Function) {\n    throw new Error(\"It looks like you passed a Promise object instead of a DOM node. Did you do something like `fireEvent.click(screen.findBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`, or await the findBy query `fireEvent.click(await screen.findBy...`?\");\n  } else if (Array.isArray(node)) {\n    throw new Error(\"It looks like you passed an Array instead of a DOM node. Did you do something like `fireEvent.click(screen.getAllBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`?\");\n  } else if (typeof node.debug === 'function' && typeof node.logTestingPlaygroundURL === 'function') {\n    throw new Error(\"It looks like you passed a `screen` object. Did you do something like `fireEvent.click(screen, ...` when you meant to use a query, e.g. `fireEvent.click(screen.getBy..., `?\");\n  } else {\n    // The user passed something unusual to a calling function\n    throw new Error(\"The given node is not an Element, the node type is: \" + typeof node + \".\");\n  }\n}\nfunction checkContainerType(container) {\n  if (!container || !(typeof container.querySelector === 'function') || !(typeof container.querySelectorAll === 'function')) {\n    throw new TypeError(\"Expected container to be an Element, a Document or a DocumentFragment but got \" + getTypeName(container) + \".\");\n  }\n  function getTypeName(object) {\n    if (typeof object === 'object') {\n      return object === null ? 'null' : object.constructor.name;\n    }\n    return typeof object;\n  }\n}\n\nconst shouldHighlight = () => {\n  let colors;\n  try {\n    var _process, _process$env;\n    colors = JSON.parse((_process = process) == null ? void 0 : (_process$env = _process.env) == null ? void 0 : _process$env.COLORS);\n  } catch (e) {\n    // If this throws, process?.env?.COLORS wasn't parsable. Since we only\n    // care about `true` or `false`, we can safely ignore the error.\n  }\n  if (typeof colors === 'boolean') {\n    // If `colors` is set explicitly (both `true` and `false`), use that value.\n    return colors;\n  } else {\n    // If `colors` is not set, colorize if we're in node.\n    return typeof process !== 'undefined' && process.versions !== undefined && process.versions.node !== undefined;\n  }\n};\nconst {\n  DOMCollection\n} = pretty_format__WEBPACK_IMPORTED_MODULE_0__.plugins;\n\n// https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType#node_type_constants\nconst ELEMENT_NODE = 1;\nconst COMMENT_NODE = 8;\n\n// https://github.com/facebook/jest/blob/615084195ae1ae61ddd56162c62bbdda17587569/packages/pretty-format/src/plugins/DOMElement.ts#L50\nfunction filterCommentsAndDefaultIgnoreTagsTags(value) {\n  return value.nodeType !== COMMENT_NODE && (value.nodeType !== ELEMENT_NODE || !value.matches(getConfig().defaultIgnore));\n}\nfunction prettyDOM(dom, maxLength, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  if (!dom) {\n    dom = getDocument().body;\n  }\n  if (typeof maxLength !== 'number') {\n    maxLength = typeof process !== 'undefined' && process.env.DEBUG_PRINT_LIMIT || 7000;\n  }\n  if (maxLength === 0) {\n    return '';\n  }\n  if (dom.documentElement) {\n    dom = dom.documentElement;\n  }\n  let domTypeName = typeof dom;\n  if (domTypeName === 'object') {\n    domTypeName = dom.constructor.name;\n  } else {\n    // To don't fall with `in` operator\n    dom = {};\n  }\n  if (!('outerHTML' in dom)) {\n    throw new TypeError(\"Expected an element or document but got \" + domTypeName);\n  }\n  const {\n    filterNode = filterCommentsAndDefaultIgnoreTagsTags,\n    ...prettyFormatOptions\n  } = options;\n  const debugContent = pretty_format__WEBPACK_IMPORTED_MODULE_0__.format(dom, {\n    plugins: [createDOMElementFilter(filterNode), DOMCollection],\n    printFunctionName: false,\n    highlight: shouldHighlight(),\n    ...prettyFormatOptions\n  });\n  return maxLength !== undefined && dom.outerHTML.length > maxLength ? debugContent.slice(0, maxLength) + \"...\" : debugContent;\n}\nconst logDOM = function () {\n  const userCodeFrame = getUserCodeFrame();\n  if (userCodeFrame) {\n    console.log(prettyDOM(...arguments) + \"\\n\\n\" + userCodeFrame);\n  } else {\n    console.log(prettyDOM(...arguments));\n  }\n};\n\n// It would be cleaner for this to live inside './queries', but\n// other parts of the code assume that all exports from\n// './queries' are query functions.\nlet config = {\n  testIdAttribute: 'data-testid',\n  asyncUtilTimeout: 1000,\n  // asyncWrapper and advanceTimersWrapper is to support React's async `act` function.\n  // forcing react-testing-library to wrap all async functions would've been\n  // a total nightmare (consider wrapping every findBy* query and then also\n  // updating `within` so those would be wrapped too. Total nightmare).\n  // so we have this config option that's really only intended for\n  // react-testing-library to use. For that reason, this feature will remain\n  // undocumented.\n  asyncWrapper: cb => cb(),\n  unstable_advanceTimersWrapper: cb => cb(),\n  eventWrapper: cb => cb(),\n  // default value for the `hidden` option in `ByRole` queries\n  defaultHidden: false,\n  // default value for the `ignore` option in `ByText` queries\n  defaultIgnore: 'script, style',\n  // showOriginalStackTrace flag to show the full error stack traces for async errors\n  showOriginalStackTrace: false,\n  // throw errors w/ suggestions for better queries. Opt in so off by default.\n  throwSuggestions: false,\n  // called when getBy* queries fail. (message, container) => Error\n  getElementError(message, container) {\n    const prettifiedDOM = prettyDOM(container);\n    const error = new Error([message, \"Ignored nodes: comments, \" + config.defaultIgnore + \"\\n\" + prettifiedDOM].filter(Boolean).join('\\n\\n'));\n    error.name = 'TestingLibraryElementError';\n    return error;\n  },\n  _disableExpensiveErrorDiagnostics: false,\n  computedStyleSupportsPseudoElements: false\n};\nfunction runWithExpensiveErrorDiagnosticsDisabled(callback) {\n  try {\n    config._disableExpensiveErrorDiagnostics = true;\n    return callback();\n  } finally {\n    config._disableExpensiveErrorDiagnostics = false;\n  }\n}\nfunction configure(newConfig) {\n  if (typeof newConfig === 'function') {\n    // Pass the existing config out to the provided function\n    // and accept a delta in return\n    newConfig = newConfig(config);\n  }\n\n  // Merge the incoming config delta\n  config = {\n    ...config,\n    ...newConfig\n  };\n}\nfunction getConfig() {\n  return config;\n}\n\nconst labelledNodeNames = ['button', 'meter', 'output', 'progress', 'select', 'textarea', 'input'];\nfunction getTextContent(node) {\n  if (labelledNodeNames.includes(node.nodeName.toLowerCase())) {\n    return '';\n  }\n  if (node.nodeType === TEXT_NODE) return node.textContent;\n  return Array.from(node.childNodes).map(childNode => getTextContent(childNode)).join('');\n}\nfunction getLabelContent(element) {\n  let textContent;\n  if (element.tagName.toLowerCase() === 'label') {\n    textContent = getTextContent(element);\n  } else {\n    textContent = element.value || element.textContent;\n  }\n  return textContent;\n}\n\n// Based on https://github.com/eps1lon/dom-accessibility-api/pull/352\nfunction getRealLabels(element) {\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- types are not aware of older browsers that don't implement `labels`\n  if (element.labels !== undefined) {\n    var _labels;\n    return (_labels = element.labels) != null ? _labels : [];\n  }\n  if (!isLabelable(element)) return [];\n  const labels = element.ownerDocument.querySelectorAll('label');\n  return Array.from(labels).filter(label => label.control === element);\n}\nfunction isLabelable(element) {\n  return /BUTTON|METER|OUTPUT|PROGRESS|SELECT|TEXTAREA/.test(element.tagName) || element.tagName === 'INPUT' && element.getAttribute('type') !== 'hidden';\n}\nfunction getLabels(container, element, _temp) {\n  let {\n    selector = '*'\n  } = _temp === void 0 ? {} : _temp;\n  const ariaLabelledBy = element.getAttribute('aria-labelledby');\n  const labelsId = ariaLabelledBy ? ariaLabelledBy.split(' ') : [];\n  return labelsId.length ? labelsId.map(labelId => {\n    const labellingElement = container.querySelector(\"[id=\\\"\" + labelId + \"\\\"]\");\n    return labellingElement ? {\n      content: getLabelContent(labellingElement),\n      formControl: null\n    } : {\n      content: '',\n      formControl: null\n    };\n  }) : Array.from(getRealLabels(element)).map(label => {\n    const textToMatch = getLabelContent(label);\n    const formControlSelector = 'button, input, meter, output, progress, select, textarea';\n    const labelledFormControl = Array.from(label.querySelectorAll(formControlSelector)).filter(formControlElement => formControlElement.matches(selector))[0];\n    return {\n      content: textToMatch,\n      formControl: labelledFormControl\n    };\n  });\n}\n\nfunction assertNotNullOrUndefined(matcher) {\n  if (matcher === null || matcher === undefined) {\n    throw new Error( // eslint-disable-next-line @typescript-eslint/restrict-template-expressions -- implicitly converting `T` to `string`\n    \"It looks like \" + matcher + \" was passed instead of a matcher. Did you do something like getByText(\" + matcher + \")?\");\n  }\n}\nfunction fuzzyMatches(textToMatch, node, matcher, normalizer) {\n  if (typeof textToMatch !== 'string') {\n    return false;\n  }\n  assertNotNullOrUndefined(matcher);\n  const normalizedText = normalizer(textToMatch);\n  if (typeof matcher === 'string' || typeof matcher === 'number') {\n    return normalizedText.toLowerCase().includes(matcher.toString().toLowerCase());\n  } else if (typeof matcher === 'function') {\n    return matcher(normalizedText, node);\n  } else {\n    return matchRegExp(matcher, normalizedText);\n  }\n}\nfunction matches(textToMatch, node, matcher, normalizer) {\n  if (typeof textToMatch !== 'string') {\n    return false;\n  }\n  assertNotNullOrUndefined(matcher);\n  const normalizedText = normalizer(textToMatch);\n  if (matcher instanceof Function) {\n    return matcher(normalizedText, node);\n  } else if (matcher instanceof RegExp) {\n    return matchRegExp(matcher, normalizedText);\n  } else {\n    return normalizedText === String(matcher);\n  }\n}\nfunction getDefaultNormalizer(_temp) {\n  let {\n    trim = true,\n    collapseWhitespace = true\n  } = _temp === void 0 ? {} : _temp;\n  return text => {\n    let normalizedText = text;\n    normalizedText = trim ? normalizedText.trim() : normalizedText;\n    normalizedText = collapseWhitespace ? normalizedText.replace(/\\s+/g, ' ') : normalizedText;\n    return normalizedText;\n  };\n}\n\n/**\n * Constructs a normalizer to pass to functions in matches.js\n * @param {boolean|undefined} trim The user-specified value for `trim`, without\n * any defaulting having been applied\n * @param {boolean|undefined} collapseWhitespace The user-specified value for\n * `collapseWhitespace`, without any defaulting having been applied\n * @param {Function|undefined} normalizer The user-specified normalizer\n * @returns {Function} A normalizer\n */\n\nfunction makeNormalizer(_ref) {\n  let {\n    trim,\n    collapseWhitespace,\n    normalizer\n  } = _ref;\n  if (!normalizer) {\n    // No custom normalizer specified. Just use default.\n    return getDefaultNormalizer({\n      trim,\n      collapseWhitespace\n    });\n  }\n  if (typeof trim !== 'undefined' || typeof collapseWhitespace !== 'undefined') {\n    // They've also specified a value for trim or collapseWhitespace\n    throw new Error('trim and collapseWhitespace are not supported with a normalizer. ' + 'If you want to use the default trim and collapseWhitespace logic in your normalizer, ' + 'use \"getDefaultNormalizer({trim, collapseWhitespace})\" and compose that into your normalizer');\n  }\n  return normalizer;\n}\nfunction matchRegExp(matcher, text) {\n  const match = matcher.test(text);\n  if (matcher.global && matcher.lastIndex !== 0) {\n    console.warn(\"To match all elements we had to reset the lastIndex of the RegExp because the global flag is enabled. We encourage to remove the global flag from the RegExp.\");\n    matcher.lastIndex = 0;\n  }\n  return match;\n}\n\nfunction getNodeText(node) {\n  if (node.matches('input[type=submit], input[type=button], input[type=reset]')) {\n    return node.value;\n  }\n  return Array.from(node.childNodes).filter(child => child.nodeType === TEXT_NODE && Boolean(child.textContent)).map(c => c.textContent).join('');\n}\n\nconst elementRoleList = buildElementRoleList(aria_query__WEBPACK_IMPORTED_MODULE_2__/* .elementRoles */ .Qv);\n\n/**\n * @param {Element} element -\n * @returns {boolean} - `true` if `element` and its subtree are inaccessible\n */\nfunction isSubtreeInaccessible(element) {\n  if (element.hidden === true) {\n    return true;\n  }\n  if (element.getAttribute('aria-hidden') === 'true') {\n    return true;\n  }\n  const window = element.ownerDocument.defaultView;\n  if (window.getComputedStyle(element).display === 'none') {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Partial implementation https://www.w3.org/TR/wai-aria-1.2/#tree_exclusion\n * which should only be used for elements with a non-presentational role i.e.\n * `role=\"none\"` and `role=\"presentation\"` will not be excluded.\n *\n * Implements aria-hidden semantics (i.e. parent overrides child)\n * Ignores \"Child Presentational: True\" characteristics\n *\n * @param {Element} element -\n * @param {object} [options] -\n * @param {function (element: Element): boolean} options.isSubtreeInaccessible -\n * can be used to return cached results from previous isSubtreeInaccessible calls\n * @returns {boolean} true if excluded, otherwise false\n */\nfunction isInaccessible(element, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    isSubtreeInaccessible: isSubtreeInaccessibleImpl = isSubtreeInaccessible\n  } = options;\n  const window = element.ownerDocument.defaultView;\n  // since visibility is inherited we can exit early\n  if (window.getComputedStyle(element).visibility === 'hidden') {\n    return true;\n  }\n  let currentElement = element;\n  while (currentElement) {\n    if (isSubtreeInaccessibleImpl(currentElement)) {\n      return true;\n    }\n    currentElement = currentElement.parentElement;\n  }\n  return false;\n}\nfunction getImplicitAriaRoles(currentNode) {\n  // eslint bug here:\n  // eslint-disable-next-line no-unused-vars\n  for (const {\n    match,\n    roles\n  } of elementRoleList) {\n    if (match(currentNode)) {\n      return [...roles];\n    }\n  }\n  return [];\n}\nfunction buildElementRoleList(elementRolesMap) {\n  function makeElementSelector(_ref) {\n    let {\n      name,\n      attributes\n    } = _ref;\n    return \"\" + name + attributes.map(_ref2 => {\n      let {\n        name: attributeName,\n        value,\n        constraints = []\n      } = _ref2;\n      const shouldNotExist = constraints.indexOf('undefined') !== -1;\n      if (shouldNotExist) {\n        return \":not([\" + attributeName + \"])\";\n      } else if (value) {\n        return \"[\" + attributeName + \"=\\\"\" + value + \"\\\"]\";\n      } else {\n        return \"[\" + attributeName + \"]\";\n      }\n    }).join('');\n  }\n  function getSelectorSpecificity(_ref3) {\n    let {\n      attributes = []\n    } = _ref3;\n    return attributes.length;\n  }\n  function bySelectorSpecificity(_ref4, _ref5) {\n    let {\n      specificity: leftSpecificity\n    } = _ref4;\n    let {\n      specificity: rightSpecificity\n    } = _ref5;\n    return rightSpecificity - leftSpecificity;\n  }\n  function match(element) {\n    let {\n      attributes = []\n    } = element;\n\n    // https://github.com/testing-library/dom-testing-library/issues/814\n    const typeTextIndex = attributes.findIndex(attribute => attribute.value && attribute.name === 'type' && attribute.value === 'text');\n    if (typeTextIndex >= 0) {\n      // not using splice to not mutate the attributes array\n      attributes = [...attributes.slice(0, typeTextIndex), ...attributes.slice(typeTextIndex + 1)];\n    }\n    const selector = makeElementSelector({\n      ...element,\n      attributes\n    });\n    return node => {\n      if (typeTextIndex >= 0 && node.type !== 'text') {\n        return false;\n      }\n      return node.matches(selector);\n    };\n  }\n  let result = [];\n\n  // eslint bug here:\n  // eslint-disable-next-line no-unused-vars\n  for (const [element, roles] of elementRolesMap.entries()) {\n    result = [...result, {\n      match: match(element),\n      roles: Array.from(roles),\n      specificity: getSelectorSpecificity(element)\n    }];\n  }\n  return result.sort(bySelectorSpecificity);\n}\nfunction getRoles(container, _temp) {\n  let {\n    hidden = false\n  } = _temp === void 0 ? {} : _temp;\n  function flattenDOM(node) {\n    return [node, ...Array.from(node.children).reduce((acc, child) => [...acc, ...flattenDOM(child)], [])];\n  }\n  return flattenDOM(container).filter(element => {\n    return hidden === false ? isInaccessible(element) === false : true;\n  }).reduce((acc, node) => {\n    let roles = [];\n    // TODO: This violates html-aria which does not allow any role on every element\n    if (node.hasAttribute('role')) {\n      roles = node.getAttribute('role').split(' ').slice(0, 1);\n    } else {\n      roles = getImplicitAriaRoles(node);\n    }\n    return roles.reduce((rolesAcc, role) => Array.isArray(rolesAcc[role]) ? {\n      ...rolesAcc,\n      [role]: [...rolesAcc[role], node]\n    } : {\n      ...rolesAcc,\n      [role]: [node]\n    }, acc);\n  }, {});\n}\nfunction prettyRoles(dom, _ref6) {\n  let {\n    hidden,\n    includeDescription\n  } = _ref6;\n  const roles = getRoles(dom, {\n    hidden\n  });\n  // We prefer to skip generic role, we don't recommend it\n  return Object.entries(roles).filter(_ref7 => {\n    let [role] = _ref7;\n    return role !== 'generic';\n  }).map(_ref8 => {\n    let [role, elements] = _ref8;\n    const delimiterBar = '-'.repeat(50);\n    const elementsString = elements.map(el => {\n      const nameString = \"Name \\\"\" + (0,dom_accessibility_api__WEBPACK_IMPORTED_MODULE_1__/* .computeAccessibleName */ .AB)(el, {\n        computedStyleSupportsPseudoElements: getConfig().computedStyleSupportsPseudoElements\n      }) + \"\\\":\\n\";\n      const domString = prettyDOM(el.cloneNode(false));\n      if (includeDescription) {\n        const descriptionString = \"Description \\\"\" + (0,dom_accessibility_api__WEBPACK_IMPORTED_MODULE_1__/* .computeAccessibleDescription */ .b)(el, {\n          computedStyleSupportsPseudoElements: getConfig().computedStyleSupportsPseudoElements\n        }) + \"\\\":\\n\";\n        return \"\" + nameString + descriptionString + domString;\n      }\n      return \"\" + nameString + domString;\n    }).join('\\n\\n');\n    return role + \":\\n\\n\" + elementsString + \"\\n\\n\" + delimiterBar;\n  }).join('\\n');\n}\nconst logRoles = function (dom, _temp2) {\n  let {\n    hidden = false\n  } = _temp2 === void 0 ? {} : _temp2;\n  return console.log(prettyRoles(dom, {\n    hidden\n  }));\n};\n\n/**\n * @param {Element} element -\n * @returns {boolean | undefined} - false/true if (not)selected, undefined if not selectable\n */\nfunction computeAriaSelected(element) {\n  // implicit value from html-aam mappings: https://www.w3.org/TR/html-aam-1.0/#html-attribute-state-and-property-mappings\n  // https://www.w3.org/TR/html-aam-1.0/#details-id-97\n  if (element.tagName === 'OPTION') {\n    return element.selected;\n  }\n\n  // explicit value\n  return checkBooleanAttribute(element, 'aria-selected');\n}\n\n/**\n * @param {Element} element -\n * @returns {boolean} -\n */\nfunction computeAriaBusy(element) {\n  // https://www.w3.org/TR/wai-aria-1.1/#aria-busy\n  return element.getAttribute('aria-busy') === 'true';\n}\n\n/**\n * @param {Element} element -\n * @returns {boolean | undefined} - false/true if (not)checked, undefined if not checked-able\n */\nfunction computeAriaChecked(element) {\n  // implicit value from html-aam mappings: https://www.w3.org/TR/html-aam-1.0/#html-attribute-state-and-property-mappings\n  // https://www.w3.org/TR/html-aam-1.0/#details-id-56\n  // https://www.w3.org/TR/html-aam-1.0/#details-id-67\n  if ('indeterminate' in element && element.indeterminate) {\n    return undefined;\n  }\n  if ('checked' in element) {\n    return element.checked;\n  }\n\n  // explicit value\n  return checkBooleanAttribute(element, 'aria-checked');\n}\n\n/**\n * @param {Element} element -\n * @returns {boolean | undefined} - false/true if (not)pressed, undefined if not press-able\n */\nfunction computeAriaPressed(element) {\n  // https://www.w3.org/TR/wai-aria-1.1/#aria-pressed\n  return checkBooleanAttribute(element, 'aria-pressed');\n}\n\n/**\n * @param {Element} element -\n * @returns {boolean | string | null} -\n */\nfunction computeAriaCurrent(element) {\n  var _ref9, _checkBooleanAttribut;\n  // https://www.w3.org/TR/wai-aria-1.1/#aria-current\n  return (_ref9 = (_checkBooleanAttribut = checkBooleanAttribute(element, 'aria-current')) != null ? _checkBooleanAttribut : element.getAttribute('aria-current')) != null ? _ref9 : false;\n}\n\n/**\n * @param {Element} element -\n * @returns {boolean | undefined} - false/true if (not)expanded, undefined if not expand-able\n */\nfunction computeAriaExpanded(element) {\n  // https://www.w3.org/TR/wai-aria-1.1/#aria-expanded\n  return checkBooleanAttribute(element, 'aria-expanded');\n}\nfunction checkBooleanAttribute(element, attribute) {\n  const attributeValue = element.getAttribute(attribute);\n  if (attributeValue === 'true') {\n    return true;\n  }\n  if (attributeValue === 'false') {\n    return false;\n  }\n  return undefined;\n}\n\n/**\n * @param {Element} element -\n * @returns {number | undefined} - number if implicit heading or aria-level present, otherwise undefined\n */\nfunction computeHeadingLevel(element) {\n  // https://w3c.github.io/html-aam/#el-h1-h6\n  // https://w3c.github.io/html-aam/#el-h1-h6\n  const implicitHeadingLevels = {\n    H1: 1,\n    H2: 2,\n    H3: 3,\n    H4: 4,\n    H5: 5,\n    H6: 6\n  };\n  // explicit aria-level value\n  // https://www.w3.org/TR/wai-aria-1.2/#aria-level\n  const ariaLevelAttribute = element.getAttribute('aria-level') && Number(element.getAttribute('aria-level'));\n  return ariaLevelAttribute || implicitHeadingLevels[element.tagName];\n}\n\n/**\n * @param {Element} element -\n * @returns {number | undefined} -\n */\nfunction computeAriaValueNow(element) {\n  const valueNow = element.getAttribute('aria-valuenow');\n  return valueNow === null ? undefined : +valueNow;\n}\n\n/**\n * @param {Element} element -\n * @returns {number | undefined} -\n */\nfunction computeAriaValueMax(element) {\n  const valueMax = element.getAttribute('aria-valuemax');\n  return valueMax === null ? undefined : +valueMax;\n}\n\n/**\n * @param {Element} element -\n * @returns {number | undefined} -\n */\nfunction computeAriaValueMin(element) {\n  const valueMin = element.getAttribute('aria-valuemin');\n  return valueMin === null ? undefined : +valueMin;\n}\n\n/**\n * @param {Element} element -\n * @returns {string | undefined} -\n */\nfunction computeAriaValueText(element) {\n  const valueText = element.getAttribute('aria-valuetext');\n  return valueText === null ? undefined : valueText;\n}\n\nconst normalize = getDefaultNormalizer();\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+\\-?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\nfunction getRegExpMatcher(string) {\n  return new RegExp(escapeRegExp(string.toLowerCase()), 'i');\n}\nfunction makeSuggestion(queryName, element, content, _ref) {\n  let {\n    variant,\n    name\n  } = _ref;\n  let warning = '';\n  const queryOptions = {};\n  const queryArgs = [['Role', 'TestId'].includes(queryName) ? content : getRegExpMatcher(content)];\n  if (name) {\n    queryOptions.name = getRegExpMatcher(name);\n  }\n  if (queryName === 'Role' && isInaccessible(element)) {\n    queryOptions.hidden = true;\n    warning = \"Element is inaccessible. This means that the element and all its children are invisible to screen readers.\\n    If you are using the aria-hidden prop, make sure this is the right choice for your case.\\n    \";\n  }\n  if (Object.keys(queryOptions).length > 0) {\n    queryArgs.push(queryOptions);\n  }\n  const queryMethod = variant + \"By\" + queryName;\n  return {\n    queryName,\n    queryMethod,\n    queryArgs,\n    variant,\n    warning,\n    toString() {\n      if (warning) {\n        console.warn(warning);\n      }\n      let [text, options] = queryArgs;\n      text = typeof text === 'string' ? \"'\" + text + \"'\" : text;\n      options = options ? \", { \" + Object.entries(options).map(_ref2 => {\n        let [k, v] = _ref2;\n        return k + \": \" + v;\n      }).join(', ') + \" }\" : '';\n      return queryMethod + \"(\" + text + options + \")\";\n    }\n  };\n}\nfunction canSuggest(currentMethod, requestedMethod, data) {\n  return data && (!requestedMethod || requestedMethod.toLowerCase() === currentMethod.toLowerCase());\n}\nfunction getSuggestedQuery(element, variant, method) {\n  var _element$getAttribute, _getImplicitAriaRoles;\n  if (variant === void 0) {\n    variant = 'get';\n  }\n  // don't create suggestions for script and style elements\n  if (element.matches(getConfig().defaultIgnore)) {\n    return undefined;\n  }\n\n  //We prefer to suggest something else if the role is generic\n  const role = (_element$getAttribute = element.getAttribute('role')) != null ? _element$getAttribute : (_getImplicitAriaRoles = getImplicitAriaRoles(element)) == null ? void 0 : _getImplicitAriaRoles[0];\n  if (role !== 'generic' && canSuggest('Role', method, role)) {\n    return makeSuggestion('Role', element, role, {\n      variant,\n      name: (0,dom_accessibility_api__WEBPACK_IMPORTED_MODULE_1__/* .computeAccessibleName */ .AB)(element, {\n        computedStyleSupportsPseudoElements: getConfig().computedStyleSupportsPseudoElements\n      })\n    });\n  }\n  const labelText = getLabels(document, element).map(label => label.content).join(' ');\n  if (canSuggest('LabelText', method, labelText)) {\n    return makeSuggestion('LabelText', element, labelText, {\n      variant\n    });\n  }\n  const placeholderText = element.getAttribute('placeholder');\n  if (canSuggest('PlaceholderText', method, placeholderText)) {\n    return makeSuggestion('PlaceholderText', element, placeholderText, {\n      variant\n    });\n  }\n  const textContent = normalize(getNodeText(element));\n  if (canSuggest('Text', method, textContent)) {\n    return makeSuggestion('Text', element, textContent, {\n      variant\n    });\n  }\n  if (canSuggest('DisplayValue', method, element.value)) {\n    return makeSuggestion('DisplayValue', element, normalize(element.value), {\n      variant\n    });\n  }\n  const alt = element.getAttribute('alt');\n  if (canSuggest('AltText', method, alt)) {\n    return makeSuggestion('AltText', element, alt, {\n      variant\n    });\n  }\n  const title = element.getAttribute('title');\n  if (canSuggest('Title', method, title)) {\n    return makeSuggestion('Title', element, title, {\n      variant\n    });\n  }\n  const testId = element.getAttribute(getConfig().testIdAttribute);\n  if (canSuggest('TestId', method, testId)) {\n    return makeSuggestion('TestId', element, testId, {\n      variant\n    });\n  }\n  return undefined;\n}\n\n// This is so the stack trace the developer sees is one that's\n// closer to their code (because async stack traces are hard to follow).\nfunction copyStackTrace(target, source) {\n  target.stack = source.stack.replace(source.message, target.message);\n}\nfunction waitFor(callback, _ref) {\n  let {\n    container = getDocument(),\n    timeout = getConfig().asyncUtilTimeout,\n    showOriginalStackTrace = getConfig().showOriginalStackTrace,\n    stackTraceError,\n    interval = 50,\n    onTimeout = error => {\n      error.message = getConfig().getElementError(error.message, container).message;\n      return error;\n    },\n    mutationObserverOptions = {\n      subtree: true,\n      childList: true,\n      attributes: true,\n      characterData: true\n    }\n  } = _ref;\n  if (typeof callback !== 'function') {\n    throw new TypeError('Received `callback` arg must be a function');\n  }\n  return new Promise(async (resolve, reject) => {\n    let lastError, intervalId, observer;\n    let finished = false;\n    let promiseStatus = 'idle';\n    const overallTimeoutTimer = setTimeout(handleTimeout, timeout);\n    const usingJestFakeTimers = jestFakeTimersAreEnabled();\n    if (usingJestFakeTimers) {\n      const {\n        unstable_advanceTimersWrapper: advanceTimersWrapper\n      } = getConfig();\n      checkCallback();\n      // this is a dangerous rule to disable because it could lead to an\n      // infinite loop. However, eslint isn't smart enough to know that we're\n      // setting finished inside `onDone` which will be called when we're done\n      // waiting or when we've timed out.\n      // eslint-disable-next-line no-unmodified-loop-condition\n      while (!finished) {\n        if (!jestFakeTimersAreEnabled()) {\n          const error = new Error(\"Changed from using fake timers to real timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to real timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830\");\n          if (!showOriginalStackTrace) copyStackTrace(error, stackTraceError);\n          reject(error);\n          return;\n        }\n\n        // In this rare case, we *need* to wait for in-flight promises\n        // to resolve before continuing. We don't need to take advantage\n        // of parallelization so we're fine.\n        // https://stackoverflow.com/a/59243586/971592\n        // eslint-disable-next-line no-await-in-loop\n        await advanceTimersWrapper(async () => {\n          // we *could* (maybe should?) use `advanceTimersToNextTimer` but it's\n          // possible that could make this loop go on forever if someone is using\n          // third party code that's setting up recursive timers so rapidly that\n          // the user's timer's don't get a chance to resolve. So we'll advance\n          // by an interval instead. (We have a test for this case).\n          jest.advanceTimersByTime(interval);\n        });\n\n        // It's really important that checkCallback is run *before* we flush\n        // in-flight promises. To be honest, I'm not sure why, and I can't quite\n        // think of a way to reproduce the problem in a test, but I spent\n        // an entire day banging my head against a wall on this.\n        checkCallback();\n        if (finished) {\n          break;\n        }\n      }\n    } else {\n      try {\n        checkContainerType(container);\n      } catch (e) {\n        reject(e);\n        return;\n      }\n      intervalId = setInterval(checkRealTimersCallback, interval);\n      const {\n        MutationObserver\n      } = getWindowFromNode(container);\n      observer = new MutationObserver(checkRealTimersCallback);\n      observer.observe(container, mutationObserverOptions);\n      checkCallback();\n    }\n    function onDone(error, result) {\n      finished = true;\n      clearTimeout(overallTimeoutTimer);\n      if (!usingJestFakeTimers) {\n        clearInterval(intervalId);\n        observer.disconnect();\n      }\n      if (error) {\n        reject(error);\n      } else {\n        resolve(result);\n      }\n    }\n    function checkRealTimersCallback() {\n      if (jestFakeTimersAreEnabled()) {\n        const error = new Error(\"Changed from using real timers to fake timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to fake timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830\");\n        if (!showOriginalStackTrace) copyStackTrace(error, stackTraceError);\n        return reject(error);\n      } else {\n        return checkCallback();\n      }\n    }\n    function checkCallback() {\n      if (promiseStatus === 'pending') return;\n      try {\n        const result = runWithExpensiveErrorDiagnosticsDisabled(callback);\n        if (typeof (result == null ? void 0 : result.then) === 'function') {\n          promiseStatus = 'pending';\n          result.then(resolvedValue => {\n            promiseStatus = 'resolved';\n            onDone(null, resolvedValue);\n          }, rejectedValue => {\n            promiseStatus = 'rejected';\n            lastError = rejectedValue;\n          });\n        } else {\n          onDone(null, result);\n        }\n        // If `callback` throws, wait for the next mutation, interval, or timeout.\n      } catch (error) {\n        // Save the most recent callback error to reject the promise with it in the event of a timeout\n        lastError = error;\n      }\n    }\n    function handleTimeout() {\n      let error;\n      if (lastError) {\n        error = lastError;\n        if (!showOriginalStackTrace && error.name === 'TestingLibraryElementError') {\n          copyStackTrace(error, stackTraceError);\n        }\n      } else {\n        error = new Error('Timed out in waitFor.');\n        if (!showOriginalStackTrace) {\n          copyStackTrace(error, stackTraceError);\n        }\n      }\n      onDone(onTimeout(error), null);\n    }\n  });\n}\nfunction waitForWrapper(callback, options) {\n  // create the error here so its stack trace is as close to the\n  // calling code as possible\n  const stackTraceError = new Error('STACK_TRACE_MESSAGE');\n  return getConfig().asyncWrapper(() => waitFor(callback, {\n    stackTraceError,\n    ...options\n  }));\n}\n\n/*\neslint\n  max-lines-per-function: [\"error\", {\"max\": 200}],\n*/\n\nfunction getElementError(message, container) {\n  return getConfig().getElementError(message, container);\n}\nfunction getMultipleElementsFoundError(message, container) {\n  return getElementError(message + \"\\n\\n(If this is intentional, then use the `*AllBy*` variant of the query (like `queryAllByText`, `getAllByText`, or `findAllByText`)).\", container);\n}\nfunction queryAllByAttribute(attribute, container, text, _temp) {\n  let {\n    exact = true,\n    collapseWhitespace,\n    trim,\n    normalizer\n  } = _temp === void 0 ? {} : _temp;\n  const matcher = exact ? matches : fuzzyMatches;\n  const matchNormalizer = makeNormalizer({\n    collapseWhitespace,\n    trim,\n    normalizer\n  });\n  return Array.from(container.querySelectorAll(\"[\" + attribute + \"]\")).filter(node => matcher(node.getAttribute(attribute), node, text, matchNormalizer));\n}\nfunction queryByAttribute(attribute, container, text, options) {\n  const els = queryAllByAttribute(attribute, container, text, options);\n  if (els.length > 1) {\n    throw getMultipleElementsFoundError(\"Found multiple elements by [\" + attribute + \"=\" + text + \"]\", container);\n  }\n  return els[0] || null;\n}\n\n// this accepts a query function and returns a function which throws an error\n// if more than one elements is returned, otherwise it returns the first\n// element or null\nfunction makeSingleQuery(allQuery, getMultipleError) {\n  return function (container) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    const els = allQuery(container, ...args);\n    if (els.length > 1) {\n      const elementStrings = els.map(element => getElementError(null, element).message).join('\\n\\n');\n      throw getMultipleElementsFoundError(getMultipleError(container, ...args) + \"\\n\\nHere are the matching elements:\\n\\n\" + elementStrings, container);\n    }\n    return els[0] || null;\n  };\n}\nfunction getSuggestionError(suggestion, container) {\n  return getConfig().getElementError(\"A better query is available, try this:\\n\" + suggestion.toString() + \"\\n\", container);\n}\n\n// this accepts a query function and returns a function which throws an error\n// if an empty list of elements is returned\nfunction makeGetAllQuery(allQuery, getMissingError) {\n  return function (container) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    const els = allQuery(container, ...args);\n    if (!els.length) {\n      throw getConfig().getElementError(getMissingError(container, ...args), container);\n    }\n    return els;\n  };\n}\n\n// this accepts a getter query function and returns a function which calls\n// waitFor and passing a function which invokes the getter.\nfunction makeFindQuery(getter) {\n  return (container, text, options, waitForOptions) => {\n    return waitForWrapper(() => {\n      return getter(container, text, options);\n    }, {\n      container,\n      ...waitForOptions\n    });\n  };\n}\nconst wrapSingleQueryWithSuggestion = (query, queryAllByName, variant) => function (container) {\n  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    args[_key3 - 1] = arguments[_key3];\n  }\n  const element = query(container, ...args);\n  const [{\n    suggest = getConfig().throwSuggestions\n  } = {}] = args.slice(-1);\n  if (element && suggest) {\n    const suggestion = getSuggestedQuery(element, variant);\n    if (suggestion && !queryAllByName.endsWith(suggestion.queryName)) {\n      throw getSuggestionError(suggestion.toString(), container);\n    }\n  }\n  return element;\n};\nconst wrapAllByQueryWithSuggestion = (query, queryAllByName, variant) => function (container) {\n  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    args[_key4 - 1] = arguments[_key4];\n  }\n  const els = query(container, ...args);\n  const [{\n    suggest = getConfig().throwSuggestions\n  } = {}] = args.slice(-1);\n  if (els.length && suggest) {\n    // get a unique list of all suggestion messages.  We are only going to make a suggestion if\n    // all the suggestions are the same\n    const uniqueSuggestionMessages = [...new Set(els.map(element => {\n      var _getSuggestedQuery;\n      return (_getSuggestedQuery = getSuggestedQuery(element, variant)) == null ? void 0 : _getSuggestedQuery.toString();\n    }))];\n    if (\n    // only want to suggest if all the els have the same suggestion.\n    uniqueSuggestionMessages.length === 1 && !queryAllByName.endsWith(\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- TODO: Can this be null at runtime?\n    getSuggestedQuery(els[0], variant).queryName)) {\n      throw getSuggestionError(uniqueSuggestionMessages[0], container);\n    }\n  }\n  return els;\n};\n\n// TODO: This deviates from the published declarations\n// However, the implementation always required a dyadic (after `container`) not variadic `queryAllBy` considering the implementation of `makeFindQuery`\n// This is at least statically true and can be verified by accepting `QueryMethod<Arguments, HTMLElement[]>`\nfunction buildQueries(queryAllBy, getMultipleError, getMissingError) {\n  const queryBy = wrapSingleQueryWithSuggestion(makeSingleQuery(queryAllBy, getMultipleError), queryAllBy.name, 'query');\n  const getAllBy = makeGetAllQuery(queryAllBy, getMissingError);\n  const getBy = makeSingleQuery(getAllBy, getMultipleError);\n  const getByWithSuggestions = wrapSingleQueryWithSuggestion(getBy, queryAllBy.name, 'get');\n  const getAllWithSuggestions = wrapAllByQueryWithSuggestion(getAllBy, queryAllBy.name.replace('query', 'get'), 'getAll');\n  const findAllBy = makeFindQuery(wrapAllByQueryWithSuggestion(getAllBy, queryAllBy.name, 'findAll'));\n  const findBy = makeFindQuery(wrapSingleQueryWithSuggestion(getBy, queryAllBy.name, 'find'));\n  return [queryBy, getAllWithSuggestions, getByWithSuggestions, findAllBy, findBy];\n}\n\nvar queryHelpers = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  getElementError: getElementError,\n  wrapAllByQueryWithSuggestion: wrapAllByQueryWithSuggestion,\n  wrapSingleQueryWithSuggestion: wrapSingleQueryWithSuggestion,\n  getMultipleElementsFoundError: getMultipleElementsFoundError,\n  queryAllByAttribute: queryAllByAttribute,\n  queryByAttribute: queryByAttribute,\n  makeSingleQuery: makeSingleQuery,\n  makeGetAllQuery: makeGetAllQuery,\n  makeFindQuery: makeFindQuery,\n  buildQueries: buildQueries\n});\n\nfunction queryAllLabels(container) {\n  return Array.from(container.querySelectorAll('label,input')).map(node => {\n    return {\n      node,\n      textToMatch: getLabelContent(node)\n    };\n  }).filter(_ref => {\n    let {\n      textToMatch\n    } = _ref;\n    return textToMatch !== null;\n  });\n}\nconst queryAllLabelsByText = function (container, text, _temp) {\n  let {\n    exact = true,\n    trim,\n    collapseWhitespace,\n    normalizer\n  } = _temp === void 0 ? {} : _temp;\n  const matcher = exact ? matches : fuzzyMatches;\n  const matchNormalizer = makeNormalizer({\n    collapseWhitespace,\n    trim,\n    normalizer\n  });\n  const textToMatchByLabels = queryAllLabels(container);\n  return textToMatchByLabels.filter(_ref2 => {\n    let {\n      node,\n      textToMatch\n    } = _ref2;\n    return matcher(textToMatch, node, text, matchNormalizer);\n  }).map(_ref3 => {\n    let {\n      node\n    } = _ref3;\n    return node;\n  });\n};\nconst queryAllByLabelText = function (container, text, _temp2) {\n  let {\n    selector = '*',\n    exact = true,\n    collapseWhitespace,\n    trim,\n    normalizer\n  } = _temp2 === void 0 ? {} : _temp2;\n  checkContainerType(container);\n  const matcher = exact ? matches : fuzzyMatches;\n  const matchNormalizer = makeNormalizer({\n    collapseWhitespace,\n    trim,\n    normalizer\n  });\n  const matchingLabelledElements = Array.from(container.querySelectorAll('*')).filter(element => {\n    return getRealLabels(element).length || element.hasAttribute('aria-labelledby');\n  }).reduce((labelledElements, labelledElement) => {\n    const labelList = getLabels(container, labelledElement, {\n      selector\n    });\n    labelList.filter(label => Boolean(label.formControl)).forEach(label => {\n      if (matcher(label.content, label.formControl, text, matchNormalizer) && label.formControl) {\n        labelledElements.push(label.formControl);\n      }\n    });\n    const labelsValue = labelList.filter(label => Boolean(label.content)).map(label => label.content);\n    if (matcher(labelsValue.join(' '), labelledElement, text, matchNormalizer)) {\n      labelledElements.push(labelledElement);\n    }\n    if (labelsValue.length > 1) {\n      labelsValue.forEach((labelValue, index) => {\n        if (matcher(labelValue, labelledElement, text, matchNormalizer)) {\n          labelledElements.push(labelledElement);\n        }\n        const labelsFiltered = [...labelsValue];\n        labelsFiltered.splice(index, 1);\n        if (labelsFiltered.length > 1) {\n          if (matcher(labelsFiltered.join(' '), labelledElement, text, matchNormalizer)) {\n            labelledElements.push(labelledElement);\n          }\n        }\n      });\n    }\n    return labelledElements;\n  }, []).concat(queryAllByAttribute('aria-label', container, text, {\n    exact,\n    normalizer: matchNormalizer\n  }));\n  return Array.from(new Set(matchingLabelledElements)).filter(element => element.matches(selector));\n};\n\n// the getAll* query would normally look like this:\n// const getAllByLabelText = makeGetAllQuery(\n//   queryAllByLabelText,\n//   (c, text) => `Unable to find a label with the text of: ${text}`,\n// )\n// however, we can give a more helpful error message than the generic one,\n// so we're writing this one out by hand.\nconst getAllByLabelText = function (container, text) {\n  for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    rest[_key - 2] = arguments[_key];\n  }\n  const els = queryAllByLabelText(container, text, ...rest);\n  if (!els.length) {\n    const labels = queryAllLabelsByText(container, text, ...rest);\n    if (labels.length) {\n      const tagNames = labels.map(label => getTagNameOfElementAssociatedWithLabelViaFor(container, label)).filter(tagName => !!tagName);\n      if (tagNames.length) {\n        throw getConfig().getElementError(tagNames.map(tagName => \"Found a label with the text of: \" + text + \", however the element associated with this label (<\" + tagName + \" />) is non-labellable [https://html.spec.whatwg.org/multipage/forms.html#category-label]. If you really need to label a <\" + tagName + \" />, you can use aria-label or aria-labelledby instead.\").join('\\n\\n'), container);\n      } else {\n        throw getConfig().getElementError(\"Found a label with the text of: \" + text + \", however no form control was found associated to that label. Make sure you're using the \\\"for\\\" attribute or \\\"aria-labelledby\\\" attribute correctly.\", container);\n      }\n    } else {\n      throw getConfig().getElementError(\"Unable to find a label with the text of: \" + text, container);\n    }\n  }\n  return els;\n};\nfunction getTagNameOfElementAssociatedWithLabelViaFor(container, label) {\n  const htmlFor = label.getAttribute('for');\n  if (!htmlFor) {\n    return null;\n  }\n  const element = container.querySelector(\"[id=\\\"\" + htmlFor + \"\\\"]\");\n  return element ? element.tagName.toLowerCase() : null;\n}\n\n// the reason mentioned above is the same reason we're not using buildQueries\nconst getMultipleError$7 = (c, text) => \"Found multiple elements with the text of: \" + text;\nconst queryByLabelText = wrapSingleQueryWithSuggestion(makeSingleQuery(queryAllByLabelText, getMultipleError$7), queryAllByLabelText.name, 'query');\nconst getByLabelText = makeSingleQuery(getAllByLabelText, getMultipleError$7);\nconst findAllByLabelText = makeFindQuery(wrapAllByQueryWithSuggestion(getAllByLabelText, getAllByLabelText.name, 'findAll'));\nconst findByLabelText = makeFindQuery(wrapSingleQueryWithSuggestion(getByLabelText, getAllByLabelText.name, 'find'));\nconst getAllByLabelTextWithSuggestions = wrapAllByQueryWithSuggestion(getAllByLabelText, getAllByLabelText.name, 'getAll');\nconst getByLabelTextWithSuggestions = wrapSingleQueryWithSuggestion(getByLabelText, getAllByLabelText.name, 'get');\nconst queryAllByLabelTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByLabelText, queryAllByLabelText.name, 'queryAll');\n\nconst queryAllByPlaceholderText = function () {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  checkContainerType(args[0]);\n  return queryAllByAttribute('placeholder', ...args);\n};\nconst getMultipleError$6 = (c, text) => \"Found multiple elements with the placeholder text of: \" + text;\nconst getMissingError$6 = (c, text) => \"Unable to find an element with the placeholder text of: \" + text;\nconst queryAllByPlaceholderTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByPlaceholderText, queryAllByPlaceholderText.name, 'queryAll');\nconst [queryByPlaceholderText, getAllByPlaceholderText, getByPlaceholderText, findAllByPlaceholderText, findByPlaceholderText] = buildQueries(queryAllByPlaceholderText, getMultipleError$6, getMissingError$6);\n\nconst queryAllByText = function (container, text, _temp) {\n  let {\n    selector = '*',\n    exact = true,\n    collapseWhitespace,\n    trim,\n    ignore = getConfig().defaultIgnore,\n    normalizer\n  } = _temp === void 0 ? {} : _temp;\n  checkContainerType(container);\n  const matcher = exact ? matches : fuzzyMatches;\n  const matchNormalizer = makeNormalizer({\n    collapseWhitespace,\n    trim,\n    normalizer\n  });\n  let baseArray = [];\n  if (typeof container.matches === 'function' && container.matches(selector)) {\n    baseArray = [container];\n  }\n  return [...baseArray, ...Array.from(container.querySelectorAll(selector))]\n  // TODO: `matches` according lib.dom.d.ts can get only `string` but according our code it can handle also boolean :)\n  .filter(node => !ignore || !node.matches(ignore)).filter(node => matcher(getNodeText(node), node, text, matchNormalizer));\n};\nconst getMultipleError$5 = (c, text) => \"Found multiple elements with the text: \" + text;\nconst getMissingError$5 = function (c, text, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    collapseWhitespace,\n    trim,\n    normalizer,\n    selector\n  } = options;\n  const matchNormalizer = makeNormalizer({\n    collapseWhitespace,\n    trim,\n    normalizer\n  });\n  const normalizedText = matchNormalizer(text.toString());\n  const isNormalizedDifferent = normalizedText !== text.toString();\n  const isCustomSelector = (selector != null ? selector : '*') !== '*';\n  return \"Unable to find an element with the text: \" + (isNormalizedDifferent ? normalizedText + \" (normalized from '\" + text + \"')\" : text) + (isCustomSelector ? \", which matches selector '\" + selector + \"'\" : '') + \". This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.\";\n};\nconst queryAllByTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByText, queryAllByText.name, 'queryAll');\nconst [queryByText, getAllByText, getByText, findAllByText, findByText] = buildQueries(queryAllByText, getMultipleError$5, getMissingError$5);\n\nconst queryAllByDisplayValue = function (container, value, _temp) {\n  let {\n    exact = true,\n    collapseWhitespace,\n    trim,\n    normalizer\n  } = _temp === void 0 ? {} : _temp;\n  checkContainerType(container);\n  const matcher = exact ? matches : fuzzyMatches;\n  const matchNormalizer = makeNormalizer({\n    collapseWhitespace,\n    trim,\n    normalizer\n  });\n  return Array.from(container.querySelectorAll(\"input,textarea,select\")).filter(node => {\n    if (node.tagName === 'SELECT') {\n      const selectedOptions = Array.from(node.options).filter(option => option.selected);\n      return selectedOptions.some(optionNode => matcher(getNodeText(optionNode), optionNode, value, matchNormalizer));\n    } else {\n      return matcher(node.value, node, value, matchNormalizer);\n    }\n  });\n};\nconst getMultipleError$4 = (c, value) => \"Found multiple elements with the display value: \" + value + \".\";\nconst getMissingError$4 = (c, value) => \"Unable to find an element with the display value: \" + value + \".\";\nconst queryAllByDisplayValueWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByDisplayValue, queryAllByDisplayValue.name, 'queryAll');\nconst [queryByDisplayValue, getAllByDisplayValue, getByDisplayValue, findAllByDisplayValue, findByDisplayValue] = buildQueries(queryAllByDisplayValue, getMultipleError$4, getMissingError$4);\n\n// Valid tags are img, input, area and custom elements\nconst VALID_TAG_REGEXP = /^(img|input|area|.+-.+)$/i;\nconst queryAllByAltText = function (container, alt, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  checkContainerType(container);\n  return queryAllByAttribute('alt', container, alt, options).filter(node => VALID_TAG_REGEXP.test(node.tagName));\n};\nconst getMultipleError$3 = (c, alt) => \"Found multiple elements with the alt text: \" + alt;\nconst getMissingError$3 = (c, alt) => \"Unable to find an element with the alt text: \" + alt;\nconst queryAllByAltTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByAltText, queryAllByAltText.name, 'queryAll');\nconst [queryByAltText, getAllByAltText, getByAltText, findAllByAltText, findByAltText] = buildQueries(queryAllByAltText, getMultipleError$3, getMissingError$3);\n\nconst isSvgTitle = node => {\n  var _node$parentElement;\n  return node.tagName.toLowerCase() === 'title' && ((_node$parentElement = node.parentElement) == null ? void 0 : _node$parentElement.tagName.toLowerCase()) === 'svg';\n};\nconst queryAllByTitle = function (container, text, _temp) {\n  let {\n    exact = true,\n    collapseWhitespace,\n    trim,\n    normalizer\n  } = _temp === void 0 ? {} : _temp;\n  checkContainerType(container);\n  const matcher = exact ? matches : fuzzyMatches;\n  const matchNormalizer = makeNormalizer({\n    collapseWhitespace,\n    trim,\n    normalizer\n  });\n  return Array.from(container.querySelectorAll('[title], svg > title')).filter(node => matcher(node.getAttribute('title'), node, text, matchNormalizer) || isSvgTitle(node) && matcher(getNodeText(node), node, text, matchNormalizer));\n};\nconst getMultipleError$2 = (c, title) => \"Found multiple elements with the title: \" + title + \".\";\nconst getMissingError$2 = (c, title) => \"Unable to find an element with the title: \" + title + \".\";\nconst queryAllByTitleWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByTitle, queryAllByTitle.name, 'queryAll');\nconst [queryByTitle, getAllByTitle, getByTitle, findAllByTitle, findByTitle] = buildQueries(queryAllByTitle, getMultipleError$2, getMissingError$2);\n\n/* eslint-disable complexity */\nconst queryAllByRole = function (container, role, _temp) {\n  let {\n    hidden = getConfig().defaultHidden,\n    name,\n    description,\n    queryFallbacks = false,\n    selected,\n    busy,\n    checked,\n    pressed,\n    current,\n    level,\n    expanded,\n    value: {\n      now: valueNow,\n      min: valueMin,\n      max: valueMax,\n      text: valueText\n    } = {}\n  } = _temp === void 0 ? {} : _temp;\n  checkContainerType(container);\n  if (selected !== undefined) {\n    var _allRoles$get;\n    // guard against unknown roles\n    if (((_allRoles$get = aria_query__WEBPACK_IMPORTED_MODULE_2__/* .roles */ .uJ.get(role)) == null ? void 0 : _allRoles$get.props['aria-selected']) === undefined) {\n      throw new Error(\"\\\"aria-selected\\\" is not supported on role \\\"\" + role + \"\\\".\");\n    }\n  }\n  if (busy !== undefined) {\n    var _allRoles$get2;\n    // guard against unknown roles\n    if (((_allRoles$get2 = aria_query__WEBPACK_IMPORTED_MODULE_2__/* .roles */ .uJ.get(role)) == null ? void 0 : _allRoles$get2.props['aria-busy']) === undefined) {\n      throw new Error(\"\\\"aria-busy\\\" is not supported on role \\\"\" + role + \"\\\".\");\n    }\n  }\n  if (checked !== undefined) {\n    var _allRoles$get3;\n    // guard against unknown roles\n    if (((_allRoles$get3 = aria_query__WEBPACK_IMPORTED_MODULE_2__/* .roles */ .uJ.get(role)) == null ? void 0 : _allRoles$get3.props['aria-checked']) === undefined) {\n      throw new Error(\"\\\"aria-checked\\\" is not supported on role \\\"\" + role + \"\\\".\");\n    }\n  }\n  if (pressed !== undefined) {\n    var _allRoles$get4;\n    // guard against unknown roles\n    if (((_allRoles$get4 = aria_query__WEBPACK_IMPORTED_MODULE_2__/* .roles */ .uJ.get(role)) == null ? void 0 : _allRoles$get4.props['aria-pressed']) === undefined) {\n      throw new Error(\"\\\"aria-pressed\\\" is not supported on role \\\"\" + role + \"\\\".\");\n    }\n  }\n  if (current !== undefined) {\n    var _allRoles$get5;\n    /* istanbul ignore next */\n    // guard against unknown roles\n    // All currently released ARIA versions support `aria-current` on all roles.\n    // Leaving this for symetry and forward compatibility\n    if (((_allRoles$get5 = aria_query__WEBPACK_IMPORTED_MODULE_2__/* .roles */ .uJ.get(role)) == null ? void 0 : _allRoles$get5.props['aria-current']) === undefined) {\n      throw new Error(\"\\\"aria-current\\\" is not supported on role \\\"\" + role + \"\\\".\");\n    }\n  }\n  if (level !== undefined) {\n    // guard against using `level` option with any role other than `heading`\n    if (role !== 'heading') {\n      throw new Error(\"Role \\\"\" + role + \"\\\" cannot have \\\"level\\\" property.\");\n    }\n  }\n  if (valueNow !== undefined) {\n    var _allRoles$get6;\n    // guard against unknown roles\n    if (((_allRoles$get6 = aria_query__WEBPACK_IMPORTED_MODULE_2__/* .roles */ .uJ.get(role)) == null ? void 0 : _allRoles$get6.props['aria-valuenow']) === undefined) {\n      throw new Error(\"\\\"aria-valuenow\\\" is not supported on role \\\"\" + role + \"\\\".\");\n    }\n  }\n  if (valueMax !== undefined) {\n    var _allRoles$get7;\n    // guard against unknown roles\n    if (((_allRoles$get7 = aria_query__WEBPACK_IMPORTED_MODULE_2__/* .roles */ .uJ.get(role)) == null ? void 0 : _allRoles$get7.props['aria-valuemax']) === undefined) {\n      throw new Error(\"\\\"aria-valuemax\\\" is not supported on role \\\"\" + role + \"\\\".\");\n    }\n  }\n  if (valueMin !== undefined) {\n    var _allRoles$get8;\n    // guard against unknown roles\n    if (((_allRoles$get8 = aria_query__WEBPACK_IMPORTED_MODULE_2__/* .roles */ .uJ.get(role)) == null ? void 0 : _allRoles$get8.props['aria-valuemin']) === undefined) {\n      throw new Error(\"\\\"aria-valuemin\\\" is not supported on role \\\"\" + role + \"\\\".\");\n    }\n  }\n  if (valueText !== undefined) {\n    var _allRoles$get9;\n    // guard against unknown roles\n    if (((_allRoles$get9 = aria_query__WEBPACK_IMPORTED_MODULE_2__/* .roles */ .uJ.get(role)) == null ? void 0 : _allRoles$get9.props['aria-valuetext']) === undefined) {\n      throw new Error(\"\\\"aria-valuetext\\\" is not supported on role \\\"\" + role + \"\\\".\");\n    }\n  }\n  if (expanded !== undefined) {\n    var _allRoles$get10;\n    // guard against unknown roles\n    if (((_allRoles$get10 = aria_query__WEBPACK_IMPORTED_MODULE_2__/* .roles */ .uJ.get(role)) == null ? void 0 : _allRoles$get10.props['aria-expanded']) === undefined) {\n      throw new Error(\"\\\"aria-expanded\\\" is not supported on role \\\"\" + role + \"\\\".\");\n    }\n  }\n  const subtreeIsInaccessibleCache = new WeakMap();\n  function cachedIsSubtreeInaccessible(element) {\n    if (!subtreeIsInaccessibleCache.has(element)) {\n      subtreeIsInaccessibleCache.set(element, isSubtreeInaccessible(element));\n    }\n    return subtreeIsInaccessibleCache.get(element);\n  }\n  return Array.from(container.querySelectorAll(\n  // Only query elements that can be matched by the following filters\n  makeRoleSelector(role))).filter(node => {\n    const isRoleSpecifiedExplicitly = node.hasAttribute('role');\n    if (isRoleSpecifiedExplicitly) {\n      const roleValue = node.getAttribute('role');\n      if (queryFallbacks) {\n        return roleValue.split(' ').filter(Boolean).some(roleAttributeToken => roleAttributeToken === role);\n      }\n      // other wise only send the first token to match\n      const [firstRoleAttributeToken] = roleValue.split(' ');\n      return firstRoleAttributeToken === role;\n    }\n    const implicitRoles = getImplicitAriaRoles(node);\n    return implicitRoles.some(implicitRole => {\n      return implicitRole === role;\n    });\n  }).filter(element => {\n    if (selected !== undefined) {\n      return selected === computeAriaSelected(element);\n    }\n    if (busy !== undefined) {\n      return busy === computeAriaBusy(element);\n    }\n    if (checked !== undefined) {\n      return checked === computeAriaChecked(element);\n    }\n    if (pressed !== undefined) {\n      return pressed === computeAriaPressed(element);\n    }\n    if (current !== undefined) {\n      return current === computeAriaCurrent(element);\n    }\n    if (expanded !== undefined) {\n      return expanded === computeAriaExpanded(element);\n    }\n    if (level !== undefined) {\n      return level === computeHeadingLevel(element);\n    }\n    if (valueNow !== undefined || valueMax !== undefined || valueMin !== undefined || valueText !== undefined) {\n      let valueMatches = true;\n      if (valueNow !== undefined) {\n        valueMatches && (valueMatches = valueNow === computeAriaValueNow(element));\n      }\n      if (valueMax !== undefined) {\n        valueMatches && (valueMatches = valueMax === computeAriaValueMax(element));\n      }\n      if (valueMin !== undefined) {\n        valueMatches && (valueMatches = valueMin === computeAriaValueMin(element));\n      }\n      if (valueText !== undefined) {\n        var _computeAriaValueText;\n        valueMatches && (valueMatches = matches((_computeAriaValueText = computeAriaValueText(element)) != null ? _computeAriaValueText : null, element, valueText, text => text));\n      }\n      return valueMatches;\n    }\n    // don't care if aria attributes are unspecified\n    return true;\n  }).filter(element => {\n    if (name === undefined) {\n      // Don't care\n      return true;\n    }\n    return matches((0,dom_accessibility_api__WEBPACK_IMPORTED_MODULE_1__/* .computeAccessibleName */ .AB)(element, {\n      computedStyleSupportsPseudoElements: getConfig().computedStyleSupportsPseudoElements\n    }), element, name, text => text);\n  }).filter(element => {\n    if (description === undefined) {\n      // Don't care\n      return true;\n    }\n    return matches((0,dom_accessibility_api__WEBPACK_IMPORTED_MODULE_1__/* .computeAccessibleDescription */ .b)(element, {\n      computedStyleSupportsPseudoElements: getConfig().computedStyleSupportsPseudoElements\n    }), element, description, text => text);\n  }).filter(element => {\n    return hidden === false ? isInaccessible(element, {\n      isSubtreeInaccessible: cachedIsSubtreeInaccessible\n    }) === false : true;\n  });\n};\nfunction makeRoleSelector(role) {\n  var _roleElements$get;\n  const explicitRoleSelector = \"*[role~=\\\"\" + role + \"\\\"]\";\n  const roleRelations = (_roleElements$get = aria_query__WEBPACK_IMPORTED_MODULE_2__/* .roleElements */ .UN.get(role)) != null ? _roleElements$get : new Set();\n  const implicitRoleSelectors = new Set(Array.from(roleRelations).map(_ref => {\n    let {\n      name\n    } = _ref;\n    return name;\n  }));\n\n  // Current transpilation config sometimes assumes `...` is always applied to arrays.\n  // `...` is equivalent to `Array.prototype.concat` for arrays.\n  // If you replace this code with `[explicitRoleSelector, ...implicitRoleSelectors]`, make sure every transpilation target retains the `...` in favor of `Array.prototype.concat`.\n  return [explicitRoleSelector].concat(Array.from(implicitRoleSelectors)).join(',');\n}\nconst getNameHint = name => {\n  let nameHint = '';\n  if (name === undefined) {\n    nameHint = '';\n  } else if (typeof name === 'string') {\n    nameHint = \" and name \\\"\" + name + \"\\\"\";\n  } else {\n    nameHint = \" and name `\" + name + \"`\";\n  }\n  return nameHint;\n};\nconst getMultipleError$1 = function (c, role, _temp2) {\n  let {\n    name\n  } = _temp2 === void 0 ? {} : _temp2;\n  return \"Found multiple elements with the role \\\"\" + role + \"\\\"\" + getNameHint(name);\n};\nconst getMissingError$1 = function (container, role, _temp3) {\n  let {\n    hidden = getConfig().defaultHidden,\n    name,\n    description\n  } = _temp3 === void 0 ? {} : _temp3;\n  if (getConfig()._disableExpensiveErrorDiagnostics) {\n    return \"Unable to find role=\\\"\" + role + \"\\\"\" + getNameHint(name);\n  }\n  let roles = '';\n  Array.from(container.children).forEach(childElement => {\n    roles += prettyRoles(childElement, {\n      hidden,\n      includeDescription: description !== undefined\n    });\n  });\n  let roleMessage;\n  if (roles.length === 0) {\n    if (hidden === false) {\n      roleMessage = 'There are no accessible roles. But there might be some inaccessible roles. ' + 'If you wish to access them, then set the `hidden` option to `true`. ' + 'Learn more about this here: https://testing-library.com/docs/dom-testing-library/api-queries#byrole';\n    } else {\n      roleMessage = 'There are no available roles.';\n    }\n  } else {\n    roleMessage = (\"\\nHere are the \" + (hidden === false ? 'accessible' : 'available') + \" roles:\\n\\n  \" + roles.replace(/\\n/g, '\\n  ').replace(/\\n\\s\\s\\n/g, '\\n\\n') + \"\\n\").trim();\n  }\n  let nameHint = '';\n  if (name === undefined) {\n    nameHint = '';\n  } else if (typeof name === 'string') {\n    nameHint = \" and name \\\"\" + name + \"\\\"\";\n  } else {\n    nameHint = \" and name `\" + name + \"`\";\n  }\n  let descriptionHint = '';\n  if (description === undefined) {\n    descriptionHint = '';\n  } else if (typeof description === 'string') {\n    descriptionHint = \" and description \\\"\" + description + \"\\\"\";\n  } else {\n    descriptionHint = \" and description `\" + description + \"`\";\n  }\n  return (\"\\nUnable to find an \" + (hidden === false ? 'accessible ' : '') + \"element with the role \\\"\" + role + \"\\\"\" + nameHint + descriptionHint + \"\\n\\n\" + roleMessage).trim();\n};\nconst queryAllByRoleWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByRole, queryAllByRole.name, 'queryAll');\nconst [queryByRole, getAllByRole, getByRole, findAllByRole, findByRole] = buildQueries(queryAllByRole, getMultipleError$1, getMissingError$1);\n\nconst getTestIdAttribute = () => getConfig().testIdAttribute;\nconst queryAllByTestId = function () {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  checkContainerType(args[0]);\n  return queryAllByAttribute(getTestIdAttribute(), ...args);\n};\nconst getMultipleError = (c, id) => \"Found multiple elements by: [\" + getTestIdAttribute() + \"=\\\"\" + id + \"\\\"]\";\nconst getMissingError = (c, id) => \"Unable to find an element by: [\" + getTestIdAttribute() + \"=\\\"\" + id + \"\\\"]\";\nconst queryAllByTestIdWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByTestId, queryAllByTestId.name, 'queryAll');\nconst [queryByTestId, getAllByTestId, getByTestId, findAllByTestId, findByTestId] = buildQueries(queryAllByTestId, getMultipleError, getMissingError);\n\nvar queries = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  queryAllByLabelText: queryAllByLabelTextWithSuggestions,\n  queryByLabelText: queryByLabelText,\n  getAllByLabelText: getAllByLabelTextWithSuggestions,\n  getByLabelText: getByLabelTextWithSuggestions,\n  findAllByLabelText: findAllByLabelText,\n  findByLabelText: findByLabelText,\n  queryByPlaceholderText: queryByPlaceholderText,\n  queryAllByPlaceholderText: queryAllByPlaceholderTextWithSuggestions,\n  getByPlaceholderText: getByPlaceholderText,\n  getAllByPlaceholderText: getAllByPlaceholderText,\n  findAllByPlaceholderText: findAllByPlaceholderText,\n  findByPlaceholderText: findByPlaceholderText,\n  queryByText: queryByText,\n  queryAllByText: queryAllByTextWithSuggestions,\n  getByText: getByText,\n  getAllByText: getAllByText,\n  findAllByText: findAllByText,\n  findByText: findByText,\n  queryByDisplayValue: queryByDisplayValue,\n  queryAllByDisplayValue: queryAllByDisplayValueWithSuggestions,\n  getByDisplayValue: getByDisplayValue,\n  getAllByDisplayValue: getAllByDisplayValue,\n  findAllByDisplayValue: findAllByDisplayValue,\n  findByDisplayValue: findByDisplayValue,\n  queryByAltText: queryByAltText,\n  queryAllByAltText: queryAllByAltTextWithSuggestions,\n  getByAltText: getByAltText,\n  getAllByAltText: getAllByAltText,\n  findAllByAltText: findAllByAltText,\n  findByAltText: findByAltText,\n  queryByTitle: queryByTitle,\n  queryAllByTitle: queryAllByTitleWithSuggestions,\n  getByTitle: getByTitle,\n  getAllByTitle: getAllByTitle,\n  findAllByTitle: findAllByTitle,\n  findByTitle: findByTitle,\n  queryByRole: queryByRole,\n  queryAllByRole: queryAllByRoleWithSuggestions,\n  getAllByRole: getAllByRole,\n  getByRole: getByRole,\n  findAllByRole: findAllByRole,\n  findByRole: findByRole,\n  queryByTestId: queryByTestId,\n  queryAllByTestId: queryAllByTestIdWithSuggestions,\n  getByTestId: getByTestId,\n  getAllByTestId: getAllByTestId,\n  findAllByTestId: findAllByTestId,\n  findByTestId: findByTestId\n});\n\n/**\n * @typedef {{[key: string]: Function}} FuncMap\n */\n\n/**\n * @param {HTMLElement} element container\n * @param {FuncMap} queries object of functions\n * @param {Object} initialValue for reducer\n * @returns {FuncMap} returns object of functions bound to container\n */\nfunction getQueriesForElement(element, queries$1, initialValue) {\n  if (queries$1 === void 0) {\n    queries$1 = queries;\n  }\n  if (initialValue === void 0) {\n    initialValue = {};\n  }\n  return Object.keys(queries$1).reduce((helpers, key) => {\n    const fn = queries$1[key];\n    helpers[key] = fn.bind(null, element);\n    return helpers;\n  }, initialValue);\n}\n\nconst isRemoved = result => !result || Array.isArray(result) && !result.length;\n\n// Check if the element is not present.\n// As the name implies, waitForElementToBeRemoved should check `present` --\x3e `removed`\nfunction initialCheck(elements) {\n  if (isRemoved(elements)) {\n    throw new Error('The element(s) given to waitForElementToBeRemoved are already removed. waitForElementToBeRemoved requires that the element(s) exist(s) before waiting for removal.');\n  }\n}\nasync function waitForElementToBeRemoved(callback, options) {\n  // created here so we get a nice stacktrace\n  const timeoutError = new Error('Timed out in waitForElementToBeRemoved.');\n  if (typeof callback !== 'function') {\n    initialCheck(callback);\n    const elements = Array.isArray(callback) ? callback : [callback];\n    const getRemainingElements = elements.map(element => {\n      let parent = element.parentElement;\n      if (parent === null) return () => null;\n      while (parent.parentElement) parent = parent.parentElement;\n      return () => parent.contains(element) ? element : null;\n    });\n    callback = () => getRemainingElements.map(c => c()).filter(Boolean);\n  }\n  initialCheck(callback());\n  return waitForWrapper(() => {\n    let result;\n    try {\n      result = callback();\n    } catch (error) {\n      if (error.name === 'TestingLibraryElementError') {\n        return undefined;\n      }\n      throw error;\n    }\n    if (!isRemoved(result)) {\n      throw timeoutError;\n    }\n    return undefined;\n  }, options);\n}\n\n/*\neslint\n  require-await: \"off\"\n*/\n\nconst eventMap = {\n  // Clipboard Events\n  copy: {\n    EventType: 'ClipboardEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  cut: {\n    EventType: 'ClipboardEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  paste: {\n    EventType: 'ClipboardEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  // Composition Events\n  compositionEnd: {\n    EventType: 'CompositionEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  compositionStart: {\n    EventType: 'CompositionEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  compositionUpdate: {\n    EventType: 'CompositionEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  // Keyboard Events\n  keyDown: {\n    EventType: 'KeyboardEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      charCode: 0,\n      composed: true\n    }\n  },\n  keyPress: {\n    EventType: 'KeyboardEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      charCode: 0,\n      composed: true\n    }\n  },\n  keyUp: {\n    EventType: 'KeyboardEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      charCode: 0,\n      composed: true\n    }\n  },\n  // Focus Events\n  focus: {\n    EventType: 'FocusEvent',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false,\n      composed: true\n    }\n  },\n  blur: {\n    EventType: 'FocusEvent',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false,\n      composed: true\n    }\n  },\n  focusIn: {\n    EventType: 'FocusEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false,\n      composed: true\n    }\n  },\n  focusOut: {\n    EventType: 'FocusEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false,\n      composed: true\n    }\n  },\n  // Form Events\n  change: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false\n    }\n  },\n  input: {\n    EventType: 'InputEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false,\n      composed: true\n    }\n  },\n  invalid: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: true\n    }\n  },\n  submit: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true\n    }\n  },\n  reset: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true\n    }\n  },\n  // Mouse Events\n  click: {\n    EventType: 'MouseEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      button: 0,\n      composed: true\n    }\n  },\n  contextMenu: {\n    EventType: 'MouseEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  dblClick: {\n    EventType: 'MouseEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  drag: {\n    EventType: 'DragEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  dragEnd: {\n    EventType: 'DragEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false,\n      composed: true\n    }\n  },\n  dragEnter: {\n    EventType: 'DragEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  dragExit: {\n    EventType: 'DragEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false,\n      composed: true\n    }\n  },\n  dragLeave: {\n    EventType: 'DragEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false,\n      composed: true\n    }\n  },\n  dragOver: {\n    EventType: 'DragEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  dragStart: {\n    EventType: 'DragEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  drop: {\n    EventType: 'DragEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  mouseDown: {\n    EventType: 'MouseEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  mouseEnter: {\n    EventType: 'MouseEvent',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false,\n      composed: true\n    }\n  },\n  mouseLeave: {\n    EventType: 'MouseEvent',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false,\n      composed: true\n    }\n  },\n  mouseMove: {\n    EventType: 'MouseEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  mouseOut: {\n    EventType: 'MouseEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  mouseOver: {\n    EventType: 'MouseEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  mouseUp: {\n    EventType: 'MouseEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  // Selection Events\n  select: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false\n    }\n  },\n  // Touch Events\n  touchCancel: {\n    EventType: 'TouchEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false,\n      composed: true\n    }\n  },\n  touchEnd: {\n    EventType: 'TouchEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  touchMove: {\n    EventType: 'TouchEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  touchStart: {\n    EventType: 'TouchEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  // UI Events\n  resize: {\n    EventType: 'UIEvent',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  scroll: {\n    EventType: 'UIEvent',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  // Wheel Events\n  wheel: {\n    EventType: 'WheelEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  // Media Events\n  abort: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  canPlay: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  canPlayThrough: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  durationChange: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  emptied: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  encrypted: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  ended: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  loadedData: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  loadedMetadata: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  loadStart: {\n    EventType: 'ProgressEvent',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  pause: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  play: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  playing: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  progress: {\n    EventType: 'ProgressEvent',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  rateChange: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  seeked: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  seeking: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  stalled: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  suspend: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  timeUpdate: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  volumeChange: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  waiting: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  // Events\n  load: {\n    // TODO: load events can be UIEvent or Event depending on what generated them\n    // This is where this abstraction breaks down.\n    // But the common targets are <img />, <script /> and window.\n    // Neither of these targets receive a UIEvent\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  error: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  // Animation Events\n  animationStart: {\n    EventType: 'AnimationEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false\n    }\n  },\n  animationEnd: {\n    EventType: 'AnimationEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false\n    }\n  },\n  animationIteration: {\n    EventType: 'AnimationEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false\n    }\n  },\n  // Transition Events\n  transitionCancel: {\n    EventType: 'TransitionEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false\n    }\n  },\n  transitionEnd: {\n    EventType: 'TransitionEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true\n    }\n  },\n  transitionRun: {\n    EventType: 'TransitionEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false\n    }\n  },\n  transitionStart: {\n    EventType: 'TransitionEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false\n    }\n  },\n  // pointer events\n  pointerOver: {\n    EventType: 'PointerEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  pointerEnter: {\n    EventType: 'PointerEvent',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  pointerDown: {\n    EventType: 'PointerEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  pointerMove: {\n    EventType: 'PointerEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  pointerUp: {\n    EventType: 'PointerEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  pointerCancel: {\n    EventType: 'PointerEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false,\n      composed: true\n    }\n  },\n  pointerOut: {\n    EventType: 'PointerEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  pointerLeave: {\n    EventType: 'PointerEvent',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  gotPointerCapture: {\n    EventType: 'PointerEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false,\n      composed: true\n    }\n  },\n  lostPointerCapture: {\n    EventType: 'PointerEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false,\n      composed: true\n    }\n  },\n  // history events\n  popState: {\n    EventType: 'PopStateEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false\n    }\n  },\n  // window events\n  offline: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  online: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  }\n};\nconst eventAliasMap = {\n  doubleClick: 'dblClick'\n};\n\nfunction fireEvent(element, event) {\n  return getConfig().eventWrapper(() => {\n    if (!event) {\n      throw new Error(\"Unable to fire an event - please provide an event object.\");\n    }\n    if (!element) {\n      throw new Error(\"Unable to fire a \\\"\" + event.type + \"\\\" event - please provide a DOM element.\");\n    }\n    return element.dispatchEvent(event);\n  });\n}\nfunction createEvent(eventName, node, init, _temp) {\n  let {\n    EventType = 'Event',\n    defaultInit = {}\n  } = _temp === void 0 ? {} : _temp;\n  if (!node) {\n    throw new Error(\"Unable to fire a \\\"\" + eventName + \"\\\" event - please provide a DOM element.\");\n  }\n  const eventInit = {\n    ...defaultInit,\n    ...init\n  };\n  const {\n    target: {\n      value,\n      files,\n      ...targetProperties\n    } = {}\n  } = eventInit;\n  if (value !== undefined) {\n    setNativeValue(node, value);\n  }\n  if (files !== undefined) {\n    // input.files is a read-only property so this is not allowed:\n    // input.files = [file]\n    // so we have to use this workaround to set the property\n    Object.defineProperty(node, 'files', {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: files\n    });\n  }\n  Object.assign(node, targetProperties);\n  const window = getWindowFromNode(node);\n  const EventConstructor = window[EventType] || window.Event;\n  let event;\n  /* istanbul ignore else  */\n  if (typeof EventConstructor === 'function') {\n    event = new EventConstructor(eventName, eventInit);\n  } else {\n    // IE11 polyfill from https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill\n    event = window.document.createEvent(EventType);\n    const {\n      bubbles,\n      cancelable,\n      detail,\n      ...otherInit\n    } = eventInit;\n    event.initEvent(eventName, bubbles, cancelable, detail);\n    Object.keys(otherInit).forEach(eventKey => {\n      event[eventKey] = otherInit[eventKey];\n    });\n  }\n\n  // DataTransfer is not supported in jsdom: https://github.com/jsdom/jsdom/issues/1568\n  const dataTransferProperties = ['dataTransfer', 'clipboardData'];\n  dataTransferProperties.forEach(dataTransferKey => {\n    const dataTransferValue = eventInit[dataTransferKey];\n    if (typeof dataTransferValue === 'object') {\n      /* istanbul ignore if  */\n      if (typeof window.DataTransfer === 'function') {\n        Object.defineProperty(event, dataTransferKey, {\n          value: Object.getOwnPropertyNames(dataTransferValue).reduce((acc, propName) => {\n            Object.defineProperty(acc, propName, {\n              value: dataTransferValue[propName]\n            });\n            return acc;\n          }, new window.DataTransfer())\n        });\n      } else {\n        Object.defineProperty(event, dataTransferKey, {\n          value: dataTransferValue\n        });\n      }\n    }\n  });\n  return event;\n}\nObject.keys(eventMap).forEach(key => {\n  const {\n    EventType,\n    defaultInit\n  } = eventMap[key];\n  const eventName = key.toLowerCase();\n  createEvent[key] = (node, init) => createEvent(eventName, node, init, {\n    EventType,\n    defaultInit\n  });\n  fireEvent[key] = (node, init) => fireEvent(node, createEvent[key](node, init));\n});\n\n// function written after some investigation here:\n// https://github.com/facebook/react/issues/10135#issuecomment-401496776\nfunction setNativeValue(element, value) {\n  const {\n    set: valueSetter\n  } = Object.getOwnPropertyDescriptor(element, 'value') || {};\n  const prototype = Object.getPrototypeOf(element);\n  const {\n    set: prototypeValueSetter\n  } = Object.getOwnPropertyDescriptor(prototype, 'value') || {};\n  if (prototypeValueSetter && valueSetter !== prototypeValueSetter) {\n    prototypeValueSetter.call(element, value);\n  } else {\n    /* istanbul ignore if */\n    // eslint-disable-next-line no-lonely-if -- Can't be ignored by istanbul otherwise\n    if (valueSetter) {\n      valueSetter.call(element, value);\n    } else {\n      throw new Error('The given element does not have a value setter');\n    }\n  }\n}\nObject.keys(eventAliasMap).forEach(aliasKey => {\n  const key = eventAliasMap[aliasKey];\n  fireEvent[aliasKey] = function () {\n    return fireEvent[key](...arguments);\n  };\n});\n\n/* eslint complexity:[\"error\", 9] */\n\n// WARNING: `lz-string` only has a default export but statically we assume named exports are allowd\nfunction unindent(string) {\n  // remove white spaces first, to save a few bytes.\n  // testing-playground will reformat on load any ways.\n  return string.replace(/[ \\t]*[\\n][ \\t]*/g, '\\n');\n}\nfunction encode(value) {\n  return lz_string__WEBPACK_IMPORTED_MODULE_3___default().compressToEncodedURIComponent(unindent(value));\n}\nfunction getPlaygroundUrl(markup) {\n  return \"https://testing-playground.com/#markup=\" + encode(markup);\n}\nconst debug = (element, maxLength, options) => Array.isArray(element) ? element.forEach(el => logDOM(el, maxLength, options)) : logDOM(element, maxLength, options);\nconst logTestingPlaygroundURL = function (element) {\n  if (element === void 0) {\n    element = getDocument().body;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (!element || !('innerHTML' in element)) {\n    console.log(\"The element you're providing isn't a valid DOM element.\");\n    return;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (!element.innerHTML) {\n    console.log(\"The provided element doesn't have any children.\");\n    return;\n  }\n  const playgroundUrl = getPlaygroundUrl(element.innerHTML);\n  console.log(\"Open this URL in your browser\\n\\n\" + playgroundUrl);\n  return playgroundUrl;\n};\nconst initialValue = {\n  debug,\n  logTestingPlaygroundURL\n};\nconst screen = typeof document !== 'undefined' && document.body // eslint-disable-line @typescript-eslint/no-unnecessary-condition\n? getQueriesForElement(document.body, queries, initialValue) : Object.keys(queries).reduce((helpers, key) => {\n  // `key` is for all intents and purposes the type of keyof `helpers`, which itself is the type of `initialValue` plus incoming properties from `queries`\n  // if `Object.keys(something)` returned Array<keyof typeof something> this explicit type assertion would not be necessary\n  // see https://stackoverflow.com/questions/55012174/why-doesnt-object-keys-return-a-keyof-type-in-typescript\n  helpers[key] = () => {\n    throw new TypeError('For queries bound to document.body a global document has to be available... Learn more: https://testing-library.com/s/screen-global-error');\n  };\n  return helpers;\n}, initialValue);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS9kb20vZGlzdC9AdGVzdGluZy1saWJyYXJ5L2RvbS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE4QztBQUN0QjtBQUNvRTtBQUM3QjtBQUM5Qjs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRKQUE0SjtBQUM1SjtBQUNBO0FBQ0EsT0FBTyxJQUFJO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7O0FBRXBEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esa0JBQWtCLE9BQU8sb0JBQW9CLE9BQU8sMkJBQTJCLE9BQU87QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsa0RBQW9COztBQUV4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU8sb0JBQW9CLE9BQU87QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHVCQUF1QixpREFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksd0JBQXdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHdCQUF3QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUI7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QjtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CLGFBQWEsVUFBVTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZ05BQWdOLHlCQUF5QjtBQUN6TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsOERBQVk7O0FBRXpEO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsc0NBQXNDO0FBQ2pEO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHdCQUF3QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHNGQUFxQjtBQUMxRDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EscURBQXFELDRGQUE0QjtBQUNqRjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHlCQUF5QjtBQUM3QjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLHFCQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLHFCQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLHFCQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0Msc0JBQXNCO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLE9BQU8sa0JBQWtCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNGQUFxQjtBQUNqQztBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxXQUFXO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksd0JBQXdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsYUFBYTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRixlQUFlO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsZUFBZTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLGVBQWU7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3QkFBd0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkseUJBQXlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOERBQThELEtBQUs7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsYUFBYTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzRUFBc0UsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksd0JBQXdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3QkFBd0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksd0JBQXdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSSx3QkFBd0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdURBQUs7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVEQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1REFBSztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdURBQUs7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVEQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1REFBSztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdURBQUs7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVEQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1REFBSztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdURBQUs7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0ZBQXFCO0FBQ3hDO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0RkFBNEI7QUFDL0M7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDhEQUFZO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx5QkFBeUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHlCQUF5QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNFQUFzRSxhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGNBQWMsMEJBQTBCO0FBQ3hDOztBQUVBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3QkFBd0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOEVBQXNDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRXlxRCIsInNvdXJjZXMiOlsid2VicGFjazovL2xlYWZ5Z3JlZW4tdWkvLi9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS9kb20vZGlzdC9AdGVzdGluZy1saWJyYXJ5L2RvbS5lc20uanM/MTk4MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBwcmV0dHlGb3JtYXQgZnJvbSAncHJldHR5LWZvcm1hdCc7XG5leHBvcnQgeyBwcmV0dHlGb3JtYXQgfTtcbmltcG9ydCB7IGNvbXB1dGVBY2Nlc3NpYmxlTmFtZSwgY29tcHV0ZUFjY2Vzc2libGVEZXNjcmlwdGlvbiB9IGZyb20gJ2RvbS1hY2Nlc3NpYmlsaXR5LWFwaSc7XG5pbXBvcnQgeyBlbGVtZW50Um9sZXMsIHJvbGVzLCByb2xlRWxlbWVudHMgfSBmcm9tICdhcmlhLXF1ZXJ5JztcbmltcG9ydCBselN0cmluZyBmcm9tICdsei1zdHJpbmcnO1xuXG4vKipcbiAqIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2plc3QvYmxvYi9lN2JiNmExZTI2ZmZhYjkwNjExYjI1OTM5MTJkZjE1YjY5MzE1NjExL3BhY2thZ2VzL3ByZXR0eS1mb3JtYXQvc3JjL3BsdWdpbnMvRE9NRWxlbWVudC50c1xuICovXG4vKiBlc2xpbnQtZGlzYWJsZSAtLSB0cnlpbmcgdG8gc3RheSBhcyBjbG9zZSB0byB0aGUgb3JpZ2luYWwgYXMgcG9zc2libGUgKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBmaWxlICovXG5cbmZ1bmN0aW9uIGVzY2FwZUhUTUwoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcbn1cbi8vIFJldHVybiBlbXB0eSBzdHJpbmcgaWYga2V5cyBpcyBlbXB0eS5cbmNvbnN0IHByaW50UHJvcHMgPSAoa2V5cywgcHJvcHMsIGNvbmZpZywgaW5kZW50YXRpb24sIGRlcHRoLCByZWZzLCBwcmludGVyKSA9PiB7XG4gIGNvbnN0IGluZGVudGF0aW9uTmV4dCA9IGluZGVudGF0aW9uICsgY29uZmlnLmluZGVudDtcbiAgY29uc3QgY29sb3JzID0gY29uZmlnLmNvbG9ycztcbiAgcmV0dXJuIGtleXMubWFwKGtleSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBwcm9wc1trZXldO1xuICAgIGxldCBwcmludGVkID0gcHJpbnRlcih2YWx1ZSwgY29uZmlnLCBpbmRlbnRhdGlvbk5leHQsIGRlcHRoLCByZWZzKTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHByaW50ZWQuaW5kZXhPZignXFxuJykgIT09IC0xKSB7XG4gICAgICAgIHByaW50ZWQgPSBjb25maWcuc3BhY2luZ091dGVyICsgaW5kZW50YXRpb25OZXh0ICsgcHJpbnRlZCArIGNvbmZpZy5zcGFjaW5nT3V0ZXIgKyBpbmRlbnRhdGlvbjtcbiAgICAgIH1cbiAgICAgIHByaW50ZWQgPSAneycgKyBwcmludGVkICsgJ30nO1xuICAgIH1cbiAgICByZXR1cm4gY29uZmlnLnNwYWNpbmdJbm5lciArIGluZGVudGF0aW9uICsgY29sb3JzLnByb3Aub3BlbiArIGtleSArIGNvbG9ycy5wcm9wLmNsb3NlICsgJz0nICsgY29sb3JzLnZhbHVlLm9wZW4gKyBwcmludGVkICsgY29sb3JzLnZhbHVlLmNsb3NlO1xuICB9KS5qb2luKCcnKTtcbn07XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ob2RlL25vZGVUeXBlI25vZGVfdHlwZV9jb25zdGFudHNcbmNvbnN0IE5vZGVUeXBlVGV4dE5vZGUgPSAzO1xuXG4vLyBSZXR1cm4gZW1wdHkgc3RyaW5nIGlmIGNoaWxkcmVuIGlzIGVtcHR5LlxuY29uc3QgcHJpbnRDaGlsZHJlbiA9IChjaGlsZHJlbiwgY29uZmlnLCBpbmRlbnRhdGlvbiwgZGVwdGgsIHJlZnMsIHByaW50ZXIpID0+IGNoaWxkcmVuLm1hcChjaGlsZCA9PiB7XG4gIGNvbnN0IHByaW50ZWRDaGlsZCA9IHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycgPyBwcmludFRleHQoY2hpbGQsIGNvbmZpZykgOiBwcmludGVyKGNoaWxkLCBjb25maWcsIGluZGVudGF0aW9uLCBkZXB0aCwgcmVmcyk7XG4gIGlmIChwcmludGVkQ2hpbGQgPT09ICcnICYmIHR5cGVvZiBjaGlsZCA9PT0gJ29iamVjdCcgJiYgY2hpbGQgIT09IG51bGwgJiYgY2hpbGQubm9kZVR5cGUgIT09IE5vZGVUeXBlVGV4dE5vZGUpIHtcbiAgICAvLyBBIHBsdWdpbiBzZXJpYWxpemVkIHRoaXMgTm9kZSB0byAnJyBtZWFuaW5nIHdlIHNob3VsZCBpZ25vcmUgaXQuXG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiBjb25maWcuc3BhY2luZ091dGVyICsgaW5kZW50YXRpb24gKyBwcmludGVkQ2hpbGQ7XG59KS5qb2luKCcnKTtcbmNvbnN0IHByaW50VGV4dCA9ICh0ZXh0LCBjb25maWcpID0+IHtcbiAgY29uc3QgY29udGVudENvbG9yID0gY29uZmlnLmNvbG9ycy5jb250ZW50O1xuICByZXR1cm4gY29udGVudENvbG9yLm9wZW4gKyBlc2NhcGVIVE1MKHRleHQpICsgY29udGVudENvbG9yLmNsb3NlO1xufTtcbmNvbnN0IHByaW50Q29tbWVudCA9IChjb21tZW50LCBjb25maWcpID0+IHtcbiAgY29uc3QgY29tbWVudENvbG9yID0gY29uZmlnLmNvbG9ycy5jb21tZW50O1xuICByZXR1cm4gY29tbWVudENvbG9yLm9wZW4gKyAnPCEtLScgKyBlc2NhcGVIVE1MKGNvbW1lbnQpICsgJy0tPicgKyBjb21tZW50Q29sb3IuY2xvc2U7XG59O1xuXG4vLyBTZXBhcmF0ZSB0aGUgZnVuY3Rpb25zIHRvIGZvcm1hdCBwcm9wcywgY2hpbGRyZW4sIGFuZCBlbGVtZW50LFxuLy8gc28gYSBwbHVnaW4gY291bGQgb3ZlcnJpZGUgYSBwYXJ0aWN1bGFyIGZ1bmN0aW9uLCBpZiBuZWVkZWQuXG4vLyBUb28gYmFkLCBzbyBzYWQ6IHRoZSB0cmFkaXRpb25hbCAoYnV0IHVubmVjZXNzYXJ5KSBzcGFjZVxuLy8gaW4gYSBzZWxmLWNsb3NpbmcgdGFnQ29sb3IgcmVxdWlyZXMgYSBzZWNvbmQgdGVzdCBvZiBwcmludGVkUHJvcHMuXG5jb25zdCBwcmludEVsZW1lbnQgPSAodHlwZSwgcHJpbnRlZFByb3BzLCBwcmludGVkQ2hpbGRyZW4sIGNvbmZpZywgaW5kZW50YXRpb24pID0+IHtcbiAgY29uc3QgdGFnQ29sb3IgPSBjb25maWcuY29sb3JzLnRhZztcbiAgcmV0dXJuIHRhZ0NvbG9yLm9wZW4gKyAnPCcgKyB0eXBlICsgKHByaW50ZWRQcm9wcyAmJiB0YWdDb2xvci5jbG9zZSArIHByaW50ZWRQcm9wcyArIGNvbmZpZy5zcGFjaW5nT3V0ZXIgKyBpbmRlbnRhdGlvbiArIHRhZ0NvbG9yLm9wZW4pICsgKHByaW50ZWRDaGlsZHJlbiA/ICc+JyArIHRhZ0NvbG9yLmNsb3NlICsgcHJpbnRlZENoaWxkcmVuICsgY29uZmlnLnNwYWNpbmdPdXRlciArIGluZGVudGF0aW9uICsgdGFnQ29sb3Iub3BlbiArICc8LycgKyB0eXBlIDogKHByaW50ZWRQcm9wcyAmJiAhY29uZmlnLm1pbiA/ICcnIDogJyAnKSArICcvJykgKyAnPicgKyB0YWdDb2xvci5jbG9zZTtcbn07XG5jb25zdCBwcmludEVsZW1lbnRBc0xlYWYgPSAodHlwZSwgY29uZmlnKSA9PiB7XG4gIGNvbnN0IHRhZ0NvbG9yID0gY29uZmlnLmNvbG9ycy50YWc7XG4gIHJldHVybiB0YWdDb2xvci5vcGVuICsgJzwnICsgdHlwZSArIHRhZ0NvbG9yLmNsb3NlICsgJyDigKYnICsgdGFnQ29sb3Iub3BlbiArICcgLz4nICsgdGFnQ29sb3IuY2xvc2U7XG59O1xuY29uc3QgRUxFTUVOVF9OT0RFJDEgPSAxO1xuY29uc3QgVEVYVF9OT0RFJDEgPSAzO1xuY29uc3QgQ09NTUVOVF9OT0RFJDEgPSA4O1xuY29uc3QgRlJBR01FTlRfTk9ERSA9IDExO1xuY29uc3QgRUxFTUVOVF9SRUdFWFAgPSAvXigoSFRNTHxTVkcpXFx3Kik/RWxlbWVudCQvO1xuY29uc3QgdGVzdE5vZGUgPSB2YWwgPT4ge1xuICBjb25zdCBjb25zdHJ1Y3Rvck5hbWUgPSB2YWwuY29uc3RydWN0b3IubmFtZTtcbiAgY29uc3Qge1xuICAgIG5vZGVUeXBlLFxuICAgIHRhZ05hbWVcbiAgfSA9IHZhbDtcbiAgY29uc3QgaXNDdXN0b21FbGVtZW50ID0gdHlwZW9mIHRhZ05hbWUgPT09ICdzdHJpbmcnICYmIHRhZ05hbWUuaW5jbHVkZXMoJy0nKSB8fCB0eXBlb2YgdmFsLmhhc0F0dHJpYnV0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWwuaGFzQXR0cmlidXRlKCdpcycpO1xuICByZXR1cm4gbm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSQxICYmIChFTEVNRU5UX1JFR0VYUC50ZXN0KGNvbnN0cnVjdG9yTmFtZSkgfHwgaXNDdXN0b21FbGVtZW50KSB8fCBub2RlVHlwZSA9PT0gVEVYVF9OT0RFJDEgJiYgY29uc3RydWN0b3JOYW1lID09PSAnVGV4dCcgfHwgbm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSQxICYmIGNvbnN0cnVjdG9yTmFtZSA9PT0gJ0NvbW1lbnQnIHx8IG5vZGVUeXBlID09PSBGUkFHTUVOVF9OT0RFICYmIGNvbnN0cnVjdG9yTmFtZSA9PT0gJ0RvY3VtZW50RnJhZ21lbnQnO1xufTtcbmZ1bmN0aW9uIG5vZGVJc1RleHQobm9kZSkge1xuICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFJDE7XG59XG5mdW5jdGlvbiBub2RlSXNDb21tZW50KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSQxO1xufVxuZnVuY3Rpb24gbm9kZUlzRnJhZ21lbnQobm9kZSkge1xuICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gRlJBR01FTlRfTk9ERTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURPTUVsZW1lbnRGaWx0ZXIoZmlsdGVyTm9kZSkge1xuICByZXR1cm4ge1xuICAgIHRlc3Q6IHZhbCA9PiB7XG4gICAgICB2YXIgX3ZhbCRjb25zdHJ1Y3RvcjI7XG4gICAgICByZXR1cm4gKHZhbCA9PSBudWxsID8gdm9pZCAwIDogKF92YWwkY29uc3RydWN0b3IyID0gdmFsLmNvbnN0cnVjdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX3ZhbCRjb25zdHJ1Y3RvcjIubmFtZSkgJiYgdGVzdE5vZGUodmFsKTtcbiAgICB9LFxuICAgIHNlcmlhbGl6ZTogKG5vZGUsIGNvbmZpZywgaW5kZW50YXRpb24sIGRlcHRoLCByZWZzLCBwcmludGVyKSA9PiB7XG4gICAgICBpZiAobm9kZUlzVGV4dChub2RlKSkge1xuICAgICAgICByZXR1cm4gcHJpbnRUZXh0KG5vZGUuZGF0YSwgY29uZmlnKTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlSXNDb21tZW50KG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBwcmludENvbW1lbnQobm9kZS5kYXRhLCBjb25maWcpO1xuICAgICAgfVxuICAgICAgY29uc3QgdHlwZSA9IG5vZGVJc0ZyYWdtZW50KG5vZGUpID8gXCJEb2N1bWVudEZyYWdtZW50XCIgOiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICgrK2RlcHRoID4gY29uZmlnLm1heERlcHRoKSB7XG4gICAgICAgIHJldHVybiBwcmludEVsZW1lbnRBc0xlYWYodHlwZSwgY29uZmlnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmludEVsZW1lbnQodHlwZSwgcHJpbnRQcm9wcyhub2RlSXNGcmFnbWVudChub2RlKSA/IFtdIDogQXJyYXkuZnJvbShub2RlLmF0dHJpYnV0ZXMpLm1hcChhdHRyID0+IGF0dHIubmFtZSkuc29ydCgpLCBub2RlSXNGcmFnbWVudChub2RlKSA/IHt9IDogQXJyYXkuZnJvbShub2RlLmF0dHJpYnV0ZXMpLnJlZHVjZSgocHJvcHMsIGF0dHJpYnV0ZSkgPT4ge1xuICAgICAgICBwcm9wc1thdHRyaWJ1dGUubmFtZV0gPSBhdHRyaWJ1dGUudmFsdWU7XG4gICAgICAgIHJldHVybiBwcm9wcztcbiAgICAgIH0sIHt9KSwgY29uZmlnLCBpbmRlbnRhdGlvbiArIGNvbmZpZy5pbmRlbnQsIGRlcHRoLCByZWZzLCBwcmludGVyKSwgcHJpbnRDaGlsZHJlbihBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChub2RlLmNoaWxkTm9kZXMgfHwgbm9kZS5jaGlsZHJlbikuZmlsdGVyKGZpbHRlck5vZGUpLCBjb25maWcsIGluZGVudGF0aW9uICsgY29uZmlnLmluZGVudCwgZGVwdGgsIHJlZnMsIHByaW50ZXIpLCBjb25maWcsIGluZGVudGF0aW9uKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIFdlIHRyeSB0byBsb2FkIG5vZGUgZGVwZW5kZW5jaWVzXG5sZXQgY2hhbGsgPSBudWxsO1xubGV0IHJlYWRGaWxlU3luYyA9IG51bGw7XG5sZXQgY29kZUZyYW1lQ29sdW1ucyA9IG51bGw7XG50cnkge1xuICBjb25zdCBub2RlUmVxdWlyZSA9IG1vZHVsZSAmJiBtb2R1bGUucmVxdWlyZTtcbiAgcmVhZEZpbGVTeW5jID0gbm9kZVJlcXVpcmUuY2FsbChtb2R1bGUsICdmcycpLnJlYWRGaWxlU3luYztcbiAgY29kZUZyYW1lQ29sdW1ucyA9IG5vZGVSZXF1aXJlLmNhbGwobW9kdWxlLCAnQGJhYmVsL2NvZGUtZnJhbWUnKS5jb2RlRnJhbWVDb2x1bW5zO1xuICBjaGFsayA9IG5vZGVSZXF1aXJlLmNhbGwobW9kdWxlLCAnY2hhbGsnKTtcbn0gY2F0Y2gge1xuICAvLyBXZSdyZSBpbiBhIGJyb3dzZXIgZW52aXJvbm1lbnRcbn1cblxuLy8gZnJhbWUgaGFzIHRoZSBmb3JtIFwiYXQgbXlNZXRob2QgKGxvY2F0aW9uL3RvL215L2ZpbGUuanM6MTA6MilcIlxuZnVuY3Rpb24gZ2V0Q29kZUZyYW1lKGZyYW1lKSB7XG4gIGNvbnN0IGxvY2F0aW9uU3RhcnQgPSBmcmFtZS5pbmRleE9mKCcoJykgKyAxO1xuICBjb25zdCBsb2NhdGlvbkVuZCA9IGZyYW1lLmluZGV4T2YoJyknKTtcbiAgY29uc3QgZnJhbWVMb2NhdGlvbiA9IGZyYW1lLnNsaWNlKGxvY2F0aW9uU3RhcnQsIGxvY2F0aW9uRW5kKTtcbiAgY29uc3QgZnJhbWVMb2NhdGlvbkVsZW1lbnRzID0gZnJhbWVMb2NhdGlvbi5zcGxpdCgnOicpO1xuICBjb25zdCBbZmlsZW5hbWUsIGxpbmUsIGNvbHVtbl0gPSBbZnJhbWVMb2NhdGlvbkVsZW1lbnRzWzBdLCBwYXJzZUludChmcmFtZUxvY2F0aW9uRWxlbWVudHNbMV0sIDEwKSwgcGFyc2VJbnQoZnJhbWVMb2NhdGlvbkVsZW1lbnRzWzJdLCAxMCldO1xuICBsZXQgcmF3RmlsZUNvbnRlbnRzID0gJyc7XG4gIHRyeSB7XG4gICAgcmF3RmlsZUNvbnRlbnRzID0gcmVhZEZpbGVTeW5jKGZpbGVuYW1lLCAndXRmLTgnKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGNvbnN0IGNvZGVGcmFtZSA9IGNvZGVGcmFtZUNvbHVtbnMocmF3RmlsZUNvbnRlbnRzLCB7XG4gICAgc3RhcnQ6IHtcbiAgICAgIGxpbmUsXG4gICAgICBjb2x1bW5cbiAgICB9XG4gIH0sIHtcbiAgICBoaWdobGlnaHRDb2RlOiB0cnVlLFxuICAgIGxpbmVzQmVsb3c6IDBcbiAgfSk7XG4gIHJldHVybiBjaGFsay5kaW0oZnJhbWVMb2NhdGlvbikgKyBcIlxcblwiICsgY29kZUZyYW1lICsgXCJcXG5cIjtcbn1cbmZ1bmN0aW9uIGdldFVzZXJDb2RlRnJhbWUoKSB7XG4gIC8vIElmIHdlIGNvdWxkbid0IGxvYWQgZGVwZW5kZW5jaWVzLCB3ZSBjYW4ndCBnZW5lcmF0ZSB0aGUgdXNlciB0cmFjZVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAoIXJlYWRGaWxlU3luYyB8fCAhY29kZUZyYW1lQ29sdW1ucykge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoKTtcbiAgY29uc3QgZmlyc3RDbGllbnRDb2RlRnJhbWUgPSBlcnIuc3RhY2suc3BsaXQoJ1xcbicpLnNsaWNlKDEpIC8vIFJlbW92ZSBmaXJzdCBsaW5lIHdoaWNoIGhhcyB0aGUgZm9ybSBcIkVycm9yOiBUeXBlRXJyb3JcIlxuICAuZmluZChmcmFtZSA9PiAhZnJhbWUuaW5jbHVkZXMoJ25vZGVfbW9kdWxlcy8nKSk7IC8vIElnbm9yZSBmcmFtZXMgZnJvbSAzcmQgcGFydHkgbGlicmFyaWVzXG5cbiAgcmV0dXJuIGdldENvZGVGcmFtZShmaXJzdENsaWVudENvZGVGcmFtZSk7XG59XG5cbi8vIENvbnN0YW50IG5vZGUubm9kZVR5cGUgZm9yIHRleHQgbm9kZXMsIHNlZTpcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ob2RlL25vZGVUeXBlI05vZGVfdHlwZV9jb25zdGFudHNcbmNvbnN0IFRFWFRfTk9ERSA9IDM7XG5mdW5jdGlvbiBqZXN0RmFrZVRpbWVyc0FyZUVuYWJsZWQoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBpZiAodHlwZW9mIGplc3QgIT09ICd1bmRlZmluZWQnICYmIGplc3QgIT09IG51bGwpIHtcbiAgICByZXR1cm4gKFxuICAgICAgLy8gbGVnYWN5IHRpbWVyc1xuICAgICAgc2V0VGltZW91dC5faXNNb2NrRnVuY3Rpb24gPT09IHRydWUgfHxcbiAgICAgIC8vIG1vZGVybiB0aW1lcnNcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItb2JqZWN0LWhhcy1vd24gLS0gbm90IHN1cHBvcnRlZCBieSBvdXIgc3VwcG9ydCBtYXRyaXhcbiAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXRUaW1lb3V0LCAnY2xvY2snKVxuICAgICk7XG4gIH1cbiAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGRlZmF1bHQgY29udGFpbmVyJyk7XG4gIH1cbiAgcmV0dXJuIHdpbmRvdy5kb2N1bWVudDtcbn1cbmZ1bmN0aW9uIGdldFdpbmRvd0Zyb21Ob2RlKG5vZGUpIHtcbiAgaWYgKG5vZGUuZGVmYXVsdFZpZXcpIHtcbiAgICAvLyBub2RlIGlzIGRvY3VtZW50XG4gICAgcmV0dXJuIG5vZGUuZGVmYXVsdFZpZXc7XG4gIH0gZWxzZSBpZiAobm9kZS5vd25lckRvY3VtZW50ICYmIG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldykge1xuICAgIC8vIG5vZGUgaXMgYSBET00gbm9kZVxuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gIH0gZWxzZSBpZiAobm9kZS53aW5kb3cpIHtcbiAgICAvLyBub2RlIGlzIHdpbmRvd1xuICAgIHJldHVybiBub2RlLndpbmRvdztcbiAgfSBlbHNlIGlmIChub2RlLm93bmVyRG9jdW1lbnQgJiYgbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSXQgbG9va3MgbGlrZSB0aGUgd2luZG93IG9iamVjdCBpcyBub3QgYXZhaWxhYmxlIGZvciB0aGUgcHJvdmlkZWQgbm9kZS5cIik7XG4gIH0gZWxzZSBpZiAobm9kZS50aGVuIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJdCBsb29rcyBsaWtlIHlvdSBwYXNzZWQgYSBQcm9taXNlIG9iamVjdCBpbnN0ZWFkIG9mIGEgRE9NIG5vZGUuIERpZCB5b3UgZG8gc29tZXRoaW5nIGxpa2UgYGZpcmVFdmVudC5jbGljayhzY3JlZW4uZmluZEJ5Li4uYCB3aGVuIHlvdSBtZWFudCB0byB1c2UgYSBgZ2V0QnlgIHF1ZXJ5IGBmaXJlRXZlbnQuY2xpY2soc2NyZWVuLmdldEJ5Li4uYCwgb3IgYXdhaXQgdGhlIGZpbmRCeSBxdWVyeSBgZmlyZUV2ZW50LmNsaWNrKGF3YWl0IHNjcmVlbi5maW5kQnkuLi5gP1wiKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSXQgbG9va3MgbGlrZSB5b3UgcGFzc2VkIGFuIEFycmF5IGluc3RlYWQgb2YgYSBET00gbm9kZS4gRGlkIHlvdSBkbyBzb21ldGhpbmcgbGlrZSBgZmlyZUV2ZW50LmNsaWNrKHNjcmVlbi5nZXRBbGxCeS4uLmAgd2hlbiB5b3UgbWVhbnQgdG8gdXNlIGEgYGdldEJ5YCBxdWVyeSBgZmlyZUV2ZW50LmNsaWNrKHNjcmVlbi5nZXRCeS4uLmA/XCIpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBub2RlLmRlYnVnID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBub2RlLmxvZ1Rlc3RpbmdQbGF5Z3JvdW5kVVJMID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSXQgbG9va3MgbGlrZSB5b3UgcGFzc2VkIGEgYHNjcmVlbmAgb2JqZWN0LiBEaWQgeW91IGRvIHNvbWV0aGluZyBsaWtlIGBmaXJlRXZlbnQuY2xpY2soc2NyZWVuLCAuLi5gIHdoZW4geW91IG1lYW50IHRvIHVzZSBhIHF1ZXJ5LCBlLmcuIGBmaXJlRXZlbnQuY2xpY2soc2NyZWVuLmdldEJ5Li4uLCBgP1wiKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGUgdXNlciBwYXNzZWQgc29tZXRoaW5nIHVudXN1YWwgdG8gYSBjYWxsaW5nIGZ1bmN0aW9uXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGdpdmVuIG5vZGUgaXMgbm90IGFuIEVsZW1lbnQsIHRoZSBub2RlIHR5cGUgaXM6IFwiICsgdHlwZW9mIG5vZGUgKyBcIi5cIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrQ29udGFpbmVyVHlwZShjb250YWluZXIpIHtcbiAgaWYgKCFjb250YWluZXIgfHwgISh0eXBlb2YgY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IgPT09ICdmdW5jdGlvbicpIHx8ICEodHlwZW9mIGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsID09PSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBjb250YWluZXIgdG8gYmUgYW4gRWxlbWVudCwgYSBEb2N1bWVudCBvciBhIERvY3VtZW50RnJhZ21lbnQgYnV0IGdvdCBcIiArIGdldFR5cGVOYW1lKGNvbnRhaW5lcikgKyBcIi5cIik7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0VHlwZU5hbWUob2JqZWN0KSB7XG4gICAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09PSBudWxsID8gJ251bGwnIDogb2JqZWN0LmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0O1xuICB9XG59XG5cbmNvbnN0IHNob3VsZEhpZ2hsaWdodCA9ICgpID0+IHtcbiAgbGV0IGNvbG9ycztcbiAgdHJ5IHtcbiAgICB2YXIgX3Byb2Nlc3MsIF9wcm9jZXNzJGVudjtcbiAgICBjb2xvcnMgPSBKU09OLnBhcnNlKChfcHJvY2VzcyA9IHByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiAoX3Byb2Nlc3MkZW52ID0gX3Byb2Nlc3MuZW52KSA9PSBudWxsID8gdm9pZCAwIDogX3Byb2Nlc3MkZW52LkNPTE9SUyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBJZiB0aGlzIHRocm93cywgcHJvY2Vzcz8uZW52Py5DT0xPUlMgd2Fzbid0IHBhcnNhYmxlLiBTaW5jZSB3ZSBvbmx5XG4gICAgLy8gY2FyZSBhYm91dCBgdHJ1ZWAgb3IgYGZhbHNlYCwgd2UgY2FuIHNhZmVseSBpZ25vcmUgdGhlIGVycm9yLlxuICB9XG4gIGlmICh0eXBlb2YgY29sb3JzID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBJZiBgY29sb3JzYCBpcyBzZXQgZXhwbGljaXRseSAoYm90aCBgdHJ1ZWAgYW5kIGBmYWxzZWApLCB1c2UgdGhhdCB2YWx1ZS5cbiAgICByZXR1cm4gY29sb3JzO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIGBjb2xvcnNgIGlzIG5vdCBzZXQsIGNvbG9yaXplIGlmIHdlJ3JlIGluIG5vZGUuXG4gICAgcmV0dXJuIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnZlcnNpb25zICE9PSB1bmRlZmluZWQgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlICE9PSB1bmRlZmluZWQ7XG4gIH1cbn07XG5jb25zdCB7XG4gIERPTUNvbGxlY3Rpb25cbn0gPSBwcmV0dHlGb3JtYXQucGx1Z2lucztcblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05vZGUvbm9kZVR5cGUjbm9kZV90eXBlX2NvbnN0YW50c1xuY29uc3QgRUxFTUVOVF9OT0RFID0gMTtcbmNvbnN0IENPTU1FTlRfTk9ERSA9IDg7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9qZXN0L2Jsb2IvNjE1MDg0MTk1YWUxYWU2MWRkZDU2MTYyYzYyYmJkZGExNzU4NzU2OS9wYWNrYWdlcy9wcmV0dHktZm9ybWF0L3NyYy9wbHVnaW5zL0RPTUVsZW1lbnQudHMjTDUwXG5mdW5jdGlvbiBmaWx0ZXJDb21tZW50c0FuZERlZmF1bHRJZ25vcmVUYWdzVGFncyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUubm9kZVR5cGUgIT09IENPTU1FTlRfTk9ERSAmJiAodmFsdWUubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSB8fCAhdmFsdWUubWF0Y2hlcyhnZXRDb25maWcoKS5kZWZhdWx0SWdub3JlKSk7XG59XG5mdW5jdGlvbiBwcmV0dHlET00oZG9tLCBtYXhMZW5ndGgsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBpZiAoIWRvbSkge1xuICAgIGRvbSA9IGdldERvY3VtZW50KCkuYm9keTtcbiAgfVxuICBpZiAodHlwZW9mIG1heExlbmd0aCAhPT0gJ251bWJlcicpIHtcbiAgICBtYXhMZW5ndGggPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYuREVCVUdfUFJJTlRfTElNSVQgfHwgNzAwMDtcbiAgfVxuICBpZiAobWF4TGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGlmIChkb20uZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgZG9tID0gZG9tLmRvY3VtZW50RWxlbWVudDtcbiAgfVxuICBsZXQgZG9tVHlwZU5hbWUgPSB0eXBlb2YgZG9tO1xuICBpZiAoZG9tVHlwZU5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgZG9tVHlwZU5hbWUgPSBkb20uY29uc3RydWN0b3IubmFtZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBkb24ndCBmYWxsIHdpdGggYGluYCBvcGVyYXRvclxuICAgIGRvbSA9IHt9O1xuICB9XG4gIGlmICghKCdvdXRlckhUTUwnIGluIGRvbSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYW4gZWxlbWVudCBvciBkb2N1bWVudCBidXQgZ290IFwiICsgZG9tVHlwZU5hbWUpO1xuICB9XG4gIGNvbnN0IHtcbiAgICBmaWx0ZXJOb2RlID0gZmlsdGVyQ29tbWVudHNBbmREZWZhdWx0SWdub3JlVGFnc1RhZ3MsXG4gICAgLi4ucHJldHR5Rm9ybWF0T3B0aW9uc1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgZGVidWdDb250ZW50ID0gcHJldHR5Rm9ybWF0LmZvcm1hdChkb20sIHtcbiAgICBwbHVnaW5zOiBbY3JlYXRlRE9NRWxlbWVudEZpbHRlcihmaWx0ZXJOb2RlKSwgRE9NQ29sbGVjdGlvbl0sXG4gICAgcHJpbnRGdW5jdGlvbk5hbWU6IGZhbHNlLFxuICAgIGhpZ2hsaWdodDogc2hvdWxkSGlnaGxpZ2h0KCksXG4gICAgLi4ucHJldHR5Rm9ybWF0T3B0aW9uc1xuICB9KTtcbiAgcmV0dXJuIG1heExlbmd0aCAhPT0gdW5kZWZpbmVkICYmIGRvbS5vdXRlckhUTUwubGVuZ3RoID4gbWF4TGVuZ3RoID8gZGVidWdDb250ZW50LnNsaWNlKDAsIG1heExlbmd0aCkgKyBcIi4uLlwiIDogZGVidWdDb250ZW50O1xufVxuY29uc3QgbG9nRE9NID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCB1c2VyQ29kZUZyYW1lID0gZ2V0VXNlckNvZGVGcmFtZSgpO1xuICBpZiAodXNlckNvZGVGcmFtZSkge1xuICAgIGNvbnNvbGUubG9nKHByZXR0eURPTSguLi5hcmd1bWVudHMpICsgXCJcXG5cXG5cIiArIHVzZXJDb2RlRnJhbWUpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUubG9nKHByZXR0eURPTSguLi5hcmd1bWVudHMpKTtcbiAgfVxufTtcblxuLy8gSXQgd291bGQgYmUgY2xlYW5lciBmb3IgdGhpcyB0byBsaXZlIGluc2lkZSAnLi9xdWVyaWVzJywgYnV0XG4vLyBvdGhlciBwYXJ0cyBvZiB0aGUgY29kZSBhc3N1bWUgdGhhdCBhbGwgZXhwb3J0cyBmcm9tXG4vLyAnLi9xdWVyaWVzJyBhcmUgcXVlcnkgZnVuY3Rpb25zLlxubGV0IGNvbmZpZyA9IHtcbiAgdGVzdElkQXR0cmlidXRlOiAnZGF0YS10ZXN0aWQnLFxuICBhc3luY1V0aWxUaW1lb3V0OiAxMDAwLFxuICAvLyBhc3luY1dyYXBwZXIgYW5kIGFkdmFuY2VUaW1lcnNXcmFwcGVyIGlzIHRvIHN1cHBvcnQgUmVhY3QncyBhc3luYyBgYWN0YCBmdW5jdGlvbi5cbiAgLy8gZm9yY2luZyByZWFjdC10ZXN0aW5nLWxpYnJhcnkgdG8gd3JhcCBhbGwgYXN5bmMgZnVuY3Rpb25zIHdvdWxkJ3ZlIGJlZW5cbiAgLy8gYSB0b3RhbCBuaWdodG1hcmUgKGNvbnNpZGVyIHdyYXBwaW5nIGV2ZXJ5IGZpbmRCeSogcXVlcnkgYW5kIHRoZW4gYWxzb1xuICAvLyB1cGRhdGluZyBgd2l0aGluYCBzbyB0aG9zZSB3b3VsZCBiZSB3cmFwcGVkIHRvby4gVG90YWwgbmlnaHRtYXJlKS5cbiAgLy8gc28gd2UgaGF2ZSB0aGlzIGNvbmZpZyBvcHRpb24gdGhhdCdzIHJlYWxseSBvbmx5IGludGVuZGVkIGZvclxuICAvLyByZWFjdC10ZXN0aW5nLWxpYnJhcnkgdG8gdXNlLiBGb3IgdGhhdCByZWFzb24sIHRoaXMgZmVhdHVyZSB3aWxsIHJlbWFpblxuICAvLyB1bmRvY3VtZW50ZWQuXG4gIGFzeW5jV3JhcHBlcjogY2IgPT4gY2IoKSxcbiAgdW5zdGFibGVfYWR2YW5jZVRpbWVyc1dyYXBwZXI6IGNiID0+IGNiKCksXG4gIGV2ZW50V3JhcHBlcjogY2IgPT4gY2IoKSxcbiAgLy8gZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIGBoaWRkZW5gIG9wdGlvbiBpbiBgQnlSb2xlYCBxdWVyaWVzXG4gIGRlZmF1bHRIaWRkZW46IGZhbHNlLFxuICAvLyBkZWZhdWx0IHZhbHVlIGZvciB0aGUgYGlnbm9yZWAgb3B0aW9uIGluIGBCeVRleHRgIHF1ZXJpZXNcbiAgZGVmYXVsdElnbm9yZTogJ3NjcmlwdCwgc3R5bGUnLFxuICAvLyBzaG93T3JpZ2luYWxTdGFja1RyYWNlIGZsYWcgdG8gc2hvdyB0aGUgZnVsbCBlcnJvciBzdGFjayB0cmFjZXMgZm9yIGFzeW5jIGVycm9yc1xuICBzaG93T3JpZ2luYWxTdGFja1RyYWNlOiBmYWxzZSxcbiAgLy8gdGhyb3cgZXJyb3JzIHcvIHN1Z2dlc3Rpb25zIGZvciBiZXR0ZXIgcXVlcmllcy4gT3B0IGluIHNvIG9mZiBieSBkZWZhdWx0LlxuICB0aHJvd1N1Z2dlc3Rpb25zOiBmYWxzZSxcbiAgLy8gY2FsbGVkIHdoZW4gZ2V0QnkqIHF1ZXJpZXMgZmFpbC4gKG1lc3NhZ2UsIGNvbnRhaW5lcikgPT4gRXJyb3JcbiAgZ2V0RWxlbWVudEVycm9yKG1lc3NhZ2UsIGNvbnRhaW5lcikge1xuICAgIGNvbnN0IHByZXR0aWZpZWRET00gPSBwcmV0dHlET00oY29udGFpbmVyKTtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihbbWVzc2FnZSwgXCJJZ25vcmVkIG5vZGVzOiBjb21tZW50cywgXCIgKyBjb25maWcuZGVmYXVsdElnbm9yZSArIFwiXFxuXCIgKyBwcmV0dGlmaWVkRE9NXS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuXFxuJykpO1xuICAgIGVycm9yLm5hbWUgPSAnVGVzdGluZ0xpYnJhcnlFbGVtZW50RXJyb3InO1xuICAgIHJldHVybiBlcnJvcjtcbiAgfSxcbiAgX2Rpc2FibGVFeHBlbnNpdmVFcnJvckRpYWdub3N0aWNzOiBmYWxzZSxcbiAgY29tcHV0ZWRTdHlsZVN1cHBvcnRzUHNldWRvRWxlbWVudHM6IGZhbHNlXG59O1xuZnVuY3Rpb24gcnVuV2l0aEV4cGVuc2l2ZUVycm9yRGlhZ25vc3RpY3NEaXNhYmxlZChjYWxsYmFjaykge1xuICB0cnkge1xuICAgIGNvbmZpZy5fZGlzYWJsZUV4cGVuc2l2ZUVycm9yRGlhZ25vc3RpY3MgPSB0cnVlO1xuICAgIHJldHVybiBjYWxsYmFjaygpO1xuICB9IGZpbmFsbHkge1xuICAgIGNvbmZpZy5fZGlzYWJsZUV4cGVuc2l2ZUVycm9yRGlhZ25vc3RpY3MgPSBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gY29uZmlndXJlKG5ld0NvbmZpZykge1xuICBpZiAodHlwZW9mIG5ld0NvbmZpZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFBhc3MgdGhlIGV4aXN0aW5nIGNvbmZpZyBvdXQgdG8gdGhlIHByb3ZpZGVkIGZ1bmN0aW9uXG4gICAgLy8gYW5kIGFjY2VwdCBhIGRlbHRhIGluIHJldHVyblxuICAgIG5ld0NvbmZpZyA9IG5ld0NvbmZpZyhjb25maWcpO1xuICB9XG5cbiAgLy8gTWVyZ2UgdGhlIGluY29taW5nIGNvbmZpZyBkZWx0YVxuICBjb25maWcgPSB7XG4gICAgLi4uY29uZmlnLFxuICAgIC4uLm5ld0NvbmZpZ1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q29uZmlnKCkge1xuICByZXR1cm4gY29uZmlnO1xufVxuXG5jb25zdCBsYWJlbGxlZE5vZGVOYW1lcyA9IFsnYnV0dG9uJywgJ21ldGVyJywgJ291dHB1dCcsICdwcm9ncmVzcycsICdzZWxlY3QnLCAndGV4dGFyZWEnLCAnaW5wdXQnXTtcbmZ1bmN0aW9uIGdldFRleHRDb250ZW50KG5vZGUpIHtcbiAgaWYgKGxhYmVsbGVkTm9kZU5hbWVzLmluY2x1ZGVzKG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgaWYgKG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkgcmV0dXJuIG5vZGUudGV4dENvbnRlbnQ7XG4gIHJldHVybiBBcnJheS5mcm9tKG5vZGUuY2hpbGROb2RlcykubWFwKGNoaWxkTm9kZSA9PiBnZXRUZXh0Q29udGVudChjaGlsZE5vZGUpKS5qb2luKCcnKTtcbn1cbmZ1bmN0aW9uIGdldExhYmVsQ29udGVudChlbGVtZW50KSB7XG4gIGxldCB0ZXh0Q29udGVudDtcbiAgaWYgKGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnbGFiZWwnKSB7XG4gICAgdGV4dENvbnRlbnQgPSBnZXRUZXh0Q29udGVudChlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICB0ZXh0Q29udGVudCA9IGVsZW1lbnQudmFsdWUgfHwgZWxlbWVudC50ZXh0Q29udGVudDtcbiAgfVxuICByZXR1cm4gdGV4dENvbnRlbnQ7XG59XG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9lcHMxbG9uL2RvbS1hY2Nlc3NpYmlsaXR5LWFwaS9wdWxsLzM1MlxuZnVuY3Rpb24gZ2V0UmVhbExhYmVscyhlbGVtZW50KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uIC0tIHR5cGVzIGFyZSBub3QgYXdhcmUgb2Ygb2xkZXIgYnJvd3NlcnMgdGhhdCBkb24ndCBpbXBsZW1lbnQgYGxhYmVsc2BcbiAgaWYgKGVsZW1lbnQubGFiZWxzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgX2xhYmVscztcbiAgICByZXR1cm4gKF9sYWJlbHMgPSBlbGVtZW50LmxhYmVscykgIT0gbnVsbCA/IF9sYWJlbHMgOiBbXTtcbiAgfVxuICBpZiAoIWlzTGFiZWxhYmxlKGVsZW1lbnQpKSByZXR1cm4gW107XG4gIGNvbnN0IGxhYmVscyA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdsYWJlbCcpO1xuICByZXR1cm4gQXJyYXkuZnJvbShsYWJlbHMpLmZpbHRlcihsYWJlbCA9PiBsYWJlbC5jb250cm9sID09PSBlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGlzTGFiZWxhYmxlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIC9CVVRUT058TUVURVJ8T1VUUFVUfFBST0dSRVNTfFNFTEVDVHxURVhUQVJFQS8udGVzdChlbGVtZW50LnRhZ05hbWUpIHx8IGVsZW1lbnQudGFnTmFtZSA9PT0gJ0lOUFVUJyAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZSgndHlwZScpICE9PSAnaGlkZGVuJztcbn1cbmZ1bmN0aW9uIGdldExhYmVscyhjb250YWluZXIsIGVsZW1lbnQsIF90ZW1wKSB7XG4gIGxldCB7XG4gICAgc2VsZWN0b3IgPSAnKidcbiAgfSA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wO1xuICBjb25zdCBhcmlhTGFiZWxsZWRCeSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsbGVkYnknKTtcbiAgY29uc3QgbGFiZWxzSWQgPSBhcmlhTGFiZWxsZWRCeSA/IGFyaWFMYWJlbGxlZEJ5LnNwbGl0KCcgJykgOiBbXTtcbiAgcmV0dXJuIGxhYmVsc0lkLmxlbmd0aCA/IGxhYmVsc0lkLm1hcChsYWJlbElkID0+IHtcbiAgICBjb25zdCBsYWJlbGxpbmdFbGVtZW50ID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCJbaWQ9XFxcIlwiICsgbGFiZWxJZCArIFwiXFxcIl1cIik7XG4gICAgcmV0dXJuIGxhYmVsbGluZ0VsZW1lbnQgPyB7XG4gICAgICBjb250ZW50OiBnZXRMYWJlbENvbnRlbnQobGFiZWxsaW5nRWxlbWVudCksXG4gICAgICBmb3JtQ29udHJvbDogbnVsbFxuICAgIH0gOiB7XG4gICAgICBjb250ZW50OiAnJyxcbiAgICAgIGZvcm1Db250cm9sOiBudWxsXG4gICAgfTtcbiAgfSkgOiBBcnJheS5mcm9tKGdldFJlYWxMYWJlbHMoZWxlbWVudCkpLm1hcChsYWJlbCA9PiB7XG4gICAgY29uc3QgdGV4dFRvTWF0Y2ggPSBnZXRMYWJlbENvbnRlbnQobGFiZWwpO1xuICAgIGNvbnN0IGZvcm1Db250cm9sU2VsZWN0b3IgPSAnYnV0dG9uLCBpbnB1dCwgbWV0ZXIsIG91dHB1dCwgcHJvZ3Jlc3MsIHNlbGVjdCwgdGV4dGFyZWEnO1xuICAgIGNvbnN0IGxhYmVsbGVkRm9ybUNvbnRyb2wgPSBBcnJheS5mcm9tKGxhYmVsLnF1ZXJ5U2VsZWN0b3JBbGwoZm9ybUNvbnRyb2xTZWxlY3RvcikpLmZpbHRlcihmb3JtQ29udHJvbEVsZW1lbnQgPT4gZm9ybUNvbnRyb2xFbGVtZW50Lm1hdGNoZXMoc2VsZWN0b3IpKVswXTtcbiAgICByZXR1cm4ge1xuICAgICAgY29udGVudDogdGV4dFRvTWF0Y2gsXG4gICAgICBmb3JtQ29udHJvbDogbGFiZWxsZWRGb3JtQ29udHJvbFxuICAgIH07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhc3NlcnROb3ROdWxsT3JVbmRlZmluZWQobWF0Y2hlcikge1xuICBpZiAobWF0Y2hlciA9PT0gbnVsbCB8fCBtYXRjaGVyID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnMgLS0gaW1wbGljaXRseSBjb252ZXJ0aW5nIGBUYCB0byBgc3RyaW5nYFxuICAgIFwiSXQgbG9va3MgbGlrZSBcIiArIG1hdGNoZXIgKyBcIiB3YXMgcGFzc2VkIGluc3RlYWQgb2YgYSBtYXRjaGVyLiBEaWQgeW91IGRvIHNvbWV0aGluZyBsaWtlIGdldEJ5VGV4dChcIiArIG1hdGNoZXIgKyBcIik/XCIpO1xuICB9XG59XG5mdW5jdGlvbiBmdXp6eU1hdGNoZXModGV4dFRvTWF0Y2gsIG5vZGUsIG1hdGNoZXIsIG5vcm1hbGl6ZXIpIHtcbiAgaWYgKHR5cGVvZiB0ZXh0VG9NYXRjaCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXNzZXJ0Tm90TnVsbE9yVW5kZWZpbmVkKG1hdGNoZXIpO1xuICBjb25zdCBub3JtYWxpemVkVGV4dCA9IG5vcm1hbGl6ZXIodGV4dFRvTWF0Y2gpO1xuICBpZiAodHlwZW9mIG1hdGNoZXIgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBtYXRjaGVyID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBub3JtYWxpemVkVGV4dC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKG1hdGNoZXIudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbWF0Y2hlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXRjaGVyKG5vcm1hbGl6ZWRUZXh0LCBub2RlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbWF0Y2hSZWdFeHAobWF0Y2hlciwgbm9ybWFsaXplZFRleHQpO1xuICB9XG59XG5mdW5jdGlvbiBtYXRjaGVzKHRleHRUb01hdGNoLCBub2RlLCBtYXRjaGVyLCBub3JtYWxpemVyKSB7XG4gIGlmICh0eXBlb2YgdGV4dFRvTWF0Y2ggIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFzc2VydE5vdE51bGxPclVuZGVmaW5lZChtYXRjaGVyKTtcbiAgY29uc3Qgbm9ybWFsaXplZFRleHQgPSBub3JtYWxpemVyKHRleHRUb01hdGNoKTtcbiAgaWYgKG1hdGNoZXIgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgIHJldHVybiBtYXRjaGVyKG5vcm1hbGl6ZWRUZXh0LCBub2RlKTtcbiAgfSBlbHNlIGlmIChtYXRjaGVyIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIG1hdGNoUmVnRXhwKG1hdGNoZXIsIG5vcm1hbGl6ZWRUZXh0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9ybWFsaXplZFRleHQgPT09IFN0cmluZyhtYXRjaGVyKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdE5vcm1hbGl6ZXIoX3RlbXApIHtcbiAgbGV0IHtcbiAgICB0cmltID0gdHJ1ZSxcbiAgICBjb2xsYXBzZVdoaXRlc3BhY2UgPSB0cnVlXG4gIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcbiAgcmV0dXJuIHRleHQgPT4ge1xuICAgIGxldCBub3JtYWxpemVkVGV4dCA9IHRleHQ7XG4gICAgbm9ybWFsaXplZFRleHQgPSB0cmltID8gbm9ybWFsaXplZFRleHQudHJpbSgpIDogbm9ybWFsaXplZFRleHQ7XG4gICAgbm9ybWFsaXplZFRleHQgPSBjb2xsYXBzZVdoaXRlc3BhY2UgPyBub3JtYWxpemVkVGV4dC5yZXBsYWNlKC9cXHMrL2csICcgJykgOiBub3JtYWxpemVkVGV4dDtcbiAgICByZXR1cm4gbm9ybWFsaXplZFRleHQ7XG4gIH07XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5vcm1hbGl6ZXIgdG8gcGFzcyB0byBmdW5jdGlvbnMgaW4gbWF0Y2hlcy5qc1xuICogQHBhcmFtIHtib29sZWFufHVuZGVmaW5lZH0gdHJpbSBUaGUgdXNlci1zcGVjaWZpZWQgdmFsdWUgZm9yIGB0cmltYCwgd2l0aG91dFxuICogYW55IGRlZmF1bHRpbmcgaGF2aW5nIGJlZW4gYXBwbGllZFxuICogQHBhcmFtIHtib29sZWFufHVuZGVmaW5lZH0gY29sbGFwc2VXaGl0ZXNwYWNlIFRoZSB1c2VyLXNwZWNpZmllZCB2YWx1ZSBmb3JcbiAqIGBjb2xsYXBzZVdoaXRlc3BhY2VgLCB3aXRob3V0IGFueSBkZWZhdWx0aW5nIGhhdmluZyBiZWVuIGFwcGxpZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb258dW5kZWZpbmVkfSBub3JtYWxpemVyIFRoZSB1c2VyLXNwZWNpZmllZCBub3JtYWxpemVyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgbm9ybWFsaXplclxuICovXG5cbmZ1bmN0aW9uIG1ha2VOb3JtYWxpemVyKF9yZWYpIHtcbiAgbGV0IHtcbiAgICB0cmltLFxuICAgIGNvbGxhcHNlV2hpdGVzcGFjZSxcbiAgICBub3JtYWxpemVyXG4gIH0gPSBfcmVmO1xuICBpZiAoIW5vcm1hbGl6ZXIpIHtcbiAgICAvLyBObyBjdXN0b20gbm9ybWFsaXplciBzcGVjaWZpZWQuIEp1c3QgdXNlIGRlZmF1bHQuXG4gICAgcmV0dXJuIGdldERlZmF1bHROb3JtYWxpemVyKHtcbiAgICAgIHRyaW0sXG4gICAgICBjb2xsYXBzZVdoaXRlc3BhY2VcbiAgICB9KTtcbiAgfVxuICBpZiAodHlwZW9mIHRyaW0gIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBjb2xsYXBzZVdoaXRlc3BhY2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gVGhleSd2ZSBhbHNvIHNwZWNpZmllZCBhIHZhbHVlIGZvciB0cmltIG9yIGNvbGxhcHNlV2hpdGVzcGFjZVxuICAgIHRocm93IG5ldyBFcnJvcigndHJpbSBhbmQgY29sbGFwc2VXaGl0ZXNwYWNlIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggYSBub3JtYWxpemVyLiAnICsgJ0lmIHlvdSB3YW50IHRvIHVzZSB0aGUgZGVmYXVsdCB0cmltIGFuZCBjb2xsYXBzZVdoaXRlc3BhY2UgbG9naWMgaW4geW91ciBub3JtYWxpemVyLCAnICsgJ3VzZSBcImdldERlZmF1bHROb3JtYWxpemVyKHt0cmltLCBjb2xsYXBzZVdoaXRlc3BhY2V9KVwiIGFuZCBjb21wb3NlIHRoYXQgaW50byB5b3VyIG5vcm1hbGl6ZXInKTtcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplcjtcbn1cbmZ1bmN0aW9uIG1hdGNoUmVnRXhwKG1hdGNoZXIsIHRleHQpIHtcbiAgY29uc3QgbWF0Y2ggPSBtYXRjaGVyLnRlc3QodGV4dCk7XG4gIGlmIChtYXRjaGVyLmdsb2JhbCAmJiBtYXRjaGVyLmxhc3RJbmRleCAhPT0gMCkge1xuICAgIGNvbnNvbGUud2FybihcIlRvIG1hdGNoIGFsbCBlbGVtZW50cyB3ZSBoYWQgdG8gcmVzZXQgdGhlIGxhc3RJbmRleCBvZiB0aGUgUmVnRXhwIGJlY2F1c2UgdGhlIGdsb2JhbCBmbGFnIGlzIGVuYWJsZWQuIFdlIGVuY291cmFnZSB0byByZW1vdmUgdGhlIGdsb2JhbCBmbGFnIGZyb20gdGhlIFJlZ0V4cC5cIik7XG4gICAgbWF0Y2hlci5sYXN0SW5kZXggPSAwO1xuICB9XG4gIHJldHVybiBtYXRjaDtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZVRleHQobm9kZSkge1xuICBpZiAobm9kZS5tYXRjaGVzKCdpbnB1dFt0eXBlPXN1Ym1pdF0sIGlucHV0W3R5cGU9YnV0dG9uXSwgaW5wdXRbdHlwZT1yZXNldF0nKSkge1xuICAgIHJldHVybiBub2RlLnZhbHVlO1xuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKG5vZGUuY2hpbGROb2RlcykuZmlsdGVyKGNoaWxkID0+IGNoaWxkLm5vZGVUeXBlID09PSBURVhUX05PREUgJiYgQm9vbGVhbihjaGlsZC50ZXh0Q29udGVudCkpLm1hcChjID0+IGMudGV4dENvbnRlbnQpLmpvaW4oJycpO1xufVxuXG5jb25zdCBlbGVtZW50Um9sZUxpc3QgPSBidWlsZEVsZW1lbnRSb2xlTGlzdChlbGVtZW50Um9sZXMpO1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBgdHJ1ZWAgaWYgYGVsZW1lbnRgIGFuZCBpdHMgc3VidHJlZSBhcmUgaW5hY2Nlc3NpYmxlXG4gKi9cbmZ1bmN0aW9uIGlzU3VidHJlZUluYWNjZXNzaWJsZShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50LmhpZGRlbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKSA9PT0gJ3RydWUnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3Qgd2luZG93ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICBpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFBhcnRpYWwgaW1wbGVtZW50YXRpb24gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dhaS1hcmlhLTEuMi8jdHJlZV9leGNsdXNpb25cbiAqIHdoaWNoIHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIGVsZW1lbnRzIHdpdGggYSBub24tcHJlc2VudGF0aW9uYWwgcm9sZSBpLmUuXG4gKiBgcm9sZT1cIm5vbmVcImAgYW5kIGByb2xlPVwicHJlc2VudGF0aW9uXCJgIHdpbGwgbm90IGJlIGV4Y2x1ZGVkLlxuICpcbiAqIEltcGxlbWVudHMgYXJpYS1oaWRkZW4gc2VtYW50aWNzIChpLmUuIHBhcmVudCBvdmVycmlkZXMgY2hpbGQpXG4gKiBJZ25vcmVzIFwiQ2hpbGQgUHJlc2VudGF0aW9uYWw6IFRydWVcIiBjaGFyYWN0ZXJpc3RpY3NcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtXG4gKiBAcGFyYW0ge2Z1bmN0aW9uIChlbGVtZW50OiBFbGVtZW50KTogYm9vbGVhbn0gb3B0aW9ucy5pc1N1YnRyZWVJbmFjY2Vzc2libGUgLVxuICogY2FuIGJlIHVzZWQgdG8gcmV0dXJuIGNhY2hlZCByZXN1bHRzIGZyb20gcHJldmlvdXMgaXNTdWJ0cmVlSW5hY2Nlc3NpYmxlIGNhbGxzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBleGNsdWRlZCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzSW5hY2Nlc3NpYmxlKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgaXNTdWJ0cmVlSW5hY2Nlc3NpYmxlOiBpc1N1YnRyZWVJbmFjY2Vzc2libGVJbXBsID0gaXNTdWJ0cmVlSW5hY2Nlc3NpYmxlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCB3aW5kb3cgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gIC8vIHNpbmNlIHZpc2liaWxpdHkgaXMgaW5oZXJpdGVkIHdlIGNhbiBleGl0IGVhcmx5XG4gIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS52aXNpYmlsaXR5ID09PSAnaGlkZGVuJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGxldCBjdXJyZW50RWxlbWVudCA9IGVsZW1lbnQ7XG4gIHdoaWxlIChjdXJyZW50RWxlbWVudCkge1xuICAgIGlmIChpc1N1YnRyZWVJbmFjY2Vzc2libGVJbXBsKGN1cnJlbnRFbGVtZW50KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGN1cnJlbnRFbGVtZW50ID0gY3VycmVudEVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRJbXBsaWNpdEFyaWFSb2xlcyhjdXJyZW50Tm9kZSkge1xuICAvLyBlc2xpbnQgYnVnIGhlcmU6XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBmb3IgKGNvbnN0IHtcbiAgICBtYXRjaCxcbiAgICByb2xlc1xuICB9IG9mIGVsZW1lbnRSb2xlTGlzdCkge1xuICAgIGlmIChtYXRjaChjdXJyZW50Tm9kZSkpIHtcbiAgICAgIHJldHVybiBbLi4ucm9sZXNdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBidWlsZEVsZW1lbnRSb2xlTGlzdChlbGVtZW50Um9sZXNNYXApIHtcbiAgZnVuY3Rpb24gbWFrZUVsZW1lbnRTZWxlY3RvcihfcmVmKSB7XG4gICAgbGV0IHtcbiAgICAgIG5hbWUsXG4gICAgICBhdHRyaWJ1dGVzXG4gICAgfSA9IF9yZWY7XG4gICAgcmV0dXJuIFwiXCIgKyBuYW1lICsgYXR0cmlidXRlcy5tYXAoX3JlZjIgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgbmFtZTogYXR0cmlidXRlTmFtZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGNvbnN0cmFpbnRzID0gW11cbiAgICAgIH0gPSBfcmVmMjtcbiAgICAgIGNvbnN0IHNob3VsZE5vdEV4aXN0ID0gY29uc3RyYWludHMuaW5kZXhPZigndW5kZWZpbmVkJykgIT09IC0xO1xuICAgICAgaWYgKHNob3VsZE5vdEV4aXN0KSB7XG4gICAgICAgIHJldHVybiBcIjpub3QoW1wiICsgYXR0cmlidXRlTmFtZSArIFwiXSlcIjtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFwiW1wiICsgYXR0cmlidXRlTmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiW1wiICsgYXR0cmlidXRlTmFtZSArIFwiXVwiO1xuICAgICAgfVxuICAgIH0pLmpvaW4oJycpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFNlbGVjdG9yU3BlY2lmaWNpdHkoX3JlZjMpIHtcbiAgICBsZXQge1xuICAgICAgYXR0cmlidXRlcyA9IFtdXG4gICAgfSA9IF9yZWYzO1xuICAgIHJldHVybiBhdHRyaWJ1dGVzLmxlbmd0aDtcbiAgfVxuICBmdW5jdGlvbiBieVNlbGVjdG9yU3BlY2lmaWNpdHkoX3JlZjQsIF9yZWY1KSB7XG4gICAgbGV0IHtcbiAgICAgIHNwZWNpZmljaXR5OiBsZWZ0U3BlY2lmaWNpdHlcbiAgICB9ID0gX3JlZjQ7XG4gICAgbGV0IHtcbiAgICAgIHNwZWNpZmljaXR5OiByaWdodFNwZWNpZmljaXR5XG4gICAgfSA9IF9yZWY1O1xuICAgIHJldHVybiByaWdodFNwZWNpZmljaXR5IC0gbGVmdFNwZWNpZmljaXR5O1xuICB9XG4gIGZ1bmN0aW9uIG1hdGNoKGVsZW1lbnQpIHtcbiAgICBsZXQge1xuICAgICAgYXR0cmlidXRlcyA9IFtdXG4gICAgfSA9IGVsZW1lbnQ7XG5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGVzdGluZy1saWJyYXJ5L2RvbS10ZXN0aW5nLWxpYnJhcnkvaXNzdWVzLzgxNFxuICAgIGNvbnN0IHR5cGVUZXh0SW5kZXggPSBhdHRyaWJ1dGVzLmZpbmRJbmRleChhdHRyaWJ1dGUgPT4gYXR0cmlidXRlLnZhbHVlICYmIGF0dHJpYnV0ZS5uYW1lID09PSAndHlwZScgJiYgYXR0cmlidXRlLnZhbHVlID09PSAndGV4dCcpO1xuICAgIGlmICh0eXBlVGV4dEluZGV4ID49IDApIHtcbiAgICAgIC8vIG5vdCB1c2luZyBzcGxpY2UgdG8gbm90IG11dGF0ZSB0aGUgYXR0cmlidXRlcyBhcnJheVxuICAgICAgYXR0cmlidXRlcyA9IFsuLi5hdHRyaWJ1dGVzLnNsaWNlKDAsIHR5cGVUZXh0SW5kZXgpLCAuLi5hdHRyaWJ1dGVzLnNsaWNlKHR5cGVUZXh0SW5kZXggKyAxKV07XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdG9yID0gbWFrZUVsZW1lbnRTZWxlY3Rvcih7XG4gICAgICAuLi5lbGVtZW50LFxuICAgICAgYXR0cmlidXRlc1xuICAgIH0pO1xuICAgIHJldHVybiBub2RlID0+IHtcbiAgICAgIGlmICh0eXBlVGV4dEluZGV4ID49IDAgJiYgbm9kZS50eXBlICE9PSAndGV4dCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGUubWF0Y2hlcyhzZWxlY3Rvcik7XG4gICAgfTtcbiAgfVxuICBsZXQgcmVzdWx0ID0gW107XG5cbiAgLy8gZXNsaW50IGJ1ZyBoZXJlOlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgZm9yIChjb25zdCBbZWxlbWVudCwgcm9sZXNdIG9mIGVsZW1lbnRSb2xlc01hcC5lbnRyaWVzKCkpIHtcbiAgICByZXN1bHQgPSBbLi4ucmVzdWx0LCB7XG4gICAgICBtYXRjaDogbWF0Y2goZWxlbWVudCksXG4gICAgICByb2xlczogQXJyYXkuZnJvbShyb2xlcyksXG4gICAgICBzcGVjaWZpY2l0eTogZ2V0U2VsZWN0b3JTcGVjaWZpY2l0eShlbGVtZW50KVxuICAgIH1dO1xuICB9XG4gIHJldHVybiByZXN1bHQuc29ydChieVNlbGVjdG9yU3BlY2lmaWNpdHkpO1xufVxuZnVuY3Rpb24gZ2V0Um9sZXMoY29udGFpbmVyLCBfdGVtcCkge1xuICBsZXQge1xuICAgIGhpZGRlbiA9IGZhbHNlXG4gIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcbiAgZnVuY3Rpb24gZmxhdHRlbkRPTShub2RlKSB7XG4gICAgcmV0dXJuIFtub2RlLCAuLi5BcnJheS5mcm9tKG5vZGUuY2hpbGRyZW4pLnJlZHVjZSgoYWNjLCBjaGlsZCkgPT4gWy4uLmFjYywgLi4uZmxhdHRlbkRPTShjaGlsZCldLCBbXSldO1xuICB9XG4gIHJldHVybiBmbGF0dGVuRE9NKGNvbnRhaW5lcikuZmlsdGVyKGVsZW1lbnQgPT4ge1xuICAgIHJldHVybiBoaWRkZW4gPT09IGZhbHNlID8gaXNJbmFjY2Vzc2libGUoZWxlbWVudCkgPT09IGZhbHNlIDogdHJ1ZTtcbiAgfSkucmVkdWNlKChhY2MsIG5vZGUpID0+IHtcbiAgICBsZXQgcm9sZXMgPSBbXTtcbiAgICAvLyBUT0RPOiBUaGlzIHZpb2xhdGVzIGh0bWwtYXJpYSB3aGljaCBkb2VzIG5vdCBhbGxvdyBhbnkgcm9sZSBvbiBldmVyeSBlbGVtZW50XG4gICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlKCdyb2xlJykpIHtcbiAgICAgIHJvbGVzID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ3JvbGUnKS5zcGxpdCgnICcpLnNsaWNlKDAsIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByb2xlcyA9IGdldEltcGxpY2l0QXJpYVJvbGVzKG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gcm9sZXMucmVkdWNlKChyb2xlc0FjYywgcm9sZSkgPT4gQXJyYXkuaXNBcnJheShyb2xlc0FjY1tyb2xlXSkgPyB7XG4gICAgICAuLi5yb2xlc0FjYyxcbiAgICAgIFtyb2xlXTogWy4uLnJvbGVzQWNjW3JvbGVdLCBub2RlXVxuICAgIH0gOiB7XG4gICAgICAuLi5yb2xlc0FjYyxcbiAgICAgIFtyb2xlXTogW25vZGVdXG4gICAgfSwgYWNjKTtcbiAgfSwge30pO1xufVxuZnVuY3Rpb24gcHJldHR5Um9sZXMoZG9tLCBfcmVmNikge1xuICBsZXQge1xuICAgIGhpZGRlbixcbiAgICBpbmNsdWRlRGVzY3JpcHRpb25cbiAgfSA9IF9yZWY2O1xuICBjb25zdCByb2xlcyA9IGdldFJvbGVzKGRvbSwge1xuICAgIGhpZGRlblxuICB9KTtcbiAgLy8gV2UgcHJlZmVyIHRvIHNraXAgZ2VuZXJpYyByb2xlLCB3ZSBkb24ndCByZWNvbW1lbmQgaXRcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJvbGVzKS5maWx0ZXIoX3JlZjcgPT4ge1xuICAgIGxldCBbcm9sZV0gPSBfcmVmNztcbiAgICByZXR1cm4gcm9sZSAhPT0gJ2dlbmVyaWMnO1xuICB9KS5tYXAoX3JlZjggPT4ge1xuICAgIGxldCBbcm9sZSwgZWxlbWVudHNdID0gX3JlZjg7XG4gICAgY29uc3QgZGVsaW1pdGVyQmFyID0gJy0nLnJlcGVhdCg1MCk7XG4gICAgY29uc3QgZWxlbWVudHNTdHJpbmcgPSBlbGVtZW50cy5tYXAoZWwgPT4ge1xuICAgICAgY29uc3QgbmFtZVN0cmluZyA9IFwiTmFtZSBcXFwiXCIgKyBjb21wdXRlQWNjZXNzaWJsZU5hbWUoZWwsIHtcbiAgICAgICAgY29tcHV0ZWRTdHlsZVN1cHBvcnRzUHNldWRvRWxlbWVudHM6IGdldENvbmZpZygpLmNvbXB1dGVkU3R5bGVTdXBwb3J0c1BzZXVkb0VsZW1lbnRzXG4gICAgICB9KSArIFwiXFxcIjpcXG5cIjtcbiAgICAgIGNvbnN0IGRvbVN0cmluZyA9IHByZXR0eURPTShlbC5jbG9uZU5vZGUoZmFsc2UpKTtcbiAgICAgIGlmIChpbmNsdWRlRGVzY3JpcHRpb24pIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb25TdHJpbmcgPSBcIkRlc2NyaXB0aW9uIFxcXCJcIiArIGNvbXB1dGVBY2Nlc3NpYmxlRGVzY3JpcHRpb24oZWwsIHtcbiAgICAgICAgICBjb21wdXRlZFN0eWxlU3VwcG9ydHNQc2V1ZG9FbGVtZW50czogZ2V0Q29uZmlnKCkuY29tcHV0ZWRTdHlsZVN1cHBvcnRzUHNldWRvRWxlbWVudHNcbiAgICAgICAgfSkgKyBcIlxcXCI6XFxuXCI7XG4gICAgICAgIHJldHVybiBcIlwiICsgbmFtZVN0cmluZyArIGRlc2NyaXB0aW9uU3RyaW5nICsgZG9tU3RyaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiXCIgKyBuYW1lU3RyaW5nICsgZG9tU3RyaW5nO1xuICAgIH0pLmpvaW4oJ1xcblxcbicpO1xuICAgIHJldHVybiByb2xlICsgXCI6XFxuXFxuXCIgKyBlbGVtZW50c1N0cmluZyArIFwiXFxuXFxuXCIgKyBkZWxpbWl0ZXJCYXI7XG4gIH0pLmpvaW4oJ1xcbicpO1xufVxuY29uc3QgbG9nUm9sZXMgPSBmdW5jdGlvbiAoZG9tLCBfdGVtcDIpIHtcbiAgbGV0IHtcbiAgICBoaWRkZW4gPSBmYWxzZVxuICB9ID0gX3RlbXAyID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wMjtcbiAgcmV0dXJuIGNvbnNvbGUubG9nKHByZXR0eVJvbGVzKGRvbSwge1xuICAgIGhpZGRlblxuICB9KSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtXG4gKiBAcmV0dXJucyB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gLSBmYWxzZS90cnVlIGlmIChub3Qpc2VsZWN0ZWQsIHVuZGVmaW5lZCBpZiBub3Qgc2VsZWN0YWJsZVxuICovXG5mdW5jdGlvbiBjb21wdXRlQXJpYVNlbGVjdGVkKGVsZW1lbnQpIHtcbiAgLy8gaW1wbGljaXQgdmFsdWUgZnJvbSBodG1sLWFhbSBtYXBwaW5nczogaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWwtYWFtLTEuMC8jaHRtbC1hdHRyaWJ1dGUtc3RhdGUtYW5kLXByb3BlcnR5LW1hcHBpbmdzXG4gIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sLWFhbS0xLjAvI2RldGFpbHMtaWQtOTdcbiAgaWYgKGVsZW1lbnQudGFnTmFtZSA9PT0gJ09QVElPTicpIHtcbiAgICByZXR1cm4gZWxlbWVudC5zZWxlY3RlZDtcbiAgfVxuXG4gIC8vIGV4cGxpY2l0IHZhbHVlXG4gIHJldHVybiBjaGVja0Jvb2xlYW5BdHRyaWJ1dGUoZWxlbWVudCwgJ2FyaWEtc2VsZWN0ZWQnKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLVxuICogQHJldHVybnMge2Jvb2xlYW59IC1cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUFyaWFCdXN5KGVsZW1lbnQpIHtcbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dhaS1hcmlhLTEuMS8jYXJpYS1idXN5XG4gIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS1idXN5JykgPT09ICd0cnVlJztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLVxuICogQHJldHVybnMge2Jvb2xlYW4gfCB1bmRlZmluZWR9IC0gZmFsc2UvdHJ1ZSBpZiAobm90KWNoZWNrZWQsIHVuZGVmaW5lZCBpZiBub3QgY2hlY2tlZC1hYmxlXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVBcmlhQ2hlY2tlZChlbGVtZW50KSB7XG4gIC8vIGltcGxpY2l0IHZhbHVlIGZyb20gaHRtbC1hYW0gbWFwcGluZ3M6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sLWFhbS0xLjAvI2h0bWwtYXR0cmlidXRlLXN0YXRlLWFuZC1wcm9wZXJ0eS1tYXBwaW5nc1xuICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbC1hYW0tMS4wLyNkZXRhaWxzLWlkLTU2XG4gIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sLWFhbS0xLjAvI2RldGFpbHMtaWQtNjdcbiAgaWYgKCdpbmRldGVybWluYXRlJyBpbiBlbGVtZW50ICYmIGVsZW1lbnQuaW5kZXRlcm1pbmF0ZSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKCdjaGVja2VkJyBpbiBlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2hlY2tlZDtcbiAgfVxuXG4gIC8vIGV4cGxpY2l0IHZhbHVlXG4gIHJldHVybiBjaGVja0Jvb2xlYW5BdHRyaWJ1dGUoZWxlbWVudCwgJ2FyaWEtY2hlY2tlZCcpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtXG4gKiBAcmV0dXJucyB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gLSBmYWxzZS90cnVlIGlmIChub3QpcHJlc3NlZCwgdW5kZWZpbmVkIGlmIG5vdCBwcmVzcy1hYmxlXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVBcmlhUHJlc3NlZChlbGVtZW50KSB7XG4gIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93YWktYXJpYS0xLjEvI2FyaWEtcHJlc3NlZFxuICByZXR1cm4gY2hlY2tCb29sZWFuQXR0cmlidXRlKGVsZW1lbnQsICdhcmlhLXByZXNzZWQnKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLVxuICogQHJldHVybnMge2Jvb2xlYW4gfCBzdHJpbmcgfCBudWxsfSAtXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVBcmlhQ3VycmVudChlbGVtZW50KSB7XG4gIHZhciBfcmVmOSwgX2NoZWNrQm9vbGVhbkF0dHJpYnV0O1xuICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2FpLWFyaWEtMS4xLyNhcmlhLWN1cnJlbnRcbiAgcmV0dXJuIChfcmVmOSA9IChfY2hlY2tCb29sZWFuQXR0cmlidXQgPSBjaGVja0Jvb2xlYW5BdHRyaWJ1dGUoZWxlbWVudCwgJ2FyaWEtY3VycmVudCcpKSAhPSBudWxsID8gX2NoZWNrQm9vbGVhbkF0dHJpYnV0IDogZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FyaWEtY3VycmVudCcpKSAhPSBudWxsID8gX3JlZjkgOiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLVxuICogQHJldHVybnMge2Jvb2xlYW4gfCB1bmRlZmluZWR9IC0gZmFsc2UvdHJ1ZSBpZiAobm90KWV4cGFuZGVkLCB1bmRlZmluZWQgaWYgbm90IGV4cGFuZC1hYmxlXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVBcmlhRXhwYW5kZWQoZWxlbWVudCkge1xuICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2FpLWFyaWEtMS4xLyNhcmlhLWV4cGFuZGVkXG4gIHJldHVybiBjaGVja0Jvb2xlYW5BdHRyaWJ1dGUoZWxlbWVudCwgJ2FyaWEtZXhwYW5kZWQnKTtcbn1cbmZ1bmN0aW9uIGNoZWNrQm9vbGVhbkF0dHJpYnV0ZShlbGVtZW50LCBhdHRyaWJ1dGUpIHtcbiAgY29uc3QgYXR0cmlidXRlVmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICBpZiAoYXR0cmlidXRlVmFsdWUgPT09ICd0cnVlJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChhdHRyaWJ1dGVWYWx1ZSA9PT0gJ2ZhbHNlJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtXG4gKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfSAtIG51bWJlciBpZiBpbXBsaWNpdCBoZWFkaW5nIG9yIGFyaWEtbGV2ZWwgcHJlc2VudCwgb3RoZXJ3aXNlIHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBjb21wdXRlSGVhZGluZ0xldmVsKGVsZW1lbnQpIHtcbiAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL2h0bWwtYWFtLyNlbC1oMS1oNlxuICAvLyBodHRwczovL3czYy5naXRodWIuaW8vaHRtbC1hYW0vI2VsLWgxLWg2XG4gIGNvbnN0IGltcGxpY2l0SGVhZGluZ0xldmVscyA9IHtcbiAgICBIMTogMSxcbiAgICBIMjogMixcbiAgICBIMzogMyxcbiAgICBINDogNCxcbiAgICBINTogNSxcbiAgICBINjogNlxuICB9O1xuICAvLyBleHBsaWNpdCBhcmlhLWxldmVsIHZhbHVlXG4gIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93YWktYXJpYS0xLjIvI2FyaWEtbGV2ZWxcbiAgY29uc3QgYXJpYUxldmVsQXR0cmlidXRlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGV2ZWwnKSAmJiBOdW1iZXIoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGV2ZWwnKSk7XG4gIHJldHVybiBhcmlhTGV2ZWxBdHRyaWJ1dGUgfHwgaW1wbGljaXRIZWFkaW5nTGV2ZWxzW2VsZW1lbnQudGFnTmFtZV07XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC1cbiAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9IC1cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUFyaWFWYWx1ZU5vdyhlbGVtZW50KSB7XG4gIGNvbnN0IHZhbHVlTm93ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FyaWEtdmFsdWVub3cnKTtcbiAgcmV0dXJuIHZhbHVlTm93ID09PSBudWxsID8gdW5kZWZpbmVkIDogK3ZhbHVlTm93O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtXG4gKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfSAtXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVBcmlhVmFsdWVNYXgoZWxlbWVudCkge1xuICBjb25zdCB2YWx1ZU1heCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdhcmlhLXZhbHVlbWF4Jyk7XG4gIHJldHVybiB2YWx1ZU1heCA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6ICt2YWx1ZU1heDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLVxuICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH0gLVxuICovXG5mdW5jdGlvbiBjb21wdXRlQXJpYVZhbHVlTWluKGVsZW1lbnQpIHtcbiAgY29uc3QgdmFsdWVNaW4gPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS12YWx1ZW1pbicpO1xuICByZXR1cm4gdmFsdWVNaW4gPT09IG51bGwgPyB1bmRlZmluZWQgOiArdmFsdWVNaW47XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC1cbiAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9IC1cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUFyaWFWYWx1ZVRleHQoZWxlbWVudCkge1xuICBjb25zdCB2YWx1ZVRleHQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS12YWx1ZXRleHQnKTtcbiAgcmV0dXJuIHZhbHVlVGV4dCA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHZhbHVlVGV4dDtcbn1cblxuY29uc3Qgbm9ybWFsaXplID0gZ2V0RGVmYXVsdE5vcm1hbGl6ZXIoKTtcbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bLiorXFwtP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpOyAvLyAkJiBtZWFucyB0aGUgd2hvbGUgbWF0Y2hlZCBzdHJpbmdcbn1cblxuZnVuY3Rpb24gZ2V0UmVnRXhwTWF0Y2hlcihzdHJpbmcpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoZXNjYXBlUmVnRXhwKHN0cmluZy50b0xvd2VyQ2FzZSgpKSwgJ2knKTtcbn1cbmZ1bmN0aW9uIG1ha2VTdWdnZXN0aW9uKHF1ZXJ5TmFtZSwgZWxlbWVudCwgY29udGVudCwgX3JlZikge1xuICBsZXQge1xuICAgIHZhcmlhbnQsXG4gICAgbmFtZVxuICB9ID0gX3JlZjtcbiAgbGV0IHdhcm5pbmcgPSAnJztcbiAgY29uc3QgcXVlcnlPcHRpb25zID0ge307XG4gIGNvbnN0IHF1ZXJ5QXJncyA9IFtbJ1JvbGUnLCAnVGVzdElkJ10uaW5jbHVkZXMocXVlcnlOYW1lKSA/IGNvbnRlbnQgOiBnZXRSZWdFeHBNYXRjaGVyKGNvbnRlbnQpXTtcbiAgaWYgKG5hbWUpIHtcbiAgICBxdWVyeU9wdGlvbnMubmFtZSA9IGdldFJlZ0V4cE1hdGNoZXIobmFtZSk7XG4gIH1cbiAgaWYgKHF1ZXJ5TmFtZSA9PT0gJ1JvbGUnICYmIGlzSW5hY2Nlc3NpYmxlKGVsZW1lbnQpKSB7XG4gICAgcXVlcnlPcHRpb25zLmhpZGRlbiA9IHRydWU7XG4gICAgd2FybmluZyA9IFwiRWxlbWVudCBpcyBpbmFjY2Vzc2libGUuIFRoaXMgbWVhbnMgdGhhdCB0aGUgZWxlbWVudCBhbmQgYWxsIGl0cyBjaGlsZHJlbiBhcmUgaW52aXNpYmxlIHRvIHNjcmVlbiByZWFkZXJzLlxcbiAgICBJZiB5b3UgYXJlIHVzaW5nIHRoZSBhcmlhLWhpZGRlbiBwcm9wLCBtYWtlIHN1cmUgdGhpcyBpcyB0aGUgcmlnaHQgY2hvaWNlIGZvciB5b3VyIGNhc2UuXFxuICAgIFwiO1xuICB9XG4gIGlmIChPYmplY3Qua2V5cyhxdWVyeU9wdGlvbnMpLmxlbmd0aCA+IDApIHtcbiAgICBxdWVyeUFyZ3MucHVzaChxdWVyeU9wdGlvbnMpO1xuICB9XG4gIGNvbnN0IHF1ZXJ5TWV0aG9kID0gdmFyaWFudCArIFwiQnlcIiArIHF1ZXJ5TmFtZTtcbiAgcmV0dXJuIHtcbiAgICBxdWVyeU5hbWUsXG4gICAgcXVlcnlNZXRob2QsXG4gICAgcXVlcnlBcmdzLFxuICAgIHZhcmlhbnQsXG4gICAgd2FybmluZyxcbiAgICB0b1N0cmluZygpIHtcbiAgICAgIGlmICh3YXJuaW5nKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbiAgICAgIH1cbiAgICAgIGxldCBbdGV4dCwgb3B0aW9uc10gPSBxdWVyeUFyZ3M7XG4gICAgICB0ZXh0ID0gdHlwZW9mIHRleHQgPT09ICdzdHJpbmcnID8gXCInXCIgKyB0ZXh0ICsgXCInXCIgOiB0ZXh0O1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBcIiwgeyBcIiArIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMpLm1hcChfcmVmMiA9PiB7XG4gICAgICAgIGxldCBbaywgdl0gPSBfcmVmMjtcbiAgICAgICAgcmV0dXJuIGsgKyBcIjogXCIgKyB2O1xuICAgICAgfSkuam9pbignLCAnKSArIFwiIH1cIiA6ICcnO1xuICAgICAgcmV0dXJuIHF1ZXJ5TWV0aG9kICsgXCIoXCIgKyB0ZXh0ICsgb3B0aW9ucyArIFwiKVwiO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNhblN1Z2dlc3QoY3VycmVudE1ldGhvZCwgcmVxdWVzdGVkTWV0aG9kLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhICYmICghcmVxdWVzdGVkTWV0aG9kIHx8IHJlcXVlc3RlZE1ldGhvZC50b0xvd2VyQ2FzZSgpID09PSBjdXJyZW50TWV0aG9kLnRvTG93ZXJDYXNlKCkpO1xufVxuZnVuY3Rpb24gZ2V0U3VnZ2VzdGVkUXVlcnkoZWxlbWVudCwgdmFyaWFudCwgbWV0aG9kKSB7XG4gIHZhciBfZWxlbWVudCRnZXRBdHRyaWJ1dGUsIF9nZXRJbXBsaWNpdEFyaWFSb2xlcztcbiAgaWYgKHZhcmlhbnQgPT09IHZvaWQgMCkge1xuICAgIHZhcmlhbnQgPSAnZ2V0JztcbiAgfVxuICAvLyBkb24ndCBjcmVhdGUgc3VnZ2VzdGlvbnMgZm9yIHNjcmlwdCBhbmQgc3R5bGUgZWxlbWVudHNcbiAgaWYgKGVsZW1lbnQubWF0Y2hlcyhnZXRDb25maWcoKS5kZWZhdWx0SWdub3JlKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvL1dlIHByZWZlciB0byBzdWdnZXN0IHNvbWV0aGluZyBlbHNlIGlmIHRoZSByb2xlIGlzIGdlbmVyaWNcbiAgY29uc3Qgcm9sZSA9IChfZWxlbWVudCRnZXRBdHRyaWJ1dGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgncm9sZScpKSAhPSBudWxsID8gX2VsZW1lbnQkZ2V0QXR0cmlidXRlIDogKF9nZXRJbXBsaWNpdEFyaWFSb2xlcyA9IGdldEltcGxpY2l0QXJpYVJvbGVzKGVsZW1lbnQpKSA9PSBudWxsID8gdm9pZCAwIDogX2dldEltcGxpY2l0QXJpYVJvbGVzWzBdO1xuICBpZiAocm9sZSAhPT0gJ2dlbmVyaWMnICYmIGNhblN1Z2dlc3QoJ1JvbGUnLCBtZXRob2QsIHJvbGUpKSB7XG4gICAgcmV0dXJuIG1ha2VTdWdnZXN0aW9uKCdSb2xlJywgZWxlbWVudCwgcm9sZSwge1xuICAgICAgdmFyaWFudCxcbiAgICAgIG5hbWU6IGNvbXB1dGVBY2Nlc3NpYmxlTmFtZShlbGVtZW50LCB7XG4gICAgICAgIGNvbXB1dGVkU3R5bGVTdXBwb3J0c1BzZXVkb0VsZW1lbnRzOiBnZXRDb25maWcoKS5jb21wdXRlZFN0eWxlU3VwcG9ydHNQc2V1ZG9FbGVtZW50c1xuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICBjb25zdCBsYWJlbFRleHQgPSBnZXRMYWJlbHMoZG9jdW1lbnQsIGVsZW1lbnQpLm1hcChsYWJlbCA9PiBsYWJlbC5jb250ZW50KS5qb2luKCcgJyk7XG4gIGlmIChjYW5TdWdnZXN0KCdMYWJlbFRleHQnLCBtZXRob2QsIGxhYmVsVGV4dCkpIHtcbiAgICByZXR1cm4gbWFrZVN1Z2dlc3Rpb24oJ0xhYmVsVGV4dCcsIGVsZW1lbnQsIGxhYmVsVGV4dCwge1xuICAgICAgdmFyaWFudFxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHBsYWNlaG9sZGVyVGV4dCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdwbGFjZWhvbGRlcicpO1xuICBpZiAoY2FuU3VnZ2VzdCgnUGxhY2Vob2xkZXJUZXh0JywgbWV0aG9kLCBwbGFjZWhvbGRlclRleHQpKSB7XG4gICAgcmV0dXJuIG1ha2VTdWdnZXN0aW9uKCdQbGFjZWhvbGRlclRleHQnLCBlbGVtZW50LCBwbGFjZWhvbGRlclRleHQsIHtcbiAgICAgIHZhcmlhbnRcbiAgICB9KTtcbiAgfVxuICBjb25zdCB0ZXh0Q29udGVudCA9IG5vcm1hbGl6ZShnZXROb2RlVGV4dChlbGVtZW50KSk7XG4gIGlmIChjYW5TdWdnZXN0KCdUZXh0JywgbWV0aG9kLCB0ZXh0Q29udGVudCkpIHtcbiAgICByZXR1cm4gbWFrZVN1Z2dlc3Rpb24oJ1RleHQnLCBlbGVtZW50LCB0ZXh0Q29udGVudCwge1xuICAgICAgdmFyaWFudFxuICAgIH0pO1xuICB9XG4gIGlmIChjYW5TdWdnZXN0KCdEaXNwbGF5VmFsdWUnLCBtZXRob2QsIGVsZW1lbnQudmFsdWUpKSB7XG4gICAgcmV0dXJuIG1ha2VTdWdnZXN0aW9uKCdEaXNwbGF5VmFsdWUnLCBlbGVtZW50LCBub3JtYWxpemUoZWxlbWVudC52YWx1ZSksIHtcbiAgICAgIHZhcmlhbnRcbiAgICB9KTtcbiAgfVxuICBjb25zdCBhbHQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnYWx0Jyk7XG4gIGlmIChjYW5TdWdnZXN0KCdBbHRUZXh0JywgbWV0aG9kLCBhbHQpKSB7XG4gICAgcmV0dXJuIG1ha2VTdWdnZXN0aW9uKCdBbHRUZXh0JywgZWxlbWVudCwgYWx0LCB7XG4gICAgICB2YXJpYW50XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgdGl0bGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndGl0bGUnKTtcbiAgaWYgKGNhblN1Z2dlc3QoJ1RpdGxlJywgbWV0aG9kLCB0aXRsZSkpIHtcbiAgICByZXR1cm4gbWFrZVN1Z2dlc3Rpb24oJ1RpdGxlJywgZWxlbWVudCwgdGl0bGUsIHtcbiAgICAgIHZhcmlhbnRcbiAgICB9KTtcbiAgfVxuICBjb25zdCB0ZXN0SWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShnZXRDb25maWcoKS50ZXN0SWRBdHRyaWJ1dGUpO1xuICBpZiAoY2FuU3VnZ2VzdCgnVGVzdElkJywgbWV0aG9kLCB0ZXN0SWQpKSB7XG4gICAgcmV0dXJuIG1ha2VTdWdnZXN0aW9uKCdUZXN0SWQnLCBlbGVtZW50LCB0ZXN0SWQsIHtcbiAgICAgIHZhcmlhbnRcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vLyBUaGlzIGlzIHNvIHRoZSBzdGFjayB0cmFjZSB0aGUgZGV2ZWxvcGVyIHNlZXMgaXMgb25lIHRoYXQnc1xuLy8gY2xvc2VyIHRvIHRoZWlyIGNvZGUgKGJlY2F1c2UgYXN5bmMgc3RhY2sgdHJhY2VzIGFyZSBoYXJkIHRvIGZvbGxvdykuXG5mdW5jdGlvbiBjb3B5U3RhY2tUcmFjZSh0YXJnZXQsIHNvdXJjZSkge1xuICB0YXJnZXQuc3RhY2sgPSBzb3VyY2Uuc3RhY2sucmVwbGFjZShzb3VyY2UubWVzc2FnZSwgdGFyZ2V0Lm1lc3NhZ2UpO1xufVxuZnVuY3Rpb24gd2FpdEZvcihjYWxsYmFjaywgX3JlZikge1xuICBsZXQge1xuICAgIGNvbnRhaW5lciA9IGdldERvY3VtZW50KCksXG4gICAgdGltZW91dCA9IGdldENvbmZpZygpLmFzeW5jVXRpbFRpbWVvdXQsXG4gICAgc2hvd09yaWdpbmFsU3RhY2tUcmFjZSA9IGdldENvbmZpZygpLnNob3dPcmlnaW5hbFN0YWNrVHJhY2UsXG4gICAgc3RhY2tUcmFjZUVycm9yLFxuICAgIGludGVydmFsID0gNTAsXG4gICAgb25UaW1lb3V0ID0gZXJyb3IgPT4ge1xuICAgICAgZXJyb3IubWVzc2FnZSA9IGdldENvbmZpZygpLmdldEVsZW1lbnRFcnJvcihlcnJvci5tZXNzYWdlLCBjb250YWluZXIpLm1lc3NhZ2U7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfSxcbiAgICBtdXRhdGlvbk9ic2VydmVyT3B0aW9ucyA9IHtcbiAgICAgIHN1YnRyZWU6IHRydWUsXG4gICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICAgIH1cbiAgfSA9IF9yZWY7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWNlaXZlZCBgY2FsbGJhY2tgIGFyZyBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGxldCBsYXN0RXJyb3IsIGludGVydmFsSWQsIG9ic2VydmVyO1xuICAgIGxldCBmaW5pc2hlZCA9IGZhbHNlO1xuICAgIGxldCBwcm9taXNlU3RhdHVzID0gJ2lkbGUnO1xuICAgIGNvbnN0IG92ZXJhbGxUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIHRpbWVvdXQpO1xuICAgIGNvbnN0IHVzaW5nSmVzdEZha2VUaW1lcnMgPSBqZXN0RmFrZVRpbWVyc0FyZUVuYWJsZWQoKTtcbiAgICBpZiAodXNpbmdKZXN0RmFrZVRpbWVycykge1xuICAgICAgY29uc3Qge1xuICAgICAgICB1bnN0YWJsZV9hZHZhbmNlVGltZXJzV3JhcHBlcjogYWR2YW5jZVRpbWVyc1dyYXBwZXJcbiAgICAgIH0gPSBnZXRDb25maWcoKTtcbiAgICAgIGNoZWNrQ2FsbGJhY2soKTtcbiAgICAgIC8vIHRoaXMgaXMgYSBkYW5nZXJvdXMgcnVsZSB0byBkaXNhYmxlIGJlY2F1c2UgaXQgY291bGQgbGVhZCB0byBhblxuICAgICAgLy8gaW5maW5pdGUgbG9vcC4gSG93ZXZlciwgZXNsaW50IGlzbid0IHNtYXJ0IGVub3VnaCB0byBrbm93IHRoYXQgd2UncmVcbiAgICAgIC8vIHNldHRpbmcgZmluaXNoZWQgaW5zaWRlIGBvbkRvbmVgIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdoZW4gd2UncmUgZG9uZVxuICAgICAgLy8gd2FpdGluZyBvciB3aGVuIHdlJ3ZlIHRpbWVkIG91dC5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bm1vZGlmaWVkLWxvb3AtY29uZGl0aW9uXG4gICAgICB3aGlsZSAoIWZpbmlzaGVkKSB7XG4gICAgICAgIGlmICghamVzdEZha2VUaW1lcnNBcmVFbmFibGVkKCkpIHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcIkNoYW5nZWQgZnJvbSB1c2luZyBmYWtlIHRpbWVycyB0byByZWFsIHRpbWVycyB3aGlsZSB1c2luZyB3YWl0Rm9yLiBUaGlzIGlzIG5vdCBhbGxvd2VkIGFuZCB3aWxsIHJlc3VsdCBpbiB2ZXJ5IHN0cmFuZ2UgYmVoYXZpb3IuIFBsZWFzZSBlbnN1cmUgeW91J3JlIGF3YWl0aW5nIGFsbCBhc3luYyB0aGluZ3MgeW91ciB0ZXN0IGlzIGRvaW5nIGJlZm9yZSBjaGFuZ2luZyB0byByZWFsIHRpbWVycy4gRm9yIG1vcmUgaW5mbywgcGxlYXNlIGdvIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS90ZXN0aW5nLWxpYnJhcnkvZG9tLXRlc3RpbmctbGlicmFyeS9pc3N1ZXMvODMwXCIpO1xuICAgICAgICAgIGlmICghc2hvd09yaWdpbmFsU3RhY2tUcmFjZSkgY29weVN0YWNrVHJhY2UoZXJyb3IsIHN0YWNrVHJhY2VFcnJvcik7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbiB0aGlzIHJhcmUgY2FzZSwgd2UgKm5lZWQqIHRvIHdhaXQgZm9yIGluLWZsaWdodCBwcm9taXNlc1xuICAgICAgICAvLyB0byByZXNvbHZlIGJlZm9yZSBjb250aW51aW5nLiBXZSBkb24ndCBuZWVkIHRvIHRha2UgYWR2YW50YWdlXG4gICAgICAgIC8vIG9mIHBhcmFsbGVsaXphdGlvbiBzbyB3ZSdyZSBmaW5lLlxuICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTkyNDM1ODYvOTcxNTkyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG4gICAgICAgIGF3YWl0IGFkdmFuY2VUaW1lcnNXcmFwcGVyKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAvLyB3ZSAqY291bGQqIChtYXliZSBzaG91bGQ/KSB1c2UgYGFkdmFuY2VUaW1lcnNUb05leHRUaW1lcmAgYnV0IGl0J3NcbiAgICAgICAgICAvLyBwb3NzaWJsZSB0aGF0IGNvdWxkIG1ha2UgdGhpcyBsb29wIGdvIG9uIGZvcmV2ZXIgaWYgc29tZW9uZSBpcyB1c2luZ1xuICAgICAgICAgIC8vIHRoaXJkIHBhcnR5IGNvZGUgdGhhdCdzIHNldHRpbmcgdXAgcmVjdXJzaXZlIHRpbWVycyBzbyByYXBpZGx5IHRoYXRcbiAgICAgICAgICAvLyB0aGUgdXNlcidzIHRpbWVyJ3MgZG9uJ3QgZ2V0IGEgY2hhbmNlIHRvIHJlc29sdmUuIFNvIHdlJ2xsIGFkdmFuY2VcbiAgICAgICAgICAvLyBieSBhbiBpbnRlcnZhbCBpbnN0ZWFkLiAoV2UgaGF2ZSBhIHRlc3QgZm9yIHRoaXMgY2FzZSkuXG4gICAgICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKGludGVydmFsKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gSXQncyByZWFsbHkgaW1wb3J0YW50IHRoYXQgY2hlY2tDYWxsYmFjayBpcyBydW4gKmJlZm9yZSogd2UgZmx1c2hcbiAgICAgICAgLy8gaW4tZmxpZ2h0IHByb21pc2VzLiBUbyBiZSBob25lc3QsIEknbSBub3Qgc3VyZSB3aHksIGFuZCBJIGNhbid0IHF1aXRlXG4gICAgICAgIC8vIHRoaW5rIG9mIGEgd2F5IHRvIHJlcHJvZHVjZSB0aGUgcHJvYmxlbSBpbiBhIHRlc3QsIGJ1dCBJIHNwZW50XG4gICAgICAgIC8vIGFuIGVudGlyZSBkYXkgYmFuZ2luZyBteSBoZWFkIGFnYWluc3QgYSB3YWxsIG9uIHRoaXMuXG4gICAgICAgIGNoZWNrQ2FsbGJhY2soKTtcbiAgICAgICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2hlY2tDb250YWluZXJUeXBlKGNvbnRhaW5lcik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKGNoZWNrUmVhbFRpbWVyc0NhbGxiYWNrLCBpbnRlcnZhbCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIE11dGF0aW9uT2JzZXJ2ZXJcbiAgICAgIH0gPSBnZXRXaW5kb3dGcm9tTm9kZShjb250YWluZXIpO1xuICAgICAgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihjaGVja1JlYWxUaW1lcnNDYWxsYmFjayk7XG4gICAgICBvYnNlcnZlci5vYnNlcnZlKGNvbnRhaW5lciwgbXV0YXRpb25PYnNlcnZlck9wdGlvbnMpO1xuICAgICAgY2hlY2tDYWxsYmFjaygpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkRvbmUoZXJyb3IsIHJlc3VsdCkge1xuICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgY2xlYXJUaW1lb3V0KG92ZXJhbGxUaW1lb3V0VGltZXIpO1xuICAgICAgaWYgKCF1c2luZ0plc3RGYWtlVGltZXJzKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1JlYWxUaW1lcnNDYWxsYmFjaygpIHtcbiAgICAgIGlmIChqZXN0RmFrZVRpbWVyc0FyZUVuYWJsZWQoKSkge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcIkNoYW5nZWQgZnJvbSB1c2luZyByZWFsIHRpbWVycyB0byBmYWtlIHRpbWVycyB3aGlsZSB1c2luZyB3YWl0Rm9yLiBUaGlzIGlzIG5vdCBhbGxvd2VkIGFuZCB3aWxsIHJlc3VsdCBpbiB2ZXJ5IHN0cmFuZ2UgYmVoYXZpb3IuIFBsZWFzZSBlbnN1cmUgeW91J3JlIGF3YWl0aW5nIGFsbCBhc3luYyB0aGluZ3MgeW91ciB0ZXN0IGlzIGRvaW5nIGJlZm9yZSBjaGFuZ2luZyB0byBmYWtlIHRpbWVycy4gRm9yIG1vcmUgaW5mbywgcGxlYXNlIGdvIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS90ZXN0aW5nLWxpYnJhcnkvZG9tLXRlc3RpbmctbGlicmFyeS9pc3N1ZXMvODMwXCIpO1xuICAgICAgICBpZiAoIXNob3dPcmlnaW5hbFN0YWNrVHJhY2UpIGNvcHlTdGFja1RyYWNlKGVycm9yLCBzdGFja1RyYWNlRXJyb3IpO1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjaGVja0NhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrQ2FsbGJhY2soKSB7XG4gICAgICBpZiAocHJvbWlzZVN0YXR1cyA9PT0gJ3BlbmRpbmcnKSByZXR1cm47XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBydW5XaXRoRXhwZW5zaXZlRXJyb3JEaWFnbm9zdGljc0Rpc2FibGVkKGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKHR5cGVvZiAocmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiByZXN1bHQudGhlbikgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBwcm9taXNlU3RhdHVzID0gJ3BlbmRpbmcnO1xuICAgICAgICAgIHJlc3VsdC50aGVuKHJlc29sdmVkVmFsdWUgPT4ge1xuICAgICAgICAgICAgcHJvbWlzZVN0YXR1cyA9ICdyZXNvbHZlZCc7XG4gICAgICAgICAgICBvbkRvbmUobnVsbCwgcmVzb2x2ZWRWYWx1ZSk7XG4gICAgICAgICAgfSwgcmVqZWN0ZWRWYWx1ZSA9PiB7XG4gICAgICAgICAgICBwcm9taXNlU3RhdHVzID0gJ3JlamVjdGVkJztcbiAgICAgICAgICAgIGxhc3RFcnJvciA9IHJlamVjdGVkVmFsdWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25Eb25lKG51bGwsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYGNhbGxiYWNrYCB0aHJvd3MsIHdhaXQgZm9yIHRoZSBuZXh0IG11dGF0aW9uLCBpbnRlcnZhbCwgb3IgdGltZW91dC5cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIFNhdmUgdGhlIG1vc3QgcmVjZW50IGNhbGxiYWNrIGVycm9yIHRvIHJlamVjdCB0aGUgcHJvbWlzZSB3aXRoIGl0IGluIHRoZSBldmVudCBvZiBhIHRpbWVvdXRcbiAgICAgICAgbGFzdEVycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7XG4gICAgICBsZXQgZXJyb3I7XG4gICAgICBpZiAobGFzdEVycm9yKSB7XG4gICAgICAgIGVycm9yID0gbGFzdEVycm9yO1xuICAgICAgICBpZiAoIXNob3dPcmlnaW5hbFN0YWNrVHJhY2UgJiYgZXJyb3IubmFtZSA9PT0gJ1Rlc3RpbmdMaWJyYXJ5RWxlbWVudEVycm9yJykge1xuICAgICAgICAgIGNvcHlTdGFja1RyYWNlKGVycm9yLCBzdGFja1RyYWNlRXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignVGltZWQgb3V0IGluIHdhaXRGb3IuJyk7XG4gICAgICAgIGlmICghc2hvd09yaWdpbmFsU3RhY2tUcmFjZSkge1xuICAgICAgICAgIGNvcHlTdGFja1RyYWNlKGVycm9yLCBzdGFja1RyYWNlRXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvbkRvbmUob25UaW1lb3V0KGVycm9yKSwgbnVsbCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHdhaXRGb3JXcmFwcGVyKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIC8vIGNyZWF0ZSB0aGUgZXJyb3IgaGVyZSBzbyBpdHMgc3RhY2sgdHJhY2UgaXMgYXMgY2xvc2UgdG8gdGhlXG4gIC8vIGNhbGxpbmcgY29kZSBhcyBwb3NzaWJsZVxuICBjb25zdCBzdGFja1RyYWNlRXJyb3IgPSBuZXcgRXJyb3IoJ1NUQUNLX1RSQUNFX01FU1NBR0UnKTtcbiAgcmV0dXJuIGdldENvbmZpZygpLmFzeW5jV3JhcHBlcigoKSA9PiB3YWl0Rm9yKGNhbGxiYWNrLCB7XG4gICAgc3RhY2tUcmFjZUVycm9yLFxuICAgIC4uLm9wdGlvbnNcbiAgfSkpO1xufVxuXG4vKlxuZXNsaW50XG4gIG1heC1saW5lcy1wZXItZnVuY3Rpb246IFtcImVycm9yXCIsIHtcIm1heFwiOiAyMDB9XSxcbiovXG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRFcnJvcihtZXNzYWdlLCBjb250YWluZXIpIHtcbiAgcmV0dXJuIGdldENvbmZpZygpLmdldEVsZW1lbnRFcnJvcihtZXNzYWdlLCBjb250YWluZXIpO1xufVxuZnVuY3Rpb24gZ2V0TXVsdGlwbGVFbGVtZW50c0ZvdW5kRXJyb3IobWVzc2FnZSwgY29udGFpbmVyKSB7XG4gIHJldHVybiBnZXRFbGVtZW50RXJyb3IobWVzc2FnZSArIFwiXFxuXFxuKElmIHRoaXMgaXMgaW50ZW50aW9uYWwsIHRoZW4gdXNlIHRoZSBgKkFsbEJ5KmAgdmFyaWFudCBvZiB0aGUgcXVlcnkgKGxpa2UgYHF1ZXJ5QWxsQnlUZXh0YCwgYGdldEFsbEJ5VGV4dGAsIG9yIGBmaW5kQWxsQnlUZXh0YCkpLlwiLCBjb250YWluZXIpO1xufVxuZnVuY3Rpb24gcXVlcnlBbGxCeUF0dHJpYnV0ZShhdHRyaWJ1dGUsIGNvbnRhaW5lciwgdGV4dCwgX3RlbXApIHtcbiAgbGV0IHtcbiAgICBleGFjdCA9IHRydWUsXG4gICAgY29sbGFwc2VXaGl0ZXNwYWNlLFxuICAgIHRyaW0sXG4gICAgbm9ybWFsaXplclxuICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gIGNvbnN0IG1hdGNoZXIgPSBleGFjdCA/IG1hdGNoZXMgOiBmdXp6eU1hdGNoZXM7XG4gIGNvbnN0IG1hdGNoTm9ybWFsaXplciA9IG1ha2VOb3JtYWxpemVyKHtcbiAgICBjb2xsYXBzZVdoaXRlc3BhY2UsXG4gICAgdHJpbSxcbiAgICBub3JtYWxpemVyXG4gIH0pO1xuICByZXR1cm4gQXJyYXkuZnJvbShjb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIltcIiArIGF0dHJpYnV0ZSArIFwiXVwiKSkuZmlsdGVyKG5vZGUgPT4gbWF0Y2hlcihub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpLCBub2RlLCB0ZXh0LCBtYXRjaE5vcm1hbGl6ZXIpKTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5QnlBdHRyaWJ1dGUoYXR0cmlidXRlLCBjb250YWluZXIsIHRleHQsIG9wdGlvbnMpIHtcbiAgY29uc3QgZWxzID0gcXVlcnlBbGxCeUF0dHJpYnV0ZShhdHRyaWJ1dGUsIGNvbnRhaW5lciwgdGV4dCwgb3B0aW9ucyk7XG4gIGlmIChlbHMubGVuZ3RoID4gMSkge1xuICAgIHRocm93IGdldE11bHRpcGxlRWxlbWVudHNGb3VuZEVycm9yKFwiRm91bmQgbXVsdGlwbGUgZWxlbWVudHMgYnkgW1wiICsgYXR0cmlidXRlICsgXCI9XCIgKyB0ZXh0ICsgXCJdXCIsIGNvbnRhaW5lcik7XG4gIH1cbiAgcmV0dXJuIGVsc1swXSB8fCBudWxsO1xufVxuXG4vLyB0aGlzIGFjY2VwdHMgYSBxdWVyeSBmdW5jdGlvbiBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIHRocm93cyBhbiBlcnJvclxuLy8gaWYgbW9yZSB0aGFuIG9uZSBlbGVtZW50cyBpcyByZXR1cm5lZCwgb3RoZXJ3aXNlIGl0IHJldHVybnMgdGhlIGZpcnN0XG4vLyBlbGVtZW50IG9yIG51bGxcbmZ1bmN0aW9uIG1ha2VTaW5nbGVRdWVyeShhbGxRdWVyeSwgZ2V0TXVsdGlwbGVFcnJvcikge1xuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBjb25zdCBlbHMgPSBhbGxRdWVyeShjb250YWluZXIsIC4uLmFyZ3MpO1xuICAgIGlmIChlbHMubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3QgZWxlbWVudFN0cmluZ3MgPSBlbHMubWFwKGVsZW1lbnQgPT4gZ2V0RWxlbWVudEVycm9yKG51bGwsIGVsZW1lbnQpLm1lc3NhZ2UpLmpvaW4oJ1xcblxcbicpO1xuICAgICAgdGhyb3cgZ2V0TXVsdGlwbGVFbGVtZW50c0ZvdW5kRXJyb3IoZ2V0TXVsdGlwbGVFcnJvcihjb250YWluZXIsIC4uLmFyZ3MpICsgXCJcXG5cXG5IZXJlIGFyZSB0aGUgbWF0Y2hpbmcgZWxlbWVudHM6XFxuXFxuXCIgKyBlbGVtZW50U3RyaW5ncywgY29udGFpbmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsc1swXSB8fCBudWxsO1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0U3VnZ2VzdGlvbkVycm9yKHN1Z2dlc3Rpb24sIGNvbnRhaW5lcikge1xuICByZXR1cm4gZ2V0Q29uZmlnKCkuZ2V0RWxlbWVudEVycm9yKFwiQSBiZXR0ZXIgcXVlcnkgaXMgYXZhaWxhYmxlLCB0cnkgdGhpczpcXG5cIiArIHN1Z2dlc3Rpb24udG9TdHJpbmcoKSArIFwiXFxuXCIsIGNvbnRhaW5lcik7XG59XG5cbi8vIHRoaXMgYWNjZXB0cyBhIHF1ZXJ5IGZ1bmN0aW9uIGFuZCByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggdGhyb3dzIGFuIGVycm9yXG4vLyBpZiBhbiBlbXB0eSBsaXN0IG9mIGVsZW1lbnRzIGlzIHJldHVybmVkXG5mdW5jdGlvbiBtYWtlR2V0QWxsUXVlcnkoYWxsUXVlcnksIGdldE1pc3NpbmdFcnJvcikge1xuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cbiAgICBjb25zdCBlbHMgPSBhbGxRdWVyeShjb250YWluZXIsIC4uLmFyZ3MpO1xuICAgIGlmICghZWxzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgZ2V0Q29uZmlnKCkuZ2V0RWxlbWVudEVycm9yKGdldE1pc3NpbmdFcnJvcihjb250YWluZXIsIC4uLmFyZ3MpLCBjb250YWluZXIpO1xuICAgIH1cbiAgICByZXR1cm4gZWxzO1xuICB9O1xufVxuXG4vLyB0aGlzIGFjY2VwdHMgYSBnZXR0ZXIgcXVlcnkgZnVuY3Rpb24gYW5kIHJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBjYWxsc1xuLy8gd2FpdEZvciBhbmQgcGFzc2luZyBhIGZ1bmN0aW9uIHdoaWNoIGludm9rZXMgdGhlIGdldHRlci5cbmZ1bmN0aW9uIG1ha2VGaW5kUXVlcnkoZ2V0dGVyKSB7XG4gIHJldHVybiAoY29udGFpbmVyLCB0ZXh0LCBvcHRpb25zLCB3YWl0Rm9yT3B0aW9ucykgPT4ge1xuICAgIHJldHVybiB3YWl0Rm9yV3JhcHBlcigoKSA9PiB7XG4gICAgICByZXR1cm4gZ2V0dGVyKGNvbnRhaW5lciwgdGV4dCwgb3B0aW9ucyk7XG4gICAgfSwge1xuICAgICAgY29udGFpbmVyLFxuICAgICAgLi4ud2FpdEZvck9wdGlvbnNcbiAgICB9KTtcbiAgfTtcbn1cbmNvbnN0IHdyYXBTaW5nbGVRdWVyeVdpdGhTdWdnZXN0aW9uID0gKHF1ZXJ5LCBxdWVyeUFsbEJ5TmFtZSwgdmFyaWFudCkgPT4gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMgPiAxID8gX2xlbjMgLSAxIDogMCksIF9rZXkzID0gMTsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgIGFyZ3NbX2tleTMgLSAxXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gIH1cbiAgY29uc3QgZWxlbWVudCA9IHF1ZXJ5KGNvbnRhaW5lciwgLi4uYXJncyk7XG4gIGNvbnN0IFt7XG4gICAgc3VnZ2VzdCA9IGdldENvbmZpZygpLnRocm93U3VnZ2VzdGlvbnNcbiAgfSA9IHt9XSA9IGFyZ3Muc2xpY2UoLTEpO1xuICBpZiAoZWxlbWVudCAmJiBzdWdnZXN0KSB7XG4gICAgY29uc3Qgc3VnZ2VzdGlvbiA9IGdldFN1Z2dlc3RlZFF1ZXJ5KGVsZW1lbnQsIHZhcmlhbnQpO1xuICAgIGlmIChzdWdnZXN0aW9uICYmICFxdWVyeUFsbEJ5TmFtZS5lbmRzV2l0aChzdWdnZXN0aW9uLnF1ZXJ5TmFtZSkpIHtcbiAgICAgIHRocm93IGdldFN1Z2dlc3Rpb25FcnJvcihzdWdnZXN0aW9uLnRvU3RyaW5nKCksIGNvbnRhaW5lcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbGVtZW50O1xufTtcbmNvbnN0IHdyYXBBbGxCeVF1ZXJ5V2l0aFN1Z2dlc3Rpb24gPSAocXVlcnksIHF1ZXJ5QWxsQnlOYW1lLCB2YXJpYW50KSA9PiBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNCA+IDEgPyBfbGVuNCAtIDEgOiAwKSwgX2tleTQgPSAxOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgYXJnc1tfa2V5NCAtIDFdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgfVxuICBjb25zdCBlbHMgPSBxdWVyeShjb250YWluZXIsIC4uLmFyZ3MpO1xuICBjb25zdCBbe1xuICAgIHN1Z2dlc3QgPSBnZXRDb25maWcoKS50aHJvd1N1Z2dlc3Rpb25zXG4gIH0gPSB7fV0gPSBhcmdzLnNsaWNlKC0xKTtcbiAgaWYgKGVscy5sZW5ndGggJiYgc3VnZ2VzdCkge1xuICAgIC8vIGdldCBhIHVuaXF1ZSBsaXN0IG9mIGFsbCBzdWdnZXN0aW9uIG1lc3NhZ2VzLiAgV2UgYXJlIG9ubHkgZ29pbmcgdG8gbWFrZSBhIHN1Z2dlc3Rpb24gaWZcbiAgICAvLyBhbGwgdGhlIHN1Z2dlc3Rpb25zIGFyZSB0aGUgc2FtZVxuICAgIGNvbnN0IHVuaXF1ZVN1Z2dlc3Rpb25NZXNzYWdlcyA9IFsuLi5uZXcgU2V0KGVscy5tYXAoZWxlbWVudCA9PiB7XG4gICAgICB2YXIgX2dldFN1Z2dlc3RlZFF1ZXJ5O1xuICAgICAgcmV0dXJuIChfZ2V0U3VnZ2VzdGVkUXVlcnkgPSBnZXRTdWdnZXN0ZWRRdWVyeShlbGVtZW50LCB2YXJpYW50KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nZXRTdWdnZXN0ZWRRdWVyeS50b1N0cmluZygpO1xuICAgIH0pKV07XG4gICAgaWYgKFxuICAgIC8vIG9ubHkgd2FudCB0byBzdWdnZXN0IGlmIGFsbCB0aGUgZWxzIGhhdmUgdGhlIHNhbWUgc3VnZ2VzdGlvbi5cbiAgICB1bmlxdWVTdWdnZXN0aW9uTWVzc2FnZXMubGVuZ3RoID09PSAxICYmICFxdWVyeUFsbEJ5TmFtZS5lbmRzV2l0aChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvbiAtLSBUT0RPOiBDYW4gdGhpcyBiZSBudWxsIGF0IHJ1bnRpbWU/XG4gICAgZ2V0U3VnZ2VzdGVkUXVlcnkoZWxzWzBdLCB2YXJpYW50KS5xdWVyeU5hbWUpKSB7XG4gICAgICB0aHJvdyBnZXRTdWdnZXN0aW9uRXJyb3IodW5pcXVlU3VnZ2VzdGlvbk1lc3NhZ2VzWzBdLCBjb250YWluZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWxzO1xufTtcblxuLy8gVE9ETzogVGhpcyBkZXZpYXRlcyBmcm9tIHRoZSBwdWJsaXNoZWQgZGVjbGFyYXRpb25zXG4vLyBIb3dldmVyLCB0aGUgaW1wbGVtZW50YXRpb24gYWx3YXlzIHJlcXVpcmVkIGEgZHlhZGljIChhZnRlciBgY29udGFpbmVyYCkgbm90IHZhcmlhZGljIGBxdWVyeUFsbEJ5YCBjb25zaWRlcmluZyB0aGUgaW1wbGVtZW50YXRpb24gb2YgYG1ha2VGaW5kUXVlcnlgXG4vLyBUaGlzIGlzIGF0IGxlYXN0IHN0YXRpY2FsbHkgdHJ1ZSBhbmQgY2FuIGJlIHZlcmlmaWVkIGJ5IGFjY2VwdGluZyBgUXVlcnlNZXRob2Q8QXJndW1lbnRzLCBIVE1MRWxlbWVudFtdPmBcbmZ1bmN0aW9uIGJ1aWxkUXVlcmllcyhxdWVyeUFsbEJ5LCBnZXRNdWx0aXBsZUVycm9yLCBnZXRNaXNzaW5nRXJyb3IpIHtcbiAgY29uc3QgcXVlcnlCeSA9IHdyYXBTaW5nbGVRdWVyeVdpdGhTdWdnZXN0aW9uKG1ha2VTaW5nbGVRdWVyeShxdWVyeUFsbEJ5LCBnZXRNdWx0aXBsZUVycm9yKSwgcXVlcnlBbGxCeS5uYW1lLCAncXVlcnknKTtcbiAgY29uc3QgZ2V0QWxsQnkgPSBtYWtlR2V0QWxsUXVlcnkocXVlcnlBbGxCeSwgZ2V0TWlzc2luZ0Vycm9yKTtcbiAgY29uc3QgZ2V0QnkgPSBtYWtlU2luZ2xlUXVlcnkoZ2V0QWxsQnksIGdldE11bHRpcGxlRXJyb3IpO1xuICBjb25zdCBnZXRCeVdpdGhTdWdnZXN0aW9ucyA9IHdyYXBTaW5nbGVRdWVyeVdpdGhTdWdnZXN0aW9uKGdldEJ5LCBxdWVyeUFsbEJ5Lm5hbWUsICdnZXQnKTtcbiAgY29uc3QgZ2V0QWxsV2l0aFN1Z2dlc3Rpb25zID0gd3JhcEFsbEJ5UXVlcnlXaXRoU3VnZ2VzdGlvbihnZXRBbGxCeSwgcXVlcnlBbGxCeS5uYW1lLnJlcGxhY2UoJ3F1ZXJ5JywgJ2dldCcpLCAnZ2V0QWxsJyk7XG4gIGNvbnN0IGZpbmRBbGxCeSA9IG1ha2VGaW5kUXVlcnkod3JhcEFsbEJ5UXVlcnlXaXRoU3VnZ2VzdGlvbihnZXRBbGxCeSwgcXVlcnlBbGxCeS5uYW1lLCAnZmluZEFsbCcpKTtcbiAgY29uc3QgZmluZEJ5ID0gbWFrZUZpbmRRdWVyeSh3cmFwU2luZ2xlUXVlcnlXaXRoU3VnZ2VzdGlvbihnZXRCeSwgcXVlcnlBbGxCeS5uYW1lLCAnZmluZCcpKTtcbiAgcmV0dXJuIFtxdWVyeUJ5LCBnZXRBbGxXaXRoU3VnZ2VzdGlvbnMsIGdldEJ5V2l0aFN1Z2dlc3Rpb25zLCBmaW5kQWxsQnksIGZpbmRCeV07XG59XG5cbnZhciBxdWVyeUhlbHBlcnMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZ2V0RWxlbWVudEVycm9yOiBnZXRFbGVtZW50RXJyb3IsXG4gIHdyYXBBbGxCeVF1ZXJ5V2l0aFN1Z2dlc3Rpb246IHdyYXBBbGxCeVF1ZXJ5V2l0aFN1Z2dlc3Rpb24sXG4gIHdyYXBTaW5nbGVRdWVyeVdpdGhTdWdnZXN0aW9uOiB3cmFwU2luZ2xlUXVlcnlXaXRoU3VnZ2VzdGlvbixcbiAgZ2V0TXVsdGlwbGVFbGVtZW50c0ZvdW5kRXJyb3I6IGdldE11bHRpcGxlRWxlbWVudHNGb3VuZEVycm9yLFxuICBxdWVyeUFsbEJ5QXR0cmlidXRlOiBxdWVyeUFsbEJ5QXR0cmlidXRlLFxuICBxdWVyeUJ5QXR0cmlidXRlOiBxdWVyeUJ5QXR0cmlidXRlLFxuICBtYWtlU2luZ2xlUXVlcnk6IG1ha2VTaW5nbGVRdWVyeSxcbiAgbWFrZUdldEFsbFF1ZXJ5OiBtYWtlR2V0QWxsUXVlcnksXG4gIG1ha2VGaW5kUXVlcnk6IG1ha2VGaW5kUXVlcnksXG4gIGJ1aWxkUXVlcmllczogYnVpbGRRdWVyaWVzXG59KTtcblxuZnVuY3Rpb24gcXVlcnlBbGxMYWJlbHMoY29udGFpbmVyKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCdsYWJlbCxpbnB1dCcpKS5tYXAobm9kZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vZGUsXG4gICAgICB0ZXh0VG9NYXRjaDogZ2V0TGFiZWxDb250ZW50KG5vZGUpXG4gICAgfTtcbiAgfSkuZmlsdGVyKF9yZWYgPT4ge1xuICAgIGxldCB7XG4gICAgICB0ZXh0VG9NYXRjaFxuICAgIH0gPSBfcmVmO1xuICAgIHJldHVybiB0ZXh0VG9NYXRjaCAhPT0gbnVsbDtcbiAgfSk7XG59XG5jb25zdCBxdWVyeUFsbExhYmVsc0J5VGV4dCA9IGZ1bmN0aW9uIChjb250YWluZXIsIHRleHQsIF90ZW1wKSB7XG4gIGxldCB7XG4gICAgZXhhY3QgPSB0cnVlLFxuICAgIHRyaW0sXG4gICAgY29sbGFwc2VXaGl0ZXNwYWNlLFxuICAgIG5vcm1hbGl6ZXJcbiAgfSA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wO1xuICBjb25zdCBtYXRjaGVyID0gZXhhY3QgPyBtYXRjaGVzIDogZnV6enlNYXRjaGVzO1xuICBjb25zdCBtYXRjaE5vcm1hbGl6ZXIgPSBtYWtlTm9ybWFsaXplcih7XG4gICAgY29sbGFwc2VXaGl0ZXNwYWNlLFxuICAgIHRyaW0sXG4gICAgbm9ybWFsaXplclxuICB9KTtcbiAgY29uc3QgdGV4dFRvTWF0Y2hCeUxhYmVscyA9IHF1ZXJ5QWxsTGFiZWxzKGNvbnRhaW5lcik7XG4gIHJldHVybiB0ZXh0VG9NYXRjaEJ5TGFiZWxzLmZpbHRlcihfcmVmMiA9PiB7XG4gICAgbGV0IHtcbiAgICAgIG5vZGUsXG4gICAgICB0ZXh0VG9NYXRjaFxuICAgIH0gPSBfcmVmMjtcbiAgICByZXR1cm4gbWF0Y2hlcih0ZXh0VG9NYXRjaCwgbm9kZSwgdGV4dCwgbWF0Y2hOb3JtYWxpemVyKTtcbiAgfSkubWFwKF9yZWYzID0+IHtcbiAgICBsZXQge1xuICAgICAgbm9kZVxuICAgIH0gPSBfcmVmMztcbiAgICByZXR1cm4gbm9kZTtcbiAgfSk7XG59O1xuY29uc3QgcXVlcnlBbGxCeUxhYmVsVGV4dCA9IGZ1bmN0aW9uIChjb250YWluZXIsIHRleHQsIF90ZW1wMikge1xuICBsZXQge1xuICAgIHNlbGVjdG9yID0gJyonLFxuICAgIGV4YWN0ID0gdHJ1ZSxcbiAgICBjb2xsYXBzZVdoaXRlc3BhY2UsXG4gICAgdHJpbSxcbiAgICBub3JtYWxpemVyXG4gIH0gPSBfdGVtcDIgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAyO1xuICBjaGVja0NvbnRhaW5lclR5cGUoY29udGFpbmVyKTtcbiAgY29uc3QgbWF0Y2hlciA9IGV4YWN0ID8gbWF0Y2hlcyA6IGZ1enp5TWF0Y2hlcztcbiAgY29uc3QgbWF0Y2hOb3JtYWxpemVyID0gbWFrZU5vcm1hbGl6ZXIoe1xuICAgIGNvbGxhcHNlV2hpdGVzcGFjZSxcbiAgICB0cmltLFxuICAgIG5vcm1hbGl6ZXJcbiAgfSk7XG4gIGNvbnN0IG1hdGNoaW5nTGFiZWxsZWRFbGVtZW50cyA9IEFycmF5LmZyb20oY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJyonKSkuZmlsdGVyKGVsZW1lbnQgPT4ge1xuICAgIHJldHVybiBnZXRSZWFsTGFiZWxzKGVsZW1lbnQpLmxlbmd0aCB8fCBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnYXJpYS1sYWJlbGxlZGJ5Jyk7XG4gIH0pLnJlZHVjZSgobGFiZWxsZWRFbGVtZW50cywgbGFiZWxsZWRFbGVtZW50KSA9PiB7XG4gICAgY29uc3QgbGFiZWxMaXN0ID0gZ2V0TGFiZWxzKGNvbnRhaW5lciwgbGFiZWxsZWRFbGVtZW50LCB7XG4gICAgICBzZWxlY3RvclxuICAgIH0pO1xuICAgIGxhYmVsTGlzdC5maWx0ZXIobGFiZWwgPT4gQm9vbGVhbihsYWJlbC5mb3JtQ29udHJvbCkpLmZvckVhY2gobGFiZWwgPT4ge1xuICAgICAgaWYgKG1hdGNoZXIobGFiZWwuY29udGVudCwgbGFiZWwuZm9ybUNvbnRyb2wsIHRleHQsIG1hdGNoTm9ybWFsaXplcikgJiYgbGFiZWwuZm9ybUNvbnRyb2wpIHtcbiAgICAgICAgbGFiZWxsZWRFbGVtZW50cy5wdXNoKGxhYmVsLmZvcm1Db250cm9sKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBsYWJlbHNWYWx1ZSA9IGxhYmVsTGlzdC5maWx0ZXIobGFiZWwgPT4gQm9vbGVhbihsYWJlbC5jb250ZW50KSkubWFwKGxhYmVsID0+IGxhYmVsLmNvbnRlbnQpO1xuICAgIGlmIChtYXRjaGVyKGxhYmVsc1ZhbHVlLmpvaW4oJyAnKSwgbGFiZWxsZWRFbGVtZW50LCB0ZXh0LCBtYXRjaE5vcm1hbGl6ZXIpKSB7XG4gICAgICBsYWJlbGxlZEVsZW1lbnRzLnB1c2gobGFiZWxsZWRFbGVtZW50KTtcbiAgICB9XG4gICAgaWYgKGxhYmVsc1ZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgIGxhYmVsc1ZhbHVlLmZvckVhY2goKGxhYmVsVmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChtYXRjaGVyKGxhYmVsVmFsdWUsIGxhYmVsbGVkRWxlbWVudCwgdGV4dCwgbWF0Y2hOb3JtYWxpemVyKSkge1xuICAgICAgICAgIGxhYmVsbGVkRWxlbWVudHMucHVzaChsYWJlbGxlZEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhYmVsc0ZpbHRlcmVkID0gWy4uLmxhYmVsc1ZhbHVlXTtcbiAgICAgICAgbGFiZWxzRmlsdGVyZWQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaWYgKGxhYmVsc0ZpbHRlcmVkLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBpZiAobWF0Y2hlcihsYWJlbHNGaWx0ZXJlZC5qb2luKCcgJyksIGxhYmVsbGVkRWxlbWVudCwgdGV4dCwgbWF0Y2hOb3JtYWxpemVyKSkge1xuICAgICAgICAgICAgbGFiZWxsZWRFbGVtZW50cy5wdXNoKGxhYmVsbGVkRWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGxhYmVsbGVkRWxlbWVudHM7XG4gIH0sIFtdKS5jb25jYXQocXVlcnlBbGxCeUF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIGNvbnRhaW5lciwgdGV4dCwge1xuICAgIGV4YWN0LFxuICAgIG5vcm1hbGl6ZXI6IG1hdGNoTm9ybWFsaXplclxuICB9KSk7XG4gIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQobWF0Y2hpbmdMYWJlbGxlZEVsZW1lbnRzKSkuZmlsdGVyKGVsZW1lbnQgPT4gZWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKSk7XG59O1xuXG4vLyB0aGUgZ2V0QWxsKiBxdWVyeSB3b3VsZCBub3JtYWxseSBsb29rIGxpa2UgdGhpczpcbi8vIGNvbnN0IGdldEFsbEJ5TGFiZWxUZXh0ID0gbWFrZUdldEFsbFF1ZXJ5KFxuLy8gICBxdWVyeUFsbEJ5TGFiZWxUZXh0LFxuLy8gICAoYywgdGV4dCkgPT4gYFVuYWJsZSB0byBmaW5kIGEgbGFiZWwgd2l0aCB0aGUgdGV4dCBvZjogJHt0ZXh0fWAsXG4vLyApXG4vLyBob3dldmVyLCB3ZSBjYW4gZ2l2ZSBhIG1vcmUgaGVscGZ1bCBlcnJvciBtZXNzYWdlIHRoYW4gdGhlIGdlbmVyaWMgb25lLFxuLy8gc28gd2UncmUgd3JpdGluZyB0aGlzIG9uZSBvdXQgYnkgaGFuZC5cbmNvbnN0IGdldEFsbEJ5TGFiZWxUZXh0ID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgdGV4dCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgcmVzdFtfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgY29uc3QgZWxzID0gcXVlcnlBbGxCeUxhYmVsVGV4dChjb250YWluZXIsIHRleHQsIC4uLnJlc3QpO1xuICBpZiAoIWVscy5sZW5ndGgpIHtcbiAgICBjb25zdCBsYWJlbHMgPSBxdWVyeUFsbExhYmVsc0J5VGV4dChjb250YWluZXIsIHRleHQsIC4uLnJlc3QpO1xuICAgIGlmIChsYWJlbHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB0YWdOYW1lcyA9IGxhYmVscy5tYXAobGFiZWwgPT4gZ2V0VGFnTmFtZU9mRWxlbWVudEFzc29jaWF0ZWRXaXRoTGFiZWxWaWFGb3IoY29udGFpbmVyLCBsYWJlbCkpLmZpbHRlcih0YWdOYW1lID0+ICEhdGFnTmFtZSk7XG4gICAgICBpZiAodGFnTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IGdldENvbmZpZygpLmdldEVsZW1lbnRFcnJvcih0YWdOYW1lcy5tYXAodGFnTmFtZSA9PiBcIkZvdW5kIGEgbGFiZWwgd2l0aCB0aGUgdGV4dCBvZjogXCIgKyB0ZXh0ICsgXCIsIGhvd2V2ZXIgdGhlIGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbGFiZWwgKDxcIiArIHRhZ05hbWUgKyBcIiAvPikgaXMgbm9uLWxhYmVsbGFibGUgW2h0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGFiZWxdLiBJZiB5b3UgcmVhbGx5IG5lZWQgdG8gbGFiZWwgYSA8XCIgKyB0YWdOYW1lICsgXCIgLz4sIHlvdSBjYW4gdXNlIGFyaWEtbGFiZWwgb3IgYXJpYS1sYWJlbGxlZGJ5IGluc3RlYWQuXCIpLmpvaW4oJ1xcblxcbicpLCBjb250YWluZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZ2V0Q29uZmlnKCkuZ2V0RWxlbWVudEVycm9yKFwiRm91bmQgYSBsYWJlbCB3aXRoIHRoZSB0ZXh0IG9mOiBcIiArIHRleHQgKyBcIiwgaG93ZXZlciBubyBmb3JtIGNvbnRyb2wgd2FzIGZvdW5kIGFzc29jaWF0ZWQgdG8gdGhhdCBsYWJlbC4gTWFrZSBzdXJlIHlvdSdyZSB1c2luZyB0aGUgXFxcImZvclxcXCIgYXR0cmlidXRlIG9yIFxcXCJhcmlhLWxhYmVsbGVkYnlcXFwiIGF0dHJpYnV0ZSBjb3JyZWN0bHkuXCIsIGNvbnRhaW5lcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGdldENvbmZpZygpLmdldEVsZW1lbnRFcnJvcihcIlVuYWJsZSB0byBmaW5kIGEgbGFiZWwgd2l0aCB0aGUgdGV4dCBvZjogXCIgKyB0ZXh0LCBjb250YWluZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWxzO1xufTtcbmZ1bmN0aW9uIGdldFRhZ05hbWVPZkVsZW1lbnRBc3NvY2lhdGVkV2l0aExhYmVsVmlhRm9yKGNvbnRhaW5lciwgbGFiZWwpIHtcbiAgY29uc3QgaHRtbEZvciA9IGxhYmVsLmdldEF0dHJpYnV0ZSgnZm9yJyk7XG4gIGlmICghaHRtbEZvcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGVsZW1lbnQgPSBjb250YWluZXIucXVlcnlTZWxlY3RvcihcIltpZD1cXFwiXCIgKyBodG1sRm9yICsgXCJcXFwiXVwiKTtcbiAgcmV0dXJuIGVsZW1lbnQgPyBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA6IG51bGw7XG59XG5cbi8vIHRoZSByZWFzb24gbWVudGlvbmVkIGFib3ZlIGlzIHRoZSBzYW1lIHJlYXNvbiB3ZSdyZSBub3QgdXNpbmcgYnVpbGRRdWVyaWVzXG5jb25zdCBnZXRNdWx0aXBsZUVycm9yJDcgPSAoYywgdGV4dCkgPT4gXCJGb3VuZCBtdWx0aXBsZSBlbGVtZW50cyB3aXRoIHRoZSB0ZXh0IG9mOiBcIiArIHRleHQ7XG5jb25zdCBxdWVyeUJ5TGFiZWxUZXh0ID0gd3JhcFNpbmdsZVF1ZXJ5V2l0aFN1Z2dlc3Rpb24obWFrZVNpbmdsZVF1ZXJ5KHF1ZXJ5QWxsQnlMYWJlbFRleHQsIGdldE11bHRpcGxlRXJyb3IkNyksIHF1ZXJ5QWxsQnlMYWJlbFRleHQubmFtZSwgJ3F1ZXJ5Jyk7XG5jb25zdCBnZXRCeUxhYmVsVGV4dCA9IG1ha2VTaW5nbGVRdWVyeShnZXRBbGxCeUxhYmVsVGV4dCwgZ2V0TXVsdGlwbGVFcnJvciQ3KTtcbmNvbnN0IGZpbmRBbGxCeUxhYmVsVGV4dCA9IG1ha2VGaW5kUXVlcnkod3JhcEFsbEJ5UXVlcnlXaXRoU3VnZ2VzdGlvbihnZXRBbGxCeUxhYmVsVGV4dCwgZ2V0QWxsQnlMYWJlbFRleHQubmFtZSwgJ2ZpbmRBbGwnKSk7XG5jb25zdCBmaW5kQnlMYWJlbFRleHQgPSBtYWtlRmluZFF1ZXJ5KHdyYXBTaW5nbGVRdWVyeVdpdGhTdWdnZXN0aW9uKGdldEJ5TGFiZWxUZXh0LCBnZXRBbGxCeUxhYmVsVGV4dC5uYW1lLCAnZmluZCcpKTtcbmNvbnN0IGdldEFsbEJ5TGFiZWxUZXh0V2l0aFN1Z2dlc3Rpb25zID0gd3JhcEFsbEJ5UXVlcnlXaXRoU3VnZ2VzdGlvbihnZXRBbGxCeUxhYmVsVGV4dCwgZ2V0QWxsQnlMYWJlbFRleHQubmFtZSwgJ2dldEFsbCcpO1xuY29uc3QgZ2V0QnlMYWJlbFRleHRXaXRoU3VnZ2VzdGlvbnMgPSB3cmFwU2luZ2xlUXVlcnlXaXRoU3VnZ2VzdGlvbihnZXRCeUxhYmVsVGV4dCwgZ2V0QWxsQnlMYWJlbFRleHQubmFtZSwgJ2dldCcpO1xuY29uc3QgcXVlcnlBbGxCeUxhYmVsVGV4dFdpdGhTdWdnZXN0aW9ucyA9IHdyYXBBbGxCeVF1ZXJ5V2l0aFN1Z2dlc3Rpb24ocXVlcnlBbGxCeUxhYmVsVGV4dCwgcXVlcnlBbGxCeUxhYmVsVGV4dC5uYW1lLCAncXVlcnlBbGwnKTtcblxuY29uc3QgcXVlcnlBbGxCeVBsYWNlaG9sZGVyVGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICBjaGVja0NvbnRhaW5lclR5cGUoYXJnc1swXSk7XG4gIHJldHVybiBxdWVyeUFsbEJ5QXR0cmlidXRlKCdwbGFjZWhvbGRlcicsIC4uLmFyZ3MpO1xufTtcbmNvbnN0IGdldE11bHRpcGxlRXJyb3IkNiA9IChjLCB0ZXh0KSA9PiBcIkZvdW5kIG11bHRpcGxlIGVsZW1lbnRzIHdpdGggdGhlIHBsYWNlaG9sZGVyIHRleHQgb2Y6IFwiICsgdGV4dDtcbmNvbnN0IGdldE1pc3NpbmdFcnJvciQ2ID0gKGMsIHRleHQpID0+IFwiVW5hYmxlIHRvIGZpbmQgYW4gZWxlbWVudCB3aXRoIHRoZSBwbGFjZWhvbGRlciB0ZXh0IG9mOiBcIiArIHRleHQ7XG5jb25zdCBxdWVyeUFsbEJ5UGxhY2Vob2xkZXJUZXh0V2l0aFN1Z2dlc3Rpb25zID0gd3JhcEFsbEJ5UXVlcnlXaXRoU3VnZ2VzdGlvbihxdWVyeUFsbEJ5UGxhY2Vob2xkZXJUZXh0LCBxdWVyeUFsbEJ5UGxhY2Vob2xkZXJUZXh0Lm5hbWUsICdxdWVyeUFsbCcpO1xuY29uc3QgW3F1ZXJ5QnlQbGFjZWhvbGRlclRleHQsIGdldEFsbEJ5UGxhY2Vob2xkZXJUZXh0LCBnZXRCeVBsYWNlaG9sZGVyVGV4dCwgZmluZEFsbEJ5UGxhY2Vob2xkZXJUZXh0LCBmaW5kQnlQbGFjZWhvbGRlclRleHRdID0gYnVpbGRRdWVyaWVzKHF1ZXJ5QWxsQnlQbGFjZWhvbGRlclRleHQsIGdldE11bHRpcGxlRXJyb3IkNiwgZ2V0TWlzc2luZ0Vycm9yJDYpO1xuXG5jb25zdCBxdWVyeUFsbEJ5VGV4dCA9IGZ1bmN0aW9uIChjb250YWluZXIsIHRleHQsIF90ZW1wKSB7XG4gIGxldCB7XG4gICAgc2VsZWN0b3IgPSAnKicsXG4gICAgZXhhY3QgPSB0cnVlLFxuICAgIGNvbGxhcHNlV2hpdGVzcGFjZSxcbiAgICB0cmltLFxuICAgIGlnbm9yZSA9IGdldENvbmZpZygpLmRlZmF1bHRJZ25vcmUsXG4gICAgbm9ybWFsaXplclxuICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gIGNoZWNrQ29udGFpbmVyVHlwZShjb250YWluZXIpO1xuICBjb25zdCBtYXRjaGVyID0gZXhhY3QgPyBtYXRjaGVzIDogZnV6enlNYXRjaGVzO1xuICBjb25zdCBtYXRjaE5vcm1hbGl6ZXIgPSBtYWtlTm9ybWFsaXplcih7XG4gICAgY29sbGFwc2VXaGl0ZXNwYWNlLFxuICAgIHRyaW0sXG4gICAgbm9ybWFsaXplclxuICB9KTtcbiAgbGV0IGJhc2VBcnJheSA9IFtdO1xuICBpZiAodHlwZW9mIGNvbnRhaW5lci5tYXRjaGVzID09PSAnZnVuY3Rpb24nICYmIGNvbnRhaW5lci5tYXRjaGVzKHNlbGVjdG9yKSkge1xuICAgIGJhc2VBcnJheSA9IFtjb250YWluZXJdO1xuICB9XG4gIHJldHVybiBbLi4uYmFzZUFycmF5LCAuLi5BcnJheS5mcm9tKGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSldXG4gIC8vIFRPRE86IGBtYXRjaGVzYCBhY2NvcmRpbmcgbGliLmRvbS5kLnRzIGNhbiBnZXQgb25seSBgc3RyaW5nYCBidXQgYWNjb3JkaW5nIG91ciBjb2RlIGl0IGNhbiBoYW5kbGUgYWxzbyBib29sZWFuIDopXG4gIC5maWx0ZXIobm9kZSA9PiAhaWdub3JlIHx8ICFub2RlLm1hdGNoZXMoaWdub3JlKSkuZmlsdGVyKG5vZGUgPT4gbWF0Y2hlcihnZXROb2RlVGV4dChub2RlKSwgbm9kZSwgdGV4dCwgbWF0Y2hOb3JtYWxpemVyKSk7XG59O1xuY29uc3QgZ2V0TXVsdGlwbGVFcnJvciQ1ID0gKGMsIHRleHQpID0+IFwiRm91bmQgbXVsdGlwbGUgZWxlbWVudHMgd2l0aCB0aGUgdGV4dDogXCIgKyB0ZXh0O1xuY29uc3QgZ2V0TWlzc2luZ0Vycm9yJDUgPSBmdW5jdGlvbiAoYywgdGV4dCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBjb2xsYXBzZVdoaXRlc3BhY2UsXG4gICAgdHJpbSxcbiAgICBub3JtYWxpemVyLFxuICAgIHNlbGVjdG9yXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBtYXRjaE5vcm1hbGl6ZXIgPSBtYWtlTm9ybWFsaXplcih7XG4gICAgY29sbGFwc2VXaGl0ZXNwYWNlLFxuICAgIHRyaW0sXG4gICAgbm9ybWFsaXplclxuICB9KTtcbiAgY29uc3Qgbm9ybWFsaXplZFRleHQgPSBtYXRjaE5vcm1hbGl6ZXIodGV4dC50b1N0cmluZygpKTtcbiAgY29uc3QgaXNOb3JtYWxpemVkRGlmZmVyZW50ID0gbm9ybWFsaXplZFRleHQgIT09IHRleHQudG9TdHJpbmcoKTtcbiAgY29uc3QgaXNDdXN0b21TZWxlY3RvciA9IChzZWxlY3RvciAhPSBudWxsID8gc2VsZWN0b3IgOiAnKicpICE9PSAnKic7XG4gIHJldHVybiBcIlVuYWJsZSB0byBmaW5kIGFuIGVsZW1lbnQgd2l0aCB0aGUgdGV4dDogXCIgKyAoaXNOb3JtYWxpemVkRGlmZmVyZW50ID8gbm9ybWFsaXplZFRleHQgKyBcIiAobm9ybWFsaXplZCBmcm9tICdcIiArIHRleHQgKyBcIicpXCIgOiB0ZXh0KSArIChpc0N1c3RvbVNlbGVjdG9yID8gXCIsIHdoaWNoIG1hdGNoZXMgc2VsZWN0b3IgJ1wiICsgc2VsZWN0b3IgKyBcIidcIiA6ICcnKSArIFwiLiBUaGlzIGNvdWxkIGJlIGJlY2F1c2UgdGhlIHRleHQgaXMgYnJva2VuIHVwIGJ5IG11bHRpcGxlIGVsZW1lbnRzLiBJbiB0aGlzIGNhc2UsIHlvdSBjYW4gcHJvdmlkZSBhIGZ1bmN0aW9uIGZvciB5b3VyIHRleHQgbWF0Y2hlciB0byBtYWtlIHlvdXIgbWF0Y2hlciBtb3JlIGZsZXhpYmxlLlwiO1xufTtcbmNvbnN0IHF1ZXJ5QWxsQnlUZXh0V2l0aFN1Z2dlc3Rpb25zID0gd3JhcEFsbEJ5UXVlcnlXaXRoU3VnZ2VzdGlvbihxdWVyeUFsbEJ5VGV4dCwgcXVlcnlBbGxCeVRleHQubmFtZSwgJ3F1ZXJ5QWxsJyk7XG5jb25zdCBbcXVlcnlCeVRleHQsIGdldEFsbEJ5VGV4dCwgZ2V0QnlUZXh0LCBmaW5kQWxsQnlUZXh0LCBmaW5kQnlUZXh0XSA9IGJ1aWxkUXVlcmllcyhxdWVyeUFsbEJ5VGV4dCwgZ2V0TXVsdGlwbGVFcnJvciQ1LCBnZXRNaXNzaW5nRXJyb3IkNSk7XG5cbmNvbnN0IHF1ZXJ5QWxsQnlEaXNwbGF5VmFsdWUgPSBmdW5jdGlvbiAoY29udGFpbmVyLCB2YWx1ZSwgX3RlbXApIHtcbiAgbGV0IHtcbiAgICBleGFjdCA9IHRydWUsXG4gICAgY29sbGFwc2VXaGl0ZXNwYWNlLFxuICAgIHRyaW0sXG4gICAgbm9ybWFsaXplclxuICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gIGNoZWNrQ29udGFpbmVyVHlwZShjb250YWluZXIpO1xuICBjb25zdCBtYXRjaGVyID0gZXhhY3QgPyBtYXRjaGVzIDogZnV6enlNYXRjaGVzO1xuICBjb25zdCBtYXRjaE5vcm1hbGl6ZXIgPSBtYWtlTm9ybWFsaXplcih7XG4gICAgY29sbGFwc2VXaGl0ZXNwYWNlLFxuICAgIHRyaW0sXG4gICAgbm9ybWFsaXplclxuICB9KTtcbiAgcmV0dXJuIEFycmF5LmZyb20oY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dCx0ZXh0YXJlYSxzZWxlY3RcIikpLmZpbHRlcihub2RlID0+IHtcbiAgICBpZiAobm9kZS50YWdOYW1lID09PSAnU0VMRUNUJykge1xuICAgICAgY29uc3Qgc2VsZWN0ZWRPcHRpb25zID0gQXJyYXkuZnJvbShub2RlLm9wdGlvbnMpLmZpbHRlcihvcHRpb24gPT4gb3B0aW9uLnNlbGVjdGVkKTtcbiAgICAgIHJldHVybiBzZWxlY3RlZE9wdGlvbnMuc29tZShvcHRpb25Ob2RlID0+IG1hdGNoZXIoZ2V0Tm9kZVRleHQob3B0aW9uTm9kZSksIG9wdGlvbk5vZGUsIHZhbHVlLCBtYXRjaE5vcm1hbGl6ZXIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1hdGNoZXIobm9kZS52YWx1ZSwgbm9kZSwgdmFsdWUsIG1hdGNoTm9ybWFsaXplcik7XG4gICAgfVxuICB9KTtcbn07XG5jb25zdCBnZXRNdWx0aXBsZUVycm9yJDQgPSAoYywgdmFsdWUpID0+IFwiRm91bmQgbXVsdGlwbGUgZWxlbWVudHMgd2l0aCB0aGUgZGlzcGxheSB2YWx1ZTogXCIgKyB2YWx1ZSArIFwiLlwiO1xuY29uc3QgZ2V0TWlzc2luZ0Vycm9yJDQgPSAoYywgdmFsdWUpID0+IFwiVW5hYmxlIHRvIGZpbmQgYW4gZWxlbWVudCB3aXRoIHRoZSBkaXNwbGF5IHZhbHVlOiBcIiArIHZhbHVlICsgXCIuXCI7XG5jb25zdCBxdWVyeUFsbEJ5RGlzcGxheVZhbHVlV2l0aFN1Z2dlc3Rpb25zID0gd3JhcEFsbEJ5UXVlcnlXaXRoU3VnZ2VzdGlvbihxdWVyeUFsbEJ5RGlzcGxheVZhbHVlLCBxdWVyeUFsbEJ5RGlzcGxheVZhbHVlLm5hbWUsICdxdWVyeUFsbCcpO1xuY29uc3QgW3F1ZXJ5QnlEaXNwbGF5VmFsdWUsIGdldEFsbEJ5RGlzcGxheVZhbHVlLCBnZXRCeURpc3BsYXlWYWx1ZSwgZmluZEFsbEJ5RGlzcGxheVZhbHVlLCBmaW5kQnlEaXNwbGF5VmFsdWVdID0gYnVpbGRRdWVyaWVzKHF1ZXJ5QWxsQnlEaXNwbGF5VmFsdWUsIGdldE11bHRpcGxlRXJyb3IkNCwgZ2V0TWlzc2luZ0Vycm9yJDQpO1xuXG4vLyBWYWxpZCB0YWdzIGFyZSBpbWcsIGlucHV0LCBhcmVhIGFuZCBjdXN0b20gZWxlbWVudHNcbmNvbnN0IFZBTElEX1RBR19SRUdFWFAgPSAvXihpbWd8aW5wdXR8YXJlYXwuKy0uKykkL2k7XG5jb25zdCBxdWVyeUFsbEJ5QWx0VGV4dCA9IGZ1bmN0aW9uIChjb250YWluZXIsIGFsdCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNoZWNrQ29udGFpbmVyVHlwZShjb250YWluZXIpO1xuICByZXR1cm4gcXVlcnlBbGxCeUF0dHJpYnV0ZSgnYWx0JywgY29udGFpbmVyLCBhbHQsIG9wdGlvbnMpLmZpbHRlcihub2RlID0+IFZBTElEX1RBR19SRUdFWFAudGVzdChub2RlLnRhZ05hbWUpKTtcbn07XG5jb25zdCBnZXRNdWx0aXBsZUVycm9yJDMgPSAoYywgYWx0KSA9PiBcIkZvdW5kIG11bHRpcGxlIGVsZW1lbnRzIHdpdGggdGhlIGFsdCB0ZXh0OiBcIiArIGFsdDtcbmNvbnN0IGdldE1pc3NpbmdFcnJvciQzID0gKGMsIGFsdCkgPT4gXCJVbmFibGUgdG8gZmluZCBhbiBlbGVtZW50IHdpdGggdGhlIGFsdCB0ZXh0OiBcIiArIGFsdDtcbmNvbnN0IHF1ZXJ5QWxsQnlBbHRUZXh0V2l0aFN1Z2dlc3Rpb25zID0gd3JhcEFsbEJ5UXVlcnlXaXRoU3VnZ2VzdGlvbihxdWVyeUFsbEJ5QWx0VGV4dCwgcXVlcnlBbGxCeUFsdFRleHQubmFtZSwgJ3F1ZXJ5QWxsJyk7XG5jb25zdCBbcXVlcnlCeUFsdFRleHQsIGdldEFsbEJ5QWx0VGV4dCwgZ2V0QnlBbHRUZXh0LCBmaW5kQWxsQnlBbHRUZXh0LCBmaW5kQnlBbHRUZXh0XSA9IGJ1aWxkUXVlcmllcyhxdWVyeUFsbEJ5QWx0VGV4dCwgZ2V0TXVsdGlwbGVFcnJvciQzLCBnZXRNaXNzaW5nRXJyb3IkMyk7XG5cbmNvbnN0IGlzU3ZnVGl0bGUgPSBub2RlID0+IHtcbiAgdmFyIF9ub2RlJHBhcmVudEVsZW1lbnQ7XG4gIHJldHVybiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RpdGxlJyAmJiAoKF9ub2RlJHBhcmVudEVsZW1lbnQgPSBub2RlLnBhcmVudEVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRwYXJlbnRFbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSkgPT09ICdzdmcnO1xufTtcbmNvbnN0IHF1ZXJ5QWxsQnlUaXRsZSA9IGZ1bmN0aW9uIChjb250YWluZXIsIHRleHQsIF90ZW1wKSB7XG4gIGxldCB7XG4gICAgZXhhY3QgPSB0cnVlLFxuICAgIGNvbGxhcHNlV2hpdGVzcGFjZSxcbiAgICB0cmltLFxuICAgIG5vcm1hbGl6ZXJcbiAgfSA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wO1xuICBjaGVja0NvbnRhaW5lclR5cGUoY29udGFpbmVyKTtcbiAgY29uc3QgbWF0Y2hlciA9IGV4YWN0ID8gbWF0Y2hlcyA6IGZ1enp5TWF0Y2hlcztcbiAgY29uc3QgbWF0Y2hOb3JtYWxpemVyID0gbWFrZU5vcm1hbGl6ZXIoe1xuICAgIGNvbGxhcHNlV2hpdGVzcGFjZSxcbiAgICB0cmltLFxuICAgIG5vcm1hbGl6ZXJcbiAgfSk7XG4gIHJldHVybiBBcnJheS5mcm9tKGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCdbdGl0bGVdLCBzdmcgPiB0aXRsZScpKS5maWx0ZXIobm9kZSA9PiBtYXRjaGVyKG5vZGUuZ2V0QXR0cmlidXRlKCd0aXRsZScpLCBub2RlLCB0ZXh0LCBtYXRjaE5vcm1hbGl6ZXIpIHx8IGlzU3ZnVGl0bGUobm9kZSkgJiYgbWF0Y2hlcihnZXROb2RlVGV4dChub2RlKSwgbm9kZSwgdGV4dCwgbWF0Y2hOb3JtYWxpemVyKSk7XG59O1xuY29uc3QgZ2V0TXVsdGlwbGVFcnJvciQyID0gKGMsIHRpdGxlKSA9PiBcIkZvdW5kIG11bHRpcGxlIGVsZW1lbnRzIHdpdGggdGhlIHRpdGxlOiBcIiArIHRpdGxlICsgXCIuXCI7XG5jb25zdCBnZXRNaXNzaW5nRXJyb3IkMiA9IChjLCB0aXRsZSkgPT4gXCJVbmFibGUgdG8gZmluZCBhbiBlbGVtZW50IHdpdGggdGhlIHRpdGxlOiBcIiArIHRpdGxlICsgXCIuXCI7XG5jb25zdCBxdWVyeUFsbEJ5VGl0bGVXaXRoU3VnZ2VzdGlvbnMgPSB3cmFwQWxsQnlRdWVyeVdpdGhTdWdnZXN0aW9uKHF1ZXJ5QWxsQnlUaXRsZSwgcXVlcnlBbGxCeVRpdGxlLm5hbWUsICdxdWVyeUFsbCcpO1xuY29uc3QgW3F1ZXJ5QnlUaXRsZSwgZ2V0QWxsQnlUaXRsZSwgZ2V0QnlUaXRsZSwgZmluZEFsbEJ5VGl0bGUsIGZpbmRCeVRpdGxlXSA9IGJ1aWxkUXVlcmllcyhxdWVyeUFsbEJ5VGl0bGUsIGdldE11bHRpcGxlRXJyb3IkMiwgZ2V0TWlzc2luZ0Vycm9yJDIpO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5ICovXG5jb25zdCBxdWVyeUFsbEJ5Um9sZSA9IGZ1bmN0aW9uIChjb250YWluZXIsIHJvbGUsIF90ZW1wKSB7XG4gIGxldCB7XG4gICAgaGlkZGVuID0gZ2V0Q29uZmlnKCkuZGVmYXVsdEhpZGRlbixcbiAgICBuYW1lLFxuICAgIGRlc2NyaXB0aW9uLFxuICAgIHF1ZXJ5RmFsbGJhY2tzID0gZmFsc2UsXG4gICAgc2VsZWN0ZWQsXG4gICAgYnVzeSxcbiAgICBjaGVja2VkLFxuICAgIHByZXNzZWQsXG4gICAgY3VycmVudCxcbiAgICBsZXZlbCxcbiAgICBleHBhbmRlZCxcbiAgICB2YWx1ZToge1xuICAgICAgbm93OiB2YWx1ZU5vdyxcbiAgICAgIG1pbjogdmFsdWVNaW4sXG4gICAgICBtYXg6IHZhbHVlTWF4LFxuICAgICAgdGV4dDogdmFsdWVUZXh0XG4gICAgfSA9IHt9XG4gIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcbiAgY2hlY2tDb250YWluZXJUeXBlKGNvbnRhaW5lcik7XG4gIGlmIChzZWxlY3RlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIF9hbGxSb2xlcyRnZXQ7XG4gICAgLy8gZ3VhcmQgYWdhaW5zdCB1bmtub3duIHJvbGVzXG4gICAgaWYgKCgoX2FsbFJvbGVzJGdldCA9IHJvbGVzLmdldChyb2xlKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hbGxSb2xlcyRnZXQucHJvcHNbJ2FyaWEtc2VsZWN0ZWQnXSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFxcImFyaWEtc2VsZWN0ZWRcXFwiIGlzIG5vdCBzdXBwb3J0ZWQgb24gcm9sZSBcXFwiXCIgKyByb2xlICsgXCJcXFwiLlwiKTtcbiAgICB9XG4gIH1cbiAgaWYgKGJ1c3kgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBfYWxsUm9sZXMkZ2V0MjtcbiAgICAvLyBndWFyZCBhZ2FpbnN0IHVua25vd24gcm9sZXNcbiAgICBpZiAoKChfYWxsUm9sZXMkZ2V0MiA9IHJvbGVzLmdldChyb2xlKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hbGxSb2xlcyRnZXQyLnByb3BzWydhcmlhLWJ1c3knXSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFxcImFyaWEtYnVzeVxcXCIgaXMgbm90IHN1cHBvcnRlZCBvbiByb2xlIFxcXCJcIiArIHJvbGUgKyBcIlxcXCIuXCIpO1xuICAgIH1cbiAgfVxuICBpZiAoY2hlY2tlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIF9hbGxSb2xlcyRnZXQzO1xuICAgIC8vIGd1YXJkIGFnYWluc3QgdW5rbm93biByb2xlc1xuICAgIGlmICgoKF9hbGxSb2xlcyRnZXQzID0gcm9sZXMuZ2V0KHJvbGUpKSA9PSBudWxsID8gdm9pZCAwIDogX2FsbFJvbGVzJGdldDMucHJvcHNbJ2FyaWEtY2hlY2tlZCddKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXFwiYXJpYS1jaGVja2VkXFxcIiBpcyBub3Qgc3VwcG9ydGVkIG9uIHJvbGUgXFxcIlwiICsgcm9sZSArIFwiXFxcIi5cIik7XG4gICAgfVxuICB9XG4gIGlmIChwcmVzc2VkICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgX2FsbFJvbGVzJGdldDQ7XG4gICAgLy8gZ3VhcmQgYWdhaW5zdCB1bmtub3duIHJvbGVzXG4gICAgaWYgKCgoX2FsbFJvbGVzJGdldDQgPSByb2xlcy5nZXQocm9sZSkpID09IG51bGwgPyB2b2lkIDAgOiBfYWxsUm9sZXMkZ2V0NC5wcm9wc1snYXJpYS1wcmVzc2VkJ10pID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcXCJhcmlhLXByZXNzZWRcXFwiIGlzIG5vdCBzdXBwb3J0ZWQgb24gcm9sZSBcXFwiXCIgKyByb2xlICsgXCJcXFwiLlwiKTtcbiAgICB9XG4gIH1cbiAgaWYgKGN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBfYWxsUm9sZXMkZ2V0NTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIC8vIGd1YXJkIGFnYWluc3QgdW5rbm93biByb2xlc1xuICAgIC8vIEFsbCBjdXJyZW50bHkgcmVsZWFzZWQgQVJJQSB2ZXJzaW9ucyBzdXBwb3J0IGBhcmlhLWN1cnJlbnRgIG9uIGFsbCByb2xlcy5cbiAgICAvLyBMZWF2aW5nIHRoaXMgZm9yIHN5bWV0cnkgYW5kIGZvcndhcmQgY29tcGF0aWJpbGl0eVxuICAgIGlmICgoKF9hbGxSb2xlcyRnZXQ1ID0gcm9sZXMuZ2V0KHJvbGUpKSA9PSBudWxsID8gdm9pZCAwIDogX2FsbFJvbGVzJGdldDUucHJvcHNbJ2FyaWEtY3VycmVudCddKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXFwiYXJpYS1jdXJyZW50XFxcIiBpcyBub3Qgc3VwcG9ydGVkIG9uIHJvbGUgXFxcIlwiICsgcm9sZSArIFwiXFxcIi5cIik7XG4gICAgfVxuICB9XG4gIGlmIChsZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gZ3VhcmQgYWdhaW5zdCB1c2luZyBgbGV2ZWxgIG9wdGlvbiB3aXRoIGFueSByb2xlIG90aGVyIHRoYW4gYGhlYWRpbmdgXG4gICAgaWYgKHJvbGUgIT09ICdoZWFkaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm9sZSBcXFwiXCIgKyByb2xlICsgXCJcXFwiIGNhbm5vdCBoYXZlIFxcXCJsZXZlbFxcXCIgcHJvcGVydHkuXCIpO1xuICAgIH1cbiAgfVxuICBpZiAodmFsdWVOb3cgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBfYWxsUm9sZXMkZ2V0NjtcbiAgICAvLyBndWFyZCBhZ2FpbnN0IHVua25vd24gcm9sZXNcbiAgICBpZiAoKChfYWxsUm9sZXMkZ2V0NiA9IHJvbGVzLmdldChyb2xlKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hbGxSb2xlcyRnZXQ2LnByb3BzWydhcmlhLXZhbHVlbm93J10pID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcXCJhcmlhLXZhbHVlbm93XFxcIiBpcyBub3Qgc3VwcG9ydGVkIG9uIHJvbGUgXFxcIlwiICsgcm9sZSArIFwiXFxcIi5cIik7XG4gICAgfVxuICB9XG4gIGlmICh2YWx1ZU1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIF9hbGxSb2xlcyRnZXQ3O1xuICAgIC8vIGd1YXJkIGFnYWluc3QgdW5rbm93biByb2xlc1xuICAgIGlmICgoKF9hbGxSb2xlcyRnZXQ3ID0gcm9sZXMuZ2V0KHJvbGUpKSA9PSBudWxsID8gdm9pZCAwIDogX2FsbFJvbGVzJGdldDcucHJvcHNbJ2FyaWEtdmFsdWVtYXgnXSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFxcImFyaWEtdmFsdWVtYXhcXFwiIGlzIG5vdCBzdXBwb3J0ZWQgb24gcm9sZSBcXFwiXCIgKyByb2xlICsgXCJcXFwiLlwiKTtcbiAgICB9XG4gIH1cbiAgaWYgKHZhbHVlTWluICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgX2FsbFJvbGVzJGdldDg7XG4gICAgLy8gZ3VhcmQgYWdhaW5zdCB1bmtub3duIHJvbGVzXG4gICAgaWYgKCgoX2FsbFJvbGVzJGdldDggPSByb2xlcy5nZXQocm9sZSkpID09IG51bGwgPyB2b2lkIDAgOiBfYWxsUm9sZXMkZ2V0OC5wcm9wc1snYXJpYS12YWx1ZW1pbiddKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXFwiYXJpYS12YWx1ZW1pblxcXCIgaXMgbm90IHN1cHBvcnRlZCBvbiByb2xlIFxcXCJcIiArIHJvbGUgKyBcIlxcXCIuXCIpO1xuICAgIH1cbiAgfVxuICBpZiAodmFsdWVUZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgX2FsbFJvbGVzJGdldDk7XG4gICAgLy8gZ3VhcmQgYWdhaW5zdCB1bmtub3duIHJvbGVzXG4gICAgaWYgKCgoX2FsbFJvbGVzJGdldDkgPSByb2xlcy5nZXQocm9sZSkpID09IG51bGwgPyB2b2lkIDAgOiBfYWxsUm9sZXMkZ2V0OS5wcm9wc1snYXJpYS12YWx1ZXRleHQnXSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFxcImFyaWEtdmFsdWV0ZXh0XFxcIiBpcyBub3Qgc3VwcG9ydGVkIG9uIHJvbGUgXFxcIlwiICsgcm9sZSArIFwiXFxcIi5cIik7XG4gICAgfVxuICB9XG4gIGlmIChleHBhbmRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIF9hbGxSb2xlcyRnZXQxMDtcbiAgICAvLyBndWFyZCBhZ2FpbnN0IHVua25vd24gcm9sZXNcbiAgICBpZiAoKChfYWxsUm9sZXMkZ2V0MTAgPSByb2xlcy5nZXQocm9sZSkpID09IG51bGwgPyB2b2lkIDAgOiBfYWxsUm9sZXMkZ2V0MTAucHJvcHNbJ2FyaWEtZXhwYW5kZWQnXSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFxcImFyaWEtZXhwYW5kZWRcXFwiIGlzIG5vdCBzdXBwb3J0ZWQgb24gcm9sZSBcXFwiXCIgKyByb2xlICsgXCJcXFwiLlwiKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc3VidHJlZUlzSW5hY2Nlc3NpYmxlQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuICBmdW5jdGlvbiBjYWNoZWRJc1N1YnRyZWVJbmFjY2Vzc2libGUoZWxlbWVudCkge1xuICAgIGlmICghc3VidHJlZUlzSW5hY2Nlc3NpYmxlQ2FjaGUuaGFzKGVsZW1lbnQpKSB7XG4gICAgICBzdWJ0cmVlSXNJbmFjY2Vzc2libGVDYWNoZS5zZXQoZWxlbWVudCwgaXNTdWJ0cmVlSW5hY2Nlc3NpYmxlKGVsZW1lbnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1YnRyZWVJc0luYWNjZXNzaWJsZUNhY2hlLmdldChlbGVtZW50KTtcbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShjb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcbiAgLy8gT25seSBxdWVyeSBlbGVtZW50cyB0aGF0IGNhbiBiZSBtYXRjaGVkIGJ5IHRoZSBmb2xsb3dpbmcgZmlsdGVyc1xuICBtYWtlUm9sZVNlbGVjdG9yKHJvbGUpKSkuZmlsdGVyKG5vZGUgPT4ge1xuICAgIGNvbnN0IGlzUm9sZVNwZWNpZmllZEV4cGxpY2l0bHkgPSBub2RlLmhhc0F0dHJpYnV0ZSgncm9sZScpO1xuICAgIGlmIChpc1JvbGVTcGVjaWZpZWRFeHBsaWNpdGx5KSB7XG4gICAgICBjb25zdCByb2xlVmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZSgncm9sZScpO1xuICAgICAgaWYgKHF1ZXJ5RmFsbGJhY2tzKSB7XG4gICAgICAgIHJldHVybiByb2xlVmFsdWUuc3BsaXQoJyAnKS5maWx0ZXIoQm9vbGVhbikuc29tZShyb2xlQXR0cmlidXRlVG9rZW4gPT4gcm9sZUF0dHJpYnV0ZVRva2VuID09PSByb2xlKTtcbiAgICAgIH1cbiAgICAgIC8vIG90aGVyIHdpc2Ugb25seSBzZW5kIHRoZSBmaXJzdCB0b2tlbiB0byBtYXRjaFxuICAgICAgY29uc3QgW2ZpcnN0Um9sZUF0dHJpYnV0ZVRva2VuXSA9IHJvbGVWYWx1ZS5zcGxpdCgnICcpO1xuICAgICAgcmV0dXJuIGZpcnN0Um9sZUF0dHJpYnV0ZVRva2VuID09PSByb2xlO1xuICAgIH1cbiAgICBjb25zdCBpbXBsaWNpdFJvbGVzID0gZ2V0SW1wbGljaXRBcmlhUm9sZXMobm9kZSk7XG4gICAgcmV0dXJuIGltcGxpY2l0Um9sZXMuc29tZShpbXBsaWNpdFJvbGUgPT4ge1xuICAgICAgcmV0dXJuIGltcGxpY2l0Um9sZSA9PT0gcm9sZTtcbiAgICB9KTtcbiAgfSkuZmlsdGVyKGVsZW1lbnQgPT4ge1xuICAgIGlmIChzZWxlY3RlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gc2VsZWN0ZWQgPT09IGNvbXB1dGVBcmlhU2VsZWN0ZWQoZWxlbWVudCk7XG4gICAgfVxuICAgIGlmIChidXN5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBidXN5ID09PSBjb21wdXRlQXJpYUJ1c3koZWxlbWVudCk7XG4gICAgfVxuICAgIGlmIChjaGVja2VkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBjaGVja2VkID09PSBjb21wdXRlQXJpYUNoZWNrZWQoZWxlbWVudCk7XG4gICAgfVxuICAgIGlmIChwcmVzc2VkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBwcmVzc2VkID09PSBjb21wdXRlQXJpYVByZXNzZWQoZWxlbWVudCk7XG4gICAgfVxuICAgIGlmIChjdXJyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBjdXJyZW50ID09PSBjb21wdXRlQXJpYUN1cnJlbnQoZWxlbWVudCk7XG4gICAgfVxuICAgIGlmIChleHBhbmRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXhwYW5kZWQgPT09IGNvbXB1dGVBcmlhRXhwYW5kZWQoZWxlbWVudCk7XG4gICAgfVxuICAgIGlmIChsZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbGV2ZWwgPT09IGNvbXB1dGVIZWFkaW5nTGV2ZWwoZWxlbWVudCk7XG4gICAgfVxuICAgIGlmICh2YWx1ZU5vdyAhPT0gdW5kZWZpbmVkIHx8IHZhbHVlTWF4ICE9PSB1bmRlZmluZWQgfHwgdmFsdWVNaW4gIT09IHVuZGVmaW5lZCB8fCB2YWx1ZVRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IHZhbHVlTWF0Y2hlcyA9IHRydWU7XG4gICAgICBpZiAodmFsdWVOb3cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZU1hdGNoZXMgJiYgKHZhbHVlTWF0Y2hlcyA9IHZhbHVlTm93ID09PSBjb21wdXRlQXJpYVZhbHVlTm93KGVsZW1lbnQpKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZU1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlTWF0Y2hlcyAmJiAodmFsdWVNYXRjaGVzID0gdmFsdWVNYXggPT09IGNvbXB1dGVBcmlhVmFsdWVNYXgoZWxlbWVudCkpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlTWluICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWVNYXRjaGVzICYmICh2YWx1ZU1hdGNoZXMgPSB2YWx1ZU1pbiA9PT0gY29tcHV0ZUFyaWFWYWx1ZU1pbihlbGVtZW50KSk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWVUZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIF9jb21wdXRlQXJpYVZhbHVlVGV4dDtcbiAgICAgICAgdmFsdWVNYXRjaGVzICYmICh2YWx1ZU1hdGNoZXMgPSBtYXRjaGVzKChfY29tcHV0ZUFyaWFWYWx1ZVRleHQgPSBjb21wdXRlQXJpYVZhbHVlVGV4dChlbGVtZW50KSkgIT0gbnVsbCA/IF9jb21wdXRlQXJpYVZhbHVlVGV4dCA6IG51bGwsIGVsZW1lbnQsIHZhbHVlVGV4dCwgdGV4dCA9PiB0ZXh0KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVNYXRjaGVzO1xuICAgIH1cbiAgICAvLyBkb24ndCBjYXJlIGlmIGFyaWEgYXR0cmlidXRlcyBhcmUgdW5zcGVjaWZpZWRcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSkuZmlsdGVyKGVsZW1lbnQgPT4ge1xuICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIERvbid0IGNhcmVcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hlcyhjb21wdXRlQWNjZXNzaWJsZU5hbWUoZWxlbWVudCwge1xuICAgICAgY29tcHV0ZWRTdHlsZVN1cHBvcnRzUHNldWRvRWxlbWVudHM6IGdldENvbmZpZygpLmNvbXB1dGVkU3R5bGVTdXBwb3J0c1BzZXVkb0VsZW1lbnRzXG4gICAgfSksIGVsZW1lbnQsIG5hbWUsIHRleHQgPT4gdGV4dCk7XG4gIH0pLmZpbHRlcihlbGVtZW50ID0+IHtcbiAgICBpZiAoZGVzY3JpcHRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRG9uJ3QgY2FyZVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBtYXRjaGVzKGNvbXB1dGVBY2Nlc3NpYmxlRGVzY3JpcHRpb24oZWxlbWVudCwge1xuICAgICAgY29tcHV0ZWRTdHlsZVN1cHBvcnRzUHNldWRvRWxlbWVudHM6IGdldENvbmZpZygpLmNvbXB1dGVkU3R5bGVTdXBwb3J0c1BzZXVkb0VsZW1lbnRzXG4gICAgfSksIGVsZW1lbnQsIGRlc2NyaXB0aW9uLCB0ZXh0ID0+IHRleHQpO1xuICB9KS5maWx0ZXIoZWxlbWVudCA9PiB7XG4gICAgcmV0dXJuIGhpZGRlbiA9PT0gZmFsc2UgPyBpc0luYWNjZXNzaWJsZShlbGVtZW50LCB7XG4gICAgICBpc1N1YnRyZWVJbmFjY2Vzc2libGU6IGNhY2hlZElzU3VidHJlZUluYWNjZXNzaWJsZVxuICAgIH0pID09PSBmYWxzZSA6IHRydWU7XG4gIH0pO1xufTtcbmZ1bmN0aW9uIG1ha2VSb2xlU2VsZWN0b3Iocm9sZSkge1xuICB2YXIgX3JvbGVFbGVtZW50cyRnZXQ7XG4gIGNvbnN0IGV4cGxpY2l0Um9sZVNlbGVjdG9yID0gXCIqW3JvbGV+PVxcXCJcIiArIHJvbGUgKyBcIlxcXCJdXCI7XG4gIGNvbnN0IHJvbGVSZWxhdGlvbnMgPSAoX3JvbGVFbGVtZW50cyRnZXQgPSByb2xlRWxlbWVudHMuZ2V0KHJvbGUpKSAhPSBudWxsID8gX3JvbGVFbGVtZW50cyRnZXQgOiBuZXcgU2V0KCk7XG4gIGNvbnN0IGltcGxpY2l0Um9sZVNlbGVjdG9ycyA9IG5ldyBTZXQoQXJyYXkuZnJvbShyb2xlUmVsYXRpb25zKS5tYXAoX3JlZiA9PiB7XG4gICAgbGV0IHtcbiAgICAgIG5hbWVcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4gbmFtZTtcbiAgfSkpO1xuXG4gIC8vIEN1cnJlbnQgdHJhbnNwaWxhdGlvbiBjb25maWcgc29tZXRpbWVzIGFzc3VtZXMgYC4uLmAgaXMgYWx3YXlzIGFwcGxpZWQgdG8gYXJyYXlzLlxuICAvLyBgLi4uYCBpcyBlcXVpdmFsZW50IHRvIGBBcnJheS5wcm90b3R5cGUuY29uY2F0YCBmb3IgYXJyYXlzLlxuICAvLyBJZiB5b3UgcmVwbGFjZSB0aGlzIGNvZGUgd2l0aCBgW2V4cGxpY2l0Um9sZVNlbGVjdG9yLCAuLi5pbXBsaWNpdFJvbGVTZWxlY3RvcnNdYCwgbWFrZSBzdXJlIGV2ZXJ5IHRyYW5zcGlsYXRpb24gdGFyZ2V0IHJldGFpbnMgdGhlIGAuLi5gIGluIGZhdm9yIG9mIGBBcnJheS5wcm90b3R5cGUuY29uY2F0YC5cbiAgcmV0dXJuIFtleHBsaWNpdFJvbGVTZWxlY3Rvcl0uY29uY2F0KEFycmF5LmZyb20oaW1wbGljaXRSb2xlU2VsZWN0b3JzKSkuam9pbignLCcpO1xufVxuY29uc3QgZ2V0TmFtZUhpbnQgPSBuYW1lID0+IHtcbiAgbGV0IG5hbWVIaW50ID0gJyc7XG4gIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICBuYW1lSGludCA9ICcnO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgIG5hbWVIaW50ID0gXCIgYW5kIG5hbWUgXFxcIlwiICsgbmFtZSArIFwiXFxcIlwiO1xuICB9IGVsc2Uge1xuICAgIG5hbWVIaW50ID0gXCIgYW5kIG5hbWUgYFwiICsgbmFtZSArIFwiYFwiO1xuICB9XG4gIHJldHVybiBuYW1lSGludDtcbn07XG5jb25zdCBnZXRNdWx0aXBsZUVycm9yJDEgPSBmdW5jdGlvbiAoYywgcm9sZSwgX3RlbXAyKSB7XG4gIGxldCB7XG4gICAgbmFtZVxuICB9ID0gX3RlbXAyID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wMjtcbiAgcmV0dXJuIFwiRm91bmQgbXVsdGlwbGUgZWxlbWVudHMgd2l0aCB0aGUgcm9sZSBcXFwiXCIgKyByb2xlICsgXCJcXFwiXCIgKyBnZXROYW1lSGludChuYW1lKTtcbn07XG5jb25zdCBnZXRNaXNzaW5nRXJyb3IkMSA9IGZ1bmN0aW9uIChjb250YWluZXIsIHJvbGUsIF90ZW1wMykge1xuICBsZXQge1xuICAgIGhpZGRlbiA9IGdldENvbmZpZygpLmRlZmF1bHRIaWRkZW4sXG4gICAgbmFtZSxcbiAgICBkZXNjcmlwdGlvblxuICB9ID0gX3RlbXAzID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wMztcbiAgaWYgKGdldENvbmZpZygpLl9kaXNhYmxlRXhwZW5zaXZlRXJyb3JEaWFnbm9zdGljcykge1xuICAgIHJldHVybiBcIlVuYWJsZSB0byBmaW5kIHJvbGU9XFxcIlwiICsgcm9sZSArIFwiXFxcIlwiICsgZ2V0TmFtZUhpbnQobmFtZSk7XG4gIH1cbiAgbGV0IHJvbGVzID0gJyc7XG4gIEFycmF5LmZyb20oY29udGFpbmVyLmNoaWxkcmVuKS5mb3JFYWNoKGNoaWxkRWxlbWVudCA9PiB7XG4gICAgcm9sZXMgKz0gcHJldHR5Um9sZXMoY2hpbGRFbGVtZW50LCB7XG4gICAgICBoaWRkZW4sXG4gICAgICBpbmNsdWRlRGVzY3JpcHRpb246IGRlc2NyaXB0aW9uICE9PSB1bmRlZmluZWRcbiAgICB9KTtcbiAgfSk7XG4gIGxldCByb2xlTWVzc2FnZTtcbiAgaWYgKHJvbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChoaWRkZW4gPT09IGZhbHNlKSB7XG4gICAgICByb2xlTWVzc2FnZSA9ICdUaGVyZSBhcmUgbm8gYWNjZXNzaWJsZSByb2xlcy4gQnV0IHRoZXJlIG1pZ2h0IGJlIHNvbWUgaW5hY2Nlc3NpYmxlIHJvbGVzLiAnICsgJ0lmIHlvdSB3aXNoIHRvIGFjY2VzcyB0aGVtLCB0aGVuIHNldCB0aGUgYGhpZGRlbmAgb3B0aW9uIHRvIGB0cnVlYC4gJyArICdMZWFybiBtb3JlIGFib3V0IHRoaXMgaGVyZTogaHR0cHM6Ly90ZXN0aW5nLWxpYnJhcnkuY29tL2RvY3MvZG9tLXRlc3RpbmctbGlicmFyeS9hcGktcXVlcmllcyNieXJvbGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICByb2xlTWVzc2FnZSA9ICdUaGVyZSBhcmUgbm8gYXZhaWxhYmxlIHJvbGVzLic7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJvbGVNZXNzYWdlID0gKFwiXFxuSGVyZSBhcmUgdGhlIFwiICsgKGhpZGRlbiA9PT0gZmFsc2UgPyAnYWNjZXNzaWJsZScgOiAnYXZhaWxhYmxlJykgKyBcIiByb2xlczpcXG5cXG4gIFwiICsgcm9sZXMucmVwbGFjZSgvXFxuL2csICdcXG4gICcpLnJlcGxhY2UoL1xcblxcc1xcc1xcbi9nLCAnXFxuXFxuJykgKyBcIlxcblwiKS50cmltKCk7XG4gIH1cbiAgbGV0IG5hbWVIaW50ID0gJyc7XG4gIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICBuYW1lSGludCA9ICcnO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgIG5hbWVIaW50ID0gXCIgYW5kIG5hbWUgXFxcIlwiICsgbmFtZSArIFwiXFxcIlwiO1xuICB9IGVsc2Uge1xuICAgIG5hbWVIaW50ID0gXCIgYW5kIG5hbWUgYFwiICsgbmFtZSArIFwiYFwiO1xuICB9XG4gIGxldCBkZXNjcmlwdGlvbkhpbnQgPSAnJztcbiAgaWYgKGRlc2NyaXB0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICBkZXNjcmlwdGlvbkhpbnQgPSAnJztcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVzY3JpcHRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgZGVzY3JpcHRpb25IaW50ID0gXCIgYW5kIGRlc2NyaXB0aW9uIFxcXCJcIiArIGRlc2NyaXB0aW9uICsgXCJcXFwiXCI7XG4gIH0gZWxzZSB7XG4gICAgZGVzY3JpcHRpb25IaW50ID0gXCIgYW5kIGRlc2NyaXB0aW9uIGBcIiArIGRlc2NyaXB0aW9uICsgXCJgXCI7XG4gIH1cbiAgcmV0dXJuIChcIlxcblVuYWJsZSB0byBmaW5kIGFuIFwiICsgKGhpZGRlbiA9PT0gZmFsc2UgPyAnYWNjZXNzaWJsZSAnIDogJycpICsgXCJlbGVtZW50IHdpdGggdGhlIHJvbGUgXFxcIlwiICsgcm9sZSArIFwiXFxcIlwiICsgbmFtZUhpbnQgKyBkZXNjcmlwdGlvbkhpbnQgKyBcIlxcblxcblwiICsgcm9sZU1lc3NhZ2UpLnRyaW0oKTtcbn07XG5jb25zdCBxdWVyeUFsbEJ5Um9sZVdpdGhTdWdnZXN0aW9ucyA9IHdyYXBBbGxCeVF1ZXJ5V2l0aFN1Z2dlc3Rpb24ocXVlcnlBbGxCeVJvbGUsIHF1ZXJ5QWxsQnlSb2xlLm5hbWUsICdxdWVyeUFsbCcpO1xuY29uc3QgW3F1ZXJ5QnlSb2xlLCBnZXRBbGxCeVJvbGUsIGdldEJ5Um9sZSwgZmluZEFsbEJ5Um9sZSwgZmluZEJ5Um9sZV0gPSBidWlsZFF1ZXJpZXMocXVlcnlBbGxCeVJvbGUsIGdldE11bHRpcGxlRXJyb3IkMSwgZ2V0TWlzc2luZ0Vycm9yJDEpO1xuXG5jb25zdCBnZXRUZXN0SWRBdHRyaWJ1dGUgPSAoKSA9PiBnZXRDb25maWcoKS50ZXN0SWRBdHRyaWJ1dGU7XG5jb25zdCBxdWVyeUFsbEJ5VGVzdElkID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIGNoZWNrQ29udGFpbmVyVHlwZShhcmdzWzBdKTtcbiAgcmV0dXJuIHF1ZXJ5QWxsQnlBdHRyaWJ1dGUoZ2V0VGVzdElkQXR0cmlidXRlKCksIC4uLmFyZ3MpO1xufTtcbmNvbnN0IGdldE11bHRpcGxlRXJyb3IgPSAoYywgaWQpID0+IFwiRm91bmQgbXVsdGlwbGUgZWxlbWVudHMgYnk6IFtcIiArIGdldFRlc3RJZEF0dHJpYnV0ZSgpICsgXCI9XFxcIlwiICsgaWQgKyBcIlxcXCJdXCI7XG5jb25zdCBnZXRNaXNzaW5nRXJyb3IgPSAoYywgaWQpID0+IFwiVW5hYmxlIHRvIGZpbmQgYW4gZWxlbWVudCBieTogW1wiICsgZ2V0VGVzdElkQXR0cmlidXRlKCkgKyBcIj1cXFwiXCIgKyBpZCArIFwiXFxcIl1cIjtcbmNvbnN0IHF1ZXJ5QWxsQnlUZXN0SWRXaXRoU3VnZ2VzdGlvbnMgPSB3cmFwQWxsQnlRdWVyeVdpdGhTdWdnZXN0aW9uKHF1ZXJ5QWxsQnlUZXN0SWQsIHF1ZXJ5QWxsQnlUZXN0SWQubmFtZSwgJ3F1ZXJ5QWxsJyk7XG5jb25zdCBbcXVlcnlCeVRlc3RJZCwgZ2V0QWxsQnlUZXN0SWQsIGdldEJ5VGVzdElkLCBmaW5kQWxsQnlUZXN0SWQsIGZpbmRCeVRlc3RJZF0gPSBidWlsZFF1ZXJpZXMocXVlcnlBbGxCeVRlc3RJZCwgZ2V0TXVsdGlwbGVFcnJvciwgZ2V0TWlzc2luZ0Vycm9yKTtcblxudmFyIHF1ZXJpZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgcXVlcnlBbGxCeUxhYmVsVGV4dDogcXVlcnlBbGxCeUxhYmVsVGV4dFdpdGhTdWdnZXN0aW9ucyxcbiAgcXVlcnlCeUxhYmVsVGV4dDogcXVlcnlCeUxhYmVsVGV4dCxcbiAgZ2V0QWxsQnlMYWJlbFRleHQ6IGdldEFsbEJ5TGFiZWxUZXh0V2l0aFN1Z2dlc3Rpb25zLFxuICBnZXRCeUxhYmVsVGV4dDogZ2V0QnlMYWJlbFRleHRXaXRoU3VnZ2VzdGlvbnMsXG4gIGZpbmRBbGxCeUxhYmVsVGV4dDogZmluZEFsbEJ5TGFiZWxUZXh0LFxuICBmaW5kQnlMYWJlbFRleHQ6IGZpbmRCeUxhYmVsVGV4dCxcbiAgcXVlcnlCeVBsYWNlaG9sZGVyVGV4dDogcXVlcnlCeVBsYWNlaG9sZGVyVGV4dCxcbiAgcXVlcnlBbGxCeVBsYWNlaG9sZGVyVGV4dDogcXVlcnlBbGxCeVBsYWNlaG9sZGVyVGV4dFdpdGhTdWdnZXN0aW9ucyxcbiAgZ2V0QnlQbGFjZWhvbGRlclRleHQ6IGdldEJ5UGxhY2Vob2xkZXJUZXh0LFxuICBnZXRBbGxCeVBsYWNlaG9sZGVyVGV4dDogZ2V0QWxsQnlQbGFjZWhvbGRlclRleHQsXG4gIGZpbmRBbGxCeVBsYWNlaG9sZGVyVGV4dDogZmluZEFsbEJ5UGxhY2Vob2xkZXJUZXh0LFxuICBmaW5kQnlQbGFjZWhvbGRlclRleHQ6IGZpbmRCeVBsYWNlaG9sZGVyVGV4dCxcbiAgcXVlcnlCeVRleHQ6IHF1ZXJ5QnlUZXh0LFxuICBxdWVyeUFsbEJ5VGV4dDogcXVlcnlBbGxCeVRleHRXaXRoU3VnZ2VzdGlvbnMsXG4gIGdldEJ5VGV4dDogZ2V0QnlUZXh0LFxuICBnZXRBbGxCeVRleHQ6IGdldEFsbEJ5VGV4dCxcbiAgZmluZEFsbEJ5VGV4dDogZmluZEFsbEJ5VGV4dCxcbiAgZmluZEJ5VGV4dDogZmluZEJ5VGV4dCxcbiAgcXVlcnlCeURpc3BsYXlWYWx1ZTogcXVlcnlCeURpc3BsYXlWYWx1ZSxcbiAgcXVlcnlBbGxCeURpc3BsYXlWYWx1ZTogcXVlcnlBbGxCeURpc3BsYXlWYWx1ZVdpdGhTdWdnZXN0aW9ucyxcbiAgZ2V0QnlEaXNwbGF5VmFsdWU6IGdldEJ5RGlzcGxheVZhbHVlLFxuICBnZXRBbGxCeURpc3BsYXlWYWx1ZTogZ2V0QWxsQnlEaXNwbGF5VmFsdWUsXG4gIGZpbmRBbGxCeURpc3BsYXlWYWx1ZTogZmluZEFsbEJ5RGlzcGxheVZhbHVlLFxuICBmaW5kQnlEaXNwbGF5VmFsdWU6IGZpbmRCeURpc3BsYXlWYWx1ZSxcbiAgcXVlcnlCeUFsdFRleHQ6IHF1ZXJ5QnlBbHRUZXh0LFxuICBxdWVyeUFsbEJ5QWx0VGV4dDogcXVlcnlBbGxCeUFsdFRleHRXaXRoU3VnZ2VzdGlvbnMsXG4gIGdldEJ5QWx0VGV4dDogZ2V0QnlBbHRUZXh0LFxuICBnZXRBbGxCeUFsdFRleHQ6IGdldEFsbEJ5QWx0VGV4dCxcbiAgZmluZEFsbEJ5QWx0VGV4dDogZmluZEFsbEJ5QWx0VGV4dCxcbiAgZmluZEJ5QWx0VGV4dDogZmluZEJ5QWx0VGV4dCxcbiAgcXVlcnlCeVRpdGxlOiBxdWVyeUJ5VGl0bGUsXG4gIHF1ZXJ5QWxsQnlUaXRsZTogcXVlcnlBbGxCeVRpdGxlV2l0aFN1Z2dlc3Rpb25zLFxuICBnZXRCeVRpdGxlOiBnZXRCeVRpdGxlLFxuICBnZXRBbGxCeVRpdGxlOiBnZXRBbGxCeVRpdGxlLFxuICBmaW5kQWxsQnlUaXRsZTogZmluZEFsbEJ5VGl0bGUsXG4gIGZpbmRCeVRpdGxlOiBmaW5kQnlUaXRsZSxcbiAgcXVlcnlCeVJvbGU6IHF1ZXJ5QnlSb2xlLFxuICBxdWVyeUFsbEJ5Um9sZTogcXVlcnlBbGxCeVJvbGVXaXRoU3VnZ2VzdGlvbnMsXG4gIGdldEFsbEJ5Um9sZTogZ2V0QWxsQnlSb2xlLFxuICBnZXRCeVJvbGU6IGdldEJ5Um9sZSxcbiAgZmluZEFsbEJ5Um9sZTogZmluZEFsbEJ5Um9sZSxcbiAgZmluZEJ5Um9sZTogZmluZEJ5Um9sZSxcbiAgcXVlcnlCeVRlc3RJZDogcXVlcnlCeVRlc3RJZCxcbiAgcXVlcnlBbGxCeVRlc3RJZDogcXVlcnlBbGxCeVRlc3RJZFdpdGhTdWdnZXN0aW9ucyxcbiAgZ2V0QnlUZXN0SWQ6IGdldEJ5VGVzdElkLFxuICBnZXRBbGxCeVRlc3RJZDogZ2V0QWxsQnlUZXN0SWQsXG4gIGZpbmRBbGxCeVRlc3RJZDogZmluZEFsbEJ5VGVzdElkLFxuICBmaW5kQnlUZXN0SWQ6IGZpbmRCeVRlc3RJZFxufSk7XG5cbi8qKlxuICogQHR5cGVkZWYge3tba2V5OiBzdHJpbmddOiBGdW5jdGlvbn19IEZ1bmNNYXBcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgY29udGFpbmVyXG4gKiBAcGFyYW0ge0Z1bmNNYXB9IHF1ZXJpZXMgb2JqZWN0IG9mIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IGluaXRpYWxWYWx1ZSBmb3IgcmVkdWNlclxuICogQHJldHVybnMge0Z1bmNNYXB9IHJldHVybnMgb2JqZWN0IG9mIGZ1bmN0aW9ucyBib3VuZCB0byBjb250YWluZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UXVlcmllc0ZvckVsZW1lbnQoZWxlbWVudCwgcXVlcmllcyQxLCBpbml0aWFsVmFsdWUpIHtcbiAgaWYgKHF1ZXJpZXMkMSA9PT0gdm9pZCAwKSB7XG4gICAgcXVlcmllcyQxID0gcXVlcmllcztcbiAgfVxuICBpZiAoaW5pdGlhbFZhbHVlID09PSB2b2lkIDApIHtcbiAgICBpbml0aWFsVmFsdWUgPSB7fTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmtleXMocXVlcmllcyQxKS5yZWR1Y2UoKGhlbHBlcnMsIGtleSkgPT4ge1xuICAgIGNvbnN0IGZuID0gcXVlcmllcyQxW2tleV07XG4gICAgaGVscGVyc1trZXldID0gZm4uYmluZChudWxsLCBlbGVtZW50KTtcbiAgICByZXR1cm4gaGVscGVycztcbiAgfSwgaW5pdGlhbFZhbHVlKTtcbn1cblxuY29uc3QgaXNSZW1vdmVkID0gcmVzdWx0ID0+ICFyZXN1bHQgfHwgQXJyYXkuaXNBcnJheShyZXN1bHQpICYmICFyZXN1bHQubGVuZ3RoO1xuXG4vLyBDaGVjayBpZiB0aGUgZWxlbWVudCBpcyBub3QgcHJlc2VudC5cbi8vIEFzIHRoZSBuYW1lIGltcGxpZXMsIHdhaXRGb3JFbGVtZW50VG9CZVJlbW92ZWQgc2hvdWxkIGNoZWNrIGBwcmVzZW50YCAtLT4gYHJlbW92ZWRgXG5mdW5jdGlvbiBpbml0aWFsQ2hlY2soZWxlbWVudHMpIHtcbiAgaWYgKGlzUmVtb3ZlZChlbGVtZW50cykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBlbGVtZW50KHMpIGdpdmVuIHRvIHdhaXRGb3JFbGVtZW50VG9CZVJlbW92ZWQgYXJlIGFscmVhZHkgcmVtb3ZlZC4gd2FpdEZvckVsZW1lbnRUb0JlUmVtb3ZlZCByZXF1aXJlcyB0aGF0IHRoZSBlbGVtZW50KHMpIGV4aXN0KHMpIGJlZm9yZSB3YWl0aW5nIGZvciByZW1vdmFsLicpO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiB3YWl0Rm9yRWxlbWVudFRvQmVSZW1vdmVkKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIC8vIGNyZWF0ZWQgaGVyZSBzbyB3ZSBnZXQgYSBuaWNlIHN0YWNrdHJhY2VcbiAgY29uc3QgdGltZW91dEVycm9yID0gbmV3IEVycm9yKCdUaW1lZCBvdXQgaW4gd2FpdEZvckVsZW1lbnRUb0JlUmVtb3ZlZC4nKTtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGluaXRpYWxDaGVjayhjYWxsYmFjayk7XG4gICAgY29uc3QgZWxlbWVudHMgPSBBcnJheS5pc0FycmF5KGNhbGxiYWNrKSA/IGNhbGxiYWNrIDogW2NhbGxiYWNrXTtcbiAgICBjb25zdCBnZXRSZW1haW5pbmdFbGVtZW50cyA9IGVsZW1lbnRzLm1hcChlbGVtZW50ID0+IHtcbiAgICAgIGxldCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICBpZiAocGFyZW50ID09PSBudWxsKSByZXR1cm4gKCkgPT4gbnVsbDtcbiAgICAgIHdoaWxlIChwYXJlbnQucGFyZW50RWxlbWVudCkgcGFyZW50ID0gcGFyZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICByZXR1cm4gKCkgPT4gcGFyZW50LmNvbnRhaW5zKGVsZW1lbnQpID8gZWxlbWVudCA6IG51bGw7XG4gICAgfSk7XG4gICAgY2FsbGJhY2sgPSAoKSA9PiBnZXRSZW1haW5pbmdFbGVtZW50cy5tYXAoYyA9PiBjKCkpLmZpbHRlcihCb29sZWFuKTtcbiAgfVxuICBpbml0aWFsQ2hlY2soY2FsbGJhY2soKSk7XG4gIHJldHVybiB3YWl0Rm9yV3JhcHBlcigoKSA9PiB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gY2FsbGJhY2soKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdUZXN0aW5nTGlicmFyeUVsZW1lbnRFcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBpZiAoIWlzUmVtb3ZlZChyZXN1bHQpKSB7XG4gICAgICB0aHJvdyB0aW1lb3V0RXJyb3I7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0sIG9wdGlvbnMpO1xufVxuXG4vKlxuZXNsaW50XG4gIHJlcXVpcmUtYXdhaXQ6IFwib2ZmXCJcbiovXG5cbmNvbnN0IGV2ZW50TWFwID0ge1xuICAvLyBDbGlwYm9hcmQgRXZlbnRzXG4gIGNvcHk6IHtcbiAgICBFdmVudFR5cGU6ICdDbGlwYm9hcmRFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIGN1dDoge1xuICAgIEV2ZW50VHlwZTogJ0NsaXBib2FyZEV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgcGFzdGU6IHtcbiAgICBFdmVudFR5cGU6ICdDbGlwYm9hcmRFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIC8vIENvbXBvc2l0aW9uIEV2ZW50c1xuICBjb21wb3NpdGlvbkVuZDoge1xuICAgIEV2ZW50VHlwZTogJ0NvbXBvc2l0aW9uRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBjb21wb3NpdGlvblN0YXJ0OiB7XG4gICAgRXZlbnRUeXBlOiAnQ29tcG9zaXRpb25FdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIGNvbXBvc2l0aW9uVXBkYXRlOiB7XG4gICAgRXZlbnRUeXBlOiAnQ29tcG9zaXRpb25FdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIC8vIEtleWJvYXJkIEV2ZW50c1xuICBrZXlEb3duOiB7XG4gICAgRXZlbnRUeXBlOiAnS2V5Ym9hcmRFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY2hhckNvZGU6IDAsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAga2V5UHJlc3M6IHtcbiAgICBFdmVudFR5cGU6ICdLZXlib2FyZEV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBjaGFyQ29kZTogMCxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBrZXlVcDoge1xuICAgIEV2ZW50VHlwZTogJ0tleWJvYXJkRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGNoYXJDb2RlOiAwLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIC8vIEZvY3VzIEV2ZW50c1xuICBmb2N1czoge1xuICAgIEV2ZW50VHlwZTogJ0ZvY3VzRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIGJsdXI6IHtcbiAgICBFdmVudFR5cGU6ICdGb2N1c0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBmb2N1c0luOiB7XG4gICAgRXZlbnRUeXBlOiAnRm9jdXNFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBmb2N1c091dDoge1xuICAgIEV2ZW50VHlwZTogJ0ZvY3VzRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2UsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgLy8gRm9ybSBFdmVudHNcbiAgY2hhbmdlOiB7XG4gICAgRXZlbnRUeXBlOiAnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIGlucHV0OiB7XG4gICAgRXZlbnRUeXBlOiAnSW5wdXRFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBpbnZhbGlkOiB7XG4gICAgRXZlbnRUeXBlOiAnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9XG4gIH0sXG4gIHN1Ym1pdDoge1xuICAgIEV2ZW50VHlwZTogJ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9XG4gIH0sXG4gIHJlc2V0OiB7XG4gICAgRXZlbnRUeXBlOiAnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgLy8gTW91c2UgRXZlbnRzXG4gIGNsaWNrOiB7XG4gICAgRXZlbnRUeXBlOiAnTW91c2VFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgYnV0dG9uOiAwLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIGNvbnRleHRNZW51OiB7XG4gICAgRXZlbnRUeXBlOiAnTW91c2VFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIGRibENsaWNrOiB7XG4gICAgRXZlbnRUeXBlOiAnTW91c2VFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIGRyYWc6IHtcbiAgICBFdmVudFR5cGU6ICdEcmFnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBkcmFnRW5kOiB7XG4gICAgRXZlbnRUeXBlOiAnRHJhZ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIGRyYWdFbnRlcjoge1xuICAgIEV2ZW50VHlwZTogJ0RyYWdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIGRyYWdFeGl0OiB7XG4gICAgRXZlbnRUeXBlOiAnRHJhZ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIGRyYWdMZWF2ZToge1xuICAgIEV2ZW50VHlwZTogJ0RyYWdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBkcmFnT3Zlcjoge1xuICAgIEV2ZW50VHlwZTogJ0RyYWdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIGRyYWdTdGFydDoge1xuICAgIEV2ZW50VHlwZTogJ0RyYWdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIGRyb3A6IHtcbiAgICBFdmVudFR5cGU6ICdEcmFnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBtb3VzZURvd246IHtcbiAgICBFdmVudFR5cGU6ICdNb3VzZUV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgbW91c2VFbnRlcjoge1xuICAgIEV2ZW50VHlwZTogJ01vdXNlRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIG1vdXNlTGVhdmU6IHtcbiAgICBFdmVudFR5cGU6ICdNb3VzZUV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBtb3VzZU1vdmU6IHtcbiAgICBFdmVudFR5cGU6ICdNb3VzZUV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgbW91c2VPdXQ6IHtcbiAgICBFdmVudFR5cGU6ICdNb3VzZUV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgbW91c2VPdmVyOiB7XG4gICAgRXZlbnRUeXBlOiAnTW91c2VFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIG1vdXNlVXA6IHtcbiAgICBFdmVudFR5cGU6ICdNb3VzZUV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgLy8gU2VsZWN0aW9uIEV2ZW50c1xuICBzZWxlY3Q6IHtcbiAgICBFdmVudFR5cGU6ICdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgLy8gVG91Y2ggRXZlbnRzXG4gIHRvdWNoQ2FuY2VsOiB7XG4gICAgRXZlbnRUeXBlOiAnVG91Y2hFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICB0b3VjaEVuZDoge1xuICAgIEV2ZW50VHlwZTogJ1RvdWNoRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICB0b3VjaE1vdmU6IHtcbiAgICBFdmVudFR5cGU6ICdUb3VjaEV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgdG91Y2hTdGFydDoge1xuICAgIEV2ZW50VHlwZTogJ1RvdWNoRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICAvLyBVSSBFdmVudHNcbiAgcmVzaXplOiB7XG4gICAgRXZlbnRUeXBlOiAnVUlFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHNjcm9sbDoge1xuICAgIEV2ZW50VHlwZTogJ1VJRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICAvLyBXaGVlbCBFdmVudHNcbiAgd2hlZWw6IHtcbiAgICBFdmVudFR5cGU6ICdXaGVlbEV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgLy8gTWVkaWEgRXZlbnRzXG4gIGFib3J0OiB7XG4gICAgRXZlbnRUeXBlOiAnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICBjYW5QbGF5OiB7XG4gICAgRXZlbnRUeXBlOiAnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICBjYW5QbGF5VGhyb3VnaDoge1xuICAgIEV2ZW50VHlwZTogJ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgZHVyYXRpb25DaGFuZ2U6IHtcbiAgICBFdmVudFR5cGU6ICdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIGVtcHRpZWQ6IHtcbiAgICBFdmVudFR5cGU6ICdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIGVuY3J5cHRlZDoge1xuICAgIEV2ZW50VHlwZTogJ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgZW5kZWQ6IHtcbiAgICBFdmVudFR5cGU6ICdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIGxvYWRlZERhdGE6IHtcbiAgICBFdmVudFR5cGU6ICdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIGxvYWRlZE1ldGFkYXRhOiB7XG4gICAgRXZlbnRUeXBlOiAnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICBsb2FkU3RhcnQ6IHtcbiAgICBFdmVudFR5cGU6ICdQcm9ncmVzc0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgcGF1c2U6IHtcbiAgICBFdmVudFR5cGU6ICdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHBsYXk6IHtcbiAgICBFdmVudFR5cGU6ICdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHBsYXlpbmc6IHtcbiAgICBFdmVudFR5cGU6ICdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHByb2dyZXNzOiB7XG4gICAgRXZlbnRUeXBlOiAnUHJvZ3Jlc3NFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHJhdGVDaGFuZ2U6IHtcbiAgICBFdmVudFR5cGU6ICdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHNlZWtlZDoge1xuICAgIEV2ZW50VHlwZTogJ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgc2Vla2luZzoge1xuICAgIEV2ZW50VHlwZTogJ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgc3RhbGxlZDoge1xuICAgIEV2ZW50VHlwZTogJ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgc3VzcGVuZDoge1xuICAgIEV2ZW50VHlwZTogJ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgdGltZVVwZGF0ZToge1xuICAgIEV2ZW50VHlwZTogJ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgdm9sdW1lQ2hhbmdlOiB7XG4gICAgRXZlbnRUeXBlOiAnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICB3YWl0aW5nOiB7XG4gICAgRXZlbnRUeXBlOiAnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICAvLyBFdmVudHNcbiAgbG9hZDoge1xuICAgIC8vIFRPRE86IGxvYWQgZXZlbnRzIGNhbiBiZSBVSUV2ZW50IG9yIEV2ZW50IGRlcGVuZGluZyBvbiB3aGF0IGdlbmVyYXRlZCB0aGVtXG4gICAgLy8gVGhpcyBpcyB3aGVyZSB0aGlzIGFic3RyYWN0aW9uIGJyZWFrcyBkb3duLlxuICAgIC8vIEJ1dCB0aGUgY29tbW9uIHRhcmdldHMgYXJlIDxpbWcgLz4sIDxzY3JpcHQgLz4gYW5kIHdpbmRvdy5cbiAgICAvLyBOZWl0aGVyIG9mIHRoZXNlIHRhcmdldHMgcmVjZWl2ZSBhIFVJRXZlbnRcbiAgICBFdmVudFR5cGU6ICdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIGVycm9yOiB7XG4gICAgRXZlbnRUeXBlOiAnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICAvLyBBbmltYXRpb24gRXZlbnRzXG4gIGFuaW1hdGlvblN0YXJ0OiB7XG4gICAgRXZlbnRUeXBlOiAnQW5pbWF0aW9uRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIGFuaW1hdGlvbkVuZDoge1xuICAgIEV2ZW50VHlwZTogJ0FuaW1hdGlvbkV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICBhbmltYXRpb25JdGVyYXRpb246IHtcbiAgICBFdmVudFR5cGU6ICdBbmltYXRpb25FdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgLy8gVHJhbnNpdGlvbiBFdmVudHNcbiAgdHJhbnNpdGlvbkNhbmNlbDoge1xuICAgIEV2ZW50VHlwZTogJ1RyYW5zaXRpb25FdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgdHJhbnNpdGlvbkVuZDoge1xuICAgIEV2ZW50VHlwZTogJ1RyYW5zaXRpb25FdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgfVxuICB9LFxuICB0cmFuc2l0aW9uUnVuOiB7XG4gICAgRXZlbnRUeXBlOiAnVHJhbnNpdGlvbkV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICB0cmFuc2l0aW9uU3RhcnQ6IHtcbiAgICBFdmVudFR5cGU6ICdUcmFuc2l0aW9uRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIC8vIHBvaW50ZXIgZXZlbnRzXG4gIHBvaW50ZXJPdmVyOiB7XG4gICAgRXZlbnRUeXBlOiAnUG9pbnRlckV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgcG9pbnRlckVudGVyOiB7XG4gICAgRXZlbnRUeXBlOiAnUG9pbnRlckV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgcG9pbnRlckRvd246IHtcbiAgICBFdmVudFR5cGU6ICdQb2ludGVyRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBwb2ludGVyTW92ZToge1xuICAgIEV2ZW50VHlwZTogJ1BvaW50ZXJFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIHBvaW50ZXJVcDoge1xuICAgIEV2ZW50VHlwZTogJ1BvaW50ZXJFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIHBvaW50ZXJDYW5jZWw6IHtcbiAgICBFdmVudFR5cGU6ICdQb2ludGVyRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2UsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgcG9pbnRlck91dDoge1xuICAgIEV2ZW50VHlwZTogJ1BvaW50ZXJFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIHBvaW50ZXJMZWF2ZToge1xuICAgIEV2ZW50VHlwZTogJ1BvaW50ZXJFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIGdvdFBvaW50ZXJDYXB0dXJlOiB7XG4gICAgRXZlbnRUeXBlOiAnUG9pbnRlckV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIGxvc3RQb2ludGVyQ2FwdHVyZToge1xuICAgIEV2ZW50VHlwZTogJ1BvaW50ZXJFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICAvLyBoaXN0b3J5IGV2ZW50c1xuICBwb3BTdGF0ZToge1xuICAgIEV2ZW50VHlwZTogJ1BvcFN0YXRlRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIC8vIHdpbmRvdyBldmVudHNcbiAgb2ZmbGluZToge1xuICAgIEV2ZW50VHlwZTogJ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgb25saW5lOiB7XG4gICAgRXZlbnRUeXBlOiAnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9XG59O1xuY29uc3QgZXZlbnRBbGlhc01hcCA9IHtcbiAgZG91YmxlQ2xpY2s6ICdkYmxDbGljaydcbn07XG5cbmZ1bmN0aW9uIGZpcmVFdmVudChlbGVtZW50LCBldmVudCkge1xuICByZXR1cm4gZ2V0Q29uZmlnKCkuZXZlbnRXcmFwcGVyKCgpID0+IHtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZmlyZSBhbiBldmVudCAtIHBsZWFzZSBwcm92aWRlIGFuIGV2ZW50IG9iamVjdC5cIik7XG4gICAgfVxuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpcmUgYSBcXFwiXCIgKyBldmVudC50eXBlICsgXCJcXFwiIGV2ZW50IC0gcGxlYXNlIHByb3ZpZGUgYSBET00gZWxlbWVudC5cIik7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50KGV2ZW50TmFtZSwgbm9kZSwgaW5pdCwgX3RlbXApIHtcbiAgbGV0IHtcbiAgICBFdmVudFR5cGUgPSAnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0ID0ge31cbiAgfSA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wO1xuICBpZiAoIW5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZmlyZSBhIFxcXCJcIiArIGV2ZW50TmFtZSArIFwiXFxcIiBldmVudCAtIHBsZWFzZSBwcm92aWRlIGEgRE9NIGVsZW1lbnQuXCIpO1xuICB9XG4gIGNvbnN0IGV2ZW50SW5pdCA9IHtcbiAgICAuLi5kZWZhdWx0SW5pdCxcbiAgICAuLi5pbml0XG4gIH07XG4gIGNvbnN0IHtcbiAgICB0YXJnZXQ6IHtcbiAgICAgIHZhbHVlLFxuICAgICAgZmlsZXMsXG4gICAgICAuLi50YXJnZXRQcm9wZXJ0aWVzXG4gICAgfSA9IHt9XG4gIH0gPSBldmVudEluaXQ7XG4gIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2V0TmF0aXZlVmFsdWUobm9kZSwgdmFsdWUpO1xuICB9XG4gIGlmIChmaWxlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gaW5wdXQuZmlsZXMgaXMgYSByZWFkLW9ubHkgcHJvcGVydHkgc28gdGhpcyBpcyBub3QgYWxsb3dlZDpcbiAgICAvLyBpbnB1dC5maWxlcyA9IFtmaWxlXVxuICAgIC8vIHNvIHdlIGhhdmUgdG8gdXNlIHRoaXMgd29ya2Fyb3VuZCB0byBzZXQgdGhlIHByb3BlcnR5XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vZGUsICdmaWxlcycsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmaWxlc1xuICAgIH0pO1xuICB9XG4gIE9iamVjdC5hc3NpZ24obm9kZSwgdGFyZ2V0UHJvcGVydGllcyk7XG4gIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvd0Zyb21Ob2RlKG5vZGUpO1xuICBjb25zdCBFdmVudENvbnN0cnVjdG9yID0gd2luZG93W0V2ZW50VHlwZV0gfHwgd2luZG93LkV2ZW50O1xuICBsZXQgZXZlbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICAqL1xuICBpZiAodHlwZW9mIEV2ZW50Q29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBldmVudCA9IG5ldyBFdmVudENvbnN0cnVjdG9yKGV2ZW50TmFtZSwgZXZlbnRJbml0KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJRTExIHBvbHlmaWxsIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50L0N1c3RvbUV2ZW50I1BvbHlmaWxsXG4gICAgZXZlbnQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRXZlbnQoRXZlbnRUeXBlKTtcbiAgICBjb25zdCB7XG4gICAgICBidWJibGVzLFxuICAgICAgY2FuY2VsYWJsZSxcbiAgICAgIGRldGFpbCxcbiAgICAgIC4uLm90aGVySW5pdFxuICAgIH0gPSBldmVudEluaXQ7XG4gICAgZXZlbnQuaW5pdEV2ZW50KGV2ZW50TmFtZSwgYnViYmxlcywgY2FuY2VsYWJsZSwgZGV0YWlsKTtcbiAgICBPYmplY3Qua2V5cyhvdGhlckluaXQpLmZvckVhY2goZXZlbnRLZXkgPT4ge1xuICAgICAgZXZlbnRbZXZlbnRLZXldID0gb3RoZXJJbml0W2V2ZW50S2V5XTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIERhdGFUcmFuc2ZlciBpcyBub3Qgc3VwcG9ydGVkIGluIGpzZG9tOiBodHRwczovL2dpdGh1Yi5jb20vanNkb20vanNkb20vaXNzdWVzLzE1NjhcbiAgY29uc3QgZGF0YVRyYW5zZmVyUHJvcGVydGllcyA9IFsnZGF0YVRyYW5zZmVyJywgJ2NsaXBib2FyZERhdGEnXTtcbiAgZGF0YVRyYW5zZmVyUHJvcGVydGllcy5mb3JFYWNoKGRhdGFUcmFuc2ZlcktleSA9PiB7XG4gICAgY29uc3QgZGF0YVRyYW5zZmVyVmFsdWUgPSBldmVudEluaXRbZGF0YVRyYW5zZmVyS2V5XTtcbiAgICBpZiAodHlwZW9mIGRhdGFUcmFuc2ZlclZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuRGF0YVRyYW5zZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShldmVudCwgZGF0YVRyYW5zZmVyS2V5LCB7XG4gICAgICAgICAgdmFsdWU6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGRhdGFUcmFuc2ZlclZhbHVlKS5yZWR1Y2UoKGFjYywgcHJvcE5hbWUpID0+IHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhY2MsIHByb3BOYW1lLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBkYXRhVHJhbnNmZXJWYWx1ZVtwcm9wTmFtZV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICB9LCBuZXcgd2luZG93LkRhdGFUcmFuc2ZlcigpKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShldmVudCwgZGF0YVRyYW5zZmVyS2V5LCB7XG4gICAgICAgICAgdmFsdWU6IGRhdGFUcmFuc2ZlclZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBldmVudDtcbn1cbk9iamVjdC5rZXlzKGV2ZW50TWFwKS5mb3JFYWNoKGtleSA9PiB7XG4gIGNvbnN0IHtcbiAgICBFdmVudFR5cGUsXG4gICAgZGVmYXVsdEluaXRcbiAgfSA9IGV2ZW50TWFwW2tleV07XG4gIGNvbnN0IGV2ZW50TmFtZSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICBjcmVhdGVFdmVudFtrZXldID0gKG5vZGUsIGluaXQpID0+IGNyZWF0ZUV2ZW50KGV2ZW50TmFtZSwgbm9kZSwgaW5pdCwge1xuICAgIEV2ZW50VHlwZSxcbiAgICBkZWZhdWx0SW5pdFxuICB9KTtcbiAgZmlyZUV2ZW50W2tleV0gPSAobm9kZSwgaW5pdCkgPT4gZmlyZUV2ZW50KG5vZGUsIGNyZWF0ZUV2ZW50W2tleV0obm9kZSwgaW5pdCkpO1xufSk7XG5cbi8vIGZ1bmN0aW9uIHdyaXR0ZW4gYWZ0ZXIgc29tZSBpbnZlc3RpZ2F0aW9uIGhlcmU6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEwMTM1I2lzc3VlY29tbWVudC00MDE0OTY3NzZcbmZ1bmN0aW9uIHNldE5hdGl2ZVZhbHVlKGVsZW1lbnQsIHZhbHVlKSB7XG4gIGNvbnN0IHtcbiAgICBzZXQ6IHZhbHVlU2V0dGVyXG4gIH0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGVsZW1lbnQsICd2YWx1ZScpIHx8IHt9O1xuICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZWxlbWVudCk7XG4gIGNvbnN0IHtcbiAgICBzZXQ6IHByb3RvdHlwZVZhbHVlU2V0dGVyXG4gIH0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvdHlwZSwgJ3ZhbHVlJykgfHwge307XG4gIGlmIChwcm90b3R5cGVWYWx1ZVNldHRlciAmJiB2YWx1ZVNldHRlciAhPT0gcHJvdG90eXBlVmFsdWVTZXR0ZXIpIHtcbiAgICBwcm90b3R5cGVWYWx1ZVNldHRlci5jYWxsKGVsZW1lbnQsIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZWx5LWlmIC0tIENhbid0IGJlIGlnbm9yZWQgYnkgaXN0YW5idWwgb3RoZXJ3aXNlXG4gICAgaWYgKHZhbHVlU2V0dGVyKSB7XG4gICAgICB2YWx1ZVNldHRlci5jYWxsKGVsZW1lbnQsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZ2l2ZW4gZWxlbWVudCBkb2VzIG5vdCBoYXZlIGEgdmFsdWUgc2V0dGVyJyk7XG4gICAgfVxuICB9XG59XG5PYmplY3Qua2V5cyhldmVudEFsaWFzTWFwKS5mb3JFYWNoKGFsaWFzS2V5ID0+IHtcbiAgY29uc3Qga2V5ID0gZXZlbnRBbGlhc01hcFthbGlhc0tleV07XG4gIGZpcmVFdmVudFthbGlhc0tleV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZpcmVFdmVudFtrZXldKC4uLmFyZ3VtZW50cyk7XG4gIH07XG59KTtcblxuLyogZXNsaW50IGNvbXBsZXhpdHk6W1wiZXJyb3JcIiwgOV0gKi9cblxuLy8gV0FSTklORzogYGx6LXN0cmluZ2Agb25seSBoYXMgYSBkZWZhdWx0IGV4cG9ydCBidXQgc3RhdGljYWxseSB3ZSBhc3N1bWUgbmFtZWQgZXhwb3J0cyBhcmUgYWxsb3dkXG5mdW5jdGlvbiB1bmluZGVudChzdHJpbmcpIHtcbiAgLy8gcmVtb3ZlIHdoaXRlIHNwYWNlcyBmaXJzdCwgdG8gc2F2ZSBhIGZldyBieXRlcy5cbiAgLy8gdGVzdGluZy1wbGF5Z3JvdW5kIHdpbGwgcmVmb3JtYXQgb24gbG9hZCBhbnkgd2F5cy5cbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bIFxcdF0qW1xcbl1bIFxcdF0qL2csICdcXG4nKTtcbn1cbmZ1bmN0aW9uIGVuY29kZSh2YWx1ZSkge1xuICByZXR1cm4gbHpTdHJpbmcuY29tcHJlc3NUb0VuY29kZWRVUklDb21wb25lbnQodW5pbmRlbnQodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGdldFBsYXlncm91bmRVcmwobWFya3VwKSB7XG4gIHJldHVybiBcImh0dHBzOi8vdGVzdGluZy1wbGF5Z3JvdW5kLmNvbS8jbWFya3VwPVwiICsgZW5jb2RlKG1hcmt1cCk7XG59XG5jb25zdCBkZWJ1ZyA9IChlbGVtZW50LCBtYXhMZW5ndGgsIG9wdGlvbnMpID0+IEFycmF5LmlzQXJyYXkoZWxlbWVudCkgPyBlbGVtZW50LmZvckVhY2goZWwgPT4gbG9nRE9NKGVsLCBtYXhMZW5ndGgsIG9wdGlvbnMpKSA6IGxvZ0RPTShlbGVtZW50LCBtYXhMZW5ndGgsIG9wdGlvbnMpO1xuY29uc3QgbG9nVGVzdGluZ1BsYXlncm91bmRVUkwgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PT0gdm9pZCAwKSB7XG4gICAgZWxlbWVudCA9IGdldERvY3VtZW50KCkuYm9keTtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICBpZiAoIWVsZW1lbnQgfHwgISgnaW5uZXJIVE1MJyBpbiBlbGVtZW50KSkge1xuICAgIGNvbnNvbGUubG9nKFwiVGhlIGVsZW1lbnQgeW91J3JlIHByb3ZpZGluZyBpc24ndCBhIHZhbGlkIERPTSBlbGVtZW50LlwiKTtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgaWYgKCFlbGVtZW50LmlubmVySFRNTCkge1xuICAgIGNvbnNvbGUubG9nKFwiVGhlIHByb3ZpZGVkIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFueSBjaGlsZHJlbi5cIik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHBsYXlncm91bmRVcmwgPSBnZXRQbGF5Z3JvdW5kVXJsKGVsZW1lbnQuaW5uZXJIVE1MKTtcbiAgY29uc29sZS5sb2coXCJPcGVuIHRoaXMgVVJMIGluIHlvdXIgYnJvd3NlclxcblxcblwiICsgcGxheWdyb3VuZFVybCk7XG4gIHJldHVybiBwbGF5Z3JvdW5kVXJsO1xufTtcbmNvbnN0IGluaXRpYWxWYWx1ZSA9IHtcbiAgZGVidWcsXG4gIGxvZ1Rlc3RpbmdQbGF5Z3JvdW5kVVJMXG59O1xuY29uc3Qgc2NyZWVuID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5ib2R5IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuPyBnZXRRdWVyaWVzRm9yRWxlbWVudChkb2N1bWVudC5ib2R5LCBxdWVyaWVzLCBpbml0aWFsVmFsdWUpIDogT2JqZWN0LmtleXMocXVlcmllcykucmVkdWNlKChoZWxwZXJzLCBrZXkpID0+IHtcbiAgLy8gYGtleWAgaXMgZm9yIGFsbCBpbnRlbnRzIGFuZCBwdXJwb3NlcyB0aGUgdHlwZSBvZiBrZXlvZiBgaGVscGVyc2AsIHdoaWNoIGl0c2VsZiBpcyB0aGUgdHlwZSBvZiBgaW5pdGlhbFZhbHVlYCBwbHVzIGluY29taW5nIHByb3BlcnRpZXMgZnJvbSBgcXVlcmllc2BcbiAgLy8gaWYgYE9iamVjdC5rZXlzKHNvbWV0aGluZylgIHJldHVybmVkIEFycmF5PGtleW9mIHR5cGVvZiBzb21ldGhpbmc+IHRoaXMgZXhwbGljaXQgdHlwZSBhc3NlcnRpb24gd291bGQgbm90IGJlIG5lY2Vzc2FyeVxuICAvLyBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTUwMTIxNzQvd2h5LWRvZXNudC1vYmplY3Qta2V5cy1yZXR1cm4tYS1rZXlvZi10eXBlLWluLXR5cGVzY3JpcHRcbiAgaGVscGVyc1trZXldID0gKCkgPT4ge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZvciBxdWVyaWVzIGJvdW5kIHRvIGRvY3VtZW50LmJvZHkgYSBnbG9iYWwgZG9jdW1lbnQgaGFzIHRvIGJlIGF2YWlsYWJsZS4uLiBMZWFybiBtb3JlOiBodHRwczovL3Rlc3RpbmctbGlicmFyeS5jb20vcy9zY3JlZW4tZ2xvYmFsLWVycm9yJyk7XG4gIH07XG4gIHJldHVybiBoZWxwZXJzO1xufSwgaW5pdGlhbFZhbHVlKTtcblxuZXhwb3J0IHsgYnVpbGRRdWVyaWVzLCBjb25maWd1cmUsIGNyZWF0ZUV2ZW50LCBmaW5kQWxsQnlBbHRUZXh0LCBmaW5kQWxsQnlEaXNwbGF5VmFsdWUsIGZpbmRBbGxCeUxhYmVsVGV4dCwgZmluZEFsbEJ5UGxhY2Vob2xkZXJUZXh0LCBmaW5kQWxsQnlSb2xlLCBmaW5kQWxsQnlUZXN0SWQsIGZpbmRBbGxCeVRleHQsIGZpbmRBbGxCeVRpdGxlLCBmaW5kQnlBbHRUZXh0LCBmaW5kQnlEaXNwbGF5VmFsdWUsIGZpbmRCeUxhYmVsVGV4dCwgZmluZEJ5UGxhY2Vob2xkZXJUZXh0LCBmaW5kQnlSb2xlLCBmaW5kQnlUZXN0SWQsIGZpbmRCeVRleHQsIGZpbmRCeVRpdGxlLCBmaXJlRXZlbnQsIGdldEFsbEJ5QWx0VGV4dCwgZ2V0QWxsQnlEaXNwbGF5VmFsdWUsIGdldEFsbEJ5TGFiZWxUZXh0V2l0aFN1Z2dlc3Rpb25zIGFzIGdldEFsbEJ5TGFiZWxUZXh0LCBnZXRBbGxCeVBsYWNlaG9sZGVyVGV4dCwgZ2V0QWxsQnlSb2xlLCBnZXRBbGxCeVRlc3RJZCwgZ2V0QWxsQnlUZXh0LCBnZXRBbGxCeVRpdGxlLCBnZXRCeUFsdFRleHQsIGdldEJ5RGlzcGxheVZhbHVlLCBnZXRCeUxhYmVsVGV4dFdpdGhTdWdnZXN0aW9ucyBhcyBnZXRCeUxhYmVsVGV4dCwgZ2V0QnlQbGFjZWhvbGRlclRleHQsIGdldEJ5Um9sZSwgZ2V0QnlUZXN0SWQsIGdldEJ5VGV4dCwgZ2V0QnlUaXRsZSwgZ2V0Q29uZmlnLCBnZXREZWZhdWx0Tm9ybWFsaXplciwgZ2V0RWxlbWVudEVycm9yLCBnZXRNdWx0aXBsZUVsZW1lbnRzRm91bmRFcnJvciwgZ2V0Tm9kZVRleHQsIGdldFF1ZXJpZXNGb3JFbGVtZW50LCBnZXRSb2xlcywgZ2V0U3VnZ2VzdGVkUXVlcnksIGlzSW5hY2Nlc3NpYmxlLCBsb2dET00sIGxvZ1JvbGVzLCBtYWtlRmluZFF1ZXJ5LCBtYWtlR2V0QWxsUXVlcnksIG1ha2VTaW5nbGVRdWVyeSwgcHJldHR5RE9NLCBxdWVyaWVzLCBxdWVyeUFsbEJ5QWx0VGV4dFdpdGhTdWdnZXN0aW9ucyBhcyBxdWVyeUFsbEJ5QWx0VGV4dCwgcXVlcnlBbGxCeUF0dHJpYnV0ZSwgcXVlcnlBbGxCeURpc3BsYXlWYWx1ZVdpdGhTdWdnZXN0aW9ucyBhcyBxdWVyeUFsbEJ5RGlzcGxheVZhbHVlLCBxdWVyeUFsbEJ5TGFiZWxUZXh0V2l0aFN1Z2dlc3Rpb25zIGFzIHF1ZXJ5QWxsQnlMYWJlbFRleHQsIHF1ZXJ5QWxsQnlQbGFjZWhvbGRlclRleHRXaXRoU3VnZ2VzdGlvbnMgYXMgcXVlcnlBbGxCeVBsYWNlaG9sZGVyVGV4dCwgcXVlcnlBbGxCeVJvbGVXaXRoU3VnZ2VzdGlvbnMgYXMgcXVlcnlBbGxCeVJvbGUsIHF1ZXJ5QWxsQnlUZXN0SWRXaXRoU3VnZ2VzdGlvbnMgYXMgcXVlcnlBbGxCeVRlc3RJZCwgcXVlcnlBbGxCeVRleHRXaXRoU3VnZ2VzdGlvbnMgYXMgcXVlcnlBbGxCeVRleHQsIHF1ZXJ5QWxsQnlUaXRsZVdpdGhTdWdnZXN0aW9ucyBhcyBxdWVyeUFsbEJ5VGl0bGUsIHF1ZXJ5QnlBbHRUZXh0LCBxdWVyeUJ5QXR0cmlidXRlLCBxdWVyeUJ5RGlzcGxheVZhbHVlLCBxdWVyeUJ5TGFiZWxUZXh0LCBxdWVyeUJ5UGxhY2Vob2xkZXJUZXh0LCBxdWVyeUJ5Um9sZSwgcXVlcnlCeVRlc3RJZCwgcXVlcnlCeVRleHQsIHF1ZXJ5QnlUaXRsZSwgcXVlcnlIZWxwZXJzLCBzY3JlZW4sIHdhaXRGb3JXcmFwcGVyIGFzIHdhaXRGb3IsIHdhaXRGb3JFbGVtZW50VG9CZVJlbW92ZWQsIGdldFF1ZXJpZXNGb3JFbGVtZW50IGFzIHdpdGhpbiwgd3JhcEFsbEJ5UXVlcnlXaXRoU3VnZ2VzdGlvbiwgd3JhcFNpbmdsZVF1ZXJ5V2l0aFN1Z2dlc3Rpb24gfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@testing-library/dom/dist/@testing-library/dom.esm.js\n")},"./node_modules/@testing-library/dom/node_modules/pretty-format/build/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = exports.DEFAULT_OPTIONS = void 0;\nexports.format = format;\nexports.plugins = void 0;\n\nvar _ansiStyles = _interopRequireDefault(__webpack_require__(\"./node_modules/@testing-library/dom/node_modules/ansi-styles/index.js\"));\n\nvar _collections = __webpack_require__(\"./node_modules/@testing-library/dom/node_modules/pretty-format/build/collections.js\");\n\nvar _AsymmetricMatcher = _interopRequireDefault(\n  __webpack_require__(\"./node_modules/@testing-library/dom/node_modules/pretty-format/build/plugins/AsymmetricMatcher.js\")\n);\n\nvar _ConvertAnsi = _interopRequireDefault(__webpack_require__(\"./node_modules/@testing-library/dom/node_modules/pretty-format/build/plugins/ConvertAnsi.js\"));\n\nvar _DOMCollection = _interopRequireDefault(__webpack_require__(\"./node_modules/@testing-library/dom/node_modules/pretty-format/build/plugins/DOMCollection.js\"));\n\nvar _DOMElement = _interopRequireDefault(__webpack_require__(\"./node_modules/@testing-library/dom/node_modules/pretty-format/build/plugins/DOMElement.js\"));\n\nvar _Immutable = _interopRequireDefault(__webpack_require__(\"./node_modules/@testing-library/dom/node_modules/pretty-format/build/plugins/Immutable.js\"));\n\nvar _ReactElement = _interopRequireDefault(__webpack_require__(\"./node_modules/@testing-library/dom/node_modules/pretty-format/build/plugins/ReactElement.js\"));\n\nvar _ReactTestComponent = _interopRequireDefault(\n  __webpack_require__(\"./node_modules/@testing-library/dom/node_modules/pretty-format/build/plugins/ReactTestComponent.js\")\n);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* eslint-disable local/ban-types-eventually */\nconst toString = Object.prototype.toString;\nconst toISOString = Date.prototype.toISOString;\nconst errorToString = Error.prototype.toString;\nconst regExpToString = RegExp.prototype.toString;\n/**\n * Explicitly comparing typeof constructor to function avoids undefined as name\n * when mock identity-obj-proxy returns the key as the value for any key.\n */\n\nconst getConstructorName = val =>\n  (typeof val.constructor === 'function' && val.constructor.name) || 'Object';\n/* global window */\n\n/** Is val is equal to global window object? Works even if it does not exist :) */\n\nconst isWindow = val => typeof window !== 'undefined' && val === window;\n\nconst SYMBOL_REGEXP = /^Symbol\\((.*)\\)(.*)$/;\nconst NEWLINE_REGEXP = /\\n/gi;\n\nclass PrettyFormatPluginError extends Error {\n  constructor(message, stack) {\n    super(message);\n    this.stack = stack;\n    this.name = this.constructor.name;\n  }\n}\n\nfunction isToStringedArrayType(toStringed) {\n  return (\n    toStringed === '[object Array]' ||\n    toStringed === '[object ArrayBuffer]' ||\n    toStringed === '[object DataView]' ||\n    toStringed === '[object Float32Array]' ||\n    toStringed === '[object Float64Array]' ||\n    toStringed === '[object Int8Array]' ||\n    toStringed === '[object Int16Array]' ||\n    toStringed === '[object Int32Array]' ||\n    toStringed === '[object Uint8Array]' ||\n    toStringed === '[object Uint8ClampedArray]' ||\n    toStringed === '[object Uint16Array]' ||\n    toStringed === '[object Uint32Array]'\n  );\n}\n\nfunction printNumber(val) {\n  return Object.is(val, -0) ? '-0' : String(val);\n}\n\nfunction printBigInt(val) {\n  return String(`${val}n`);\n}\n\nfunction printFunction(val, printFunctionName) {\n  if (!printFunctionName) {\n    return '[Function]';\n  }\n\n  return '[Function ' + (val.name || 'anonymous') + ']';\n}\n\nfunction printSymbol(val) {\n  return String(val).replace(SYMBOL_REGEXP, 'Symbol($1)');\n}\n\nfunction printError(val) {\n  return '[' + errorToString.call(val) + ']';\n}\n/**\n * The first port of call for printing an object, handles most of the\n * data-types in JS.\n */\n\nfunction printBasicValue(val, printFunctionName, escapeRegex, escapeString) {\n  if (val === true || val === false) {\n    return '' + val;\n  }\n\n  if (val === undefined) {\n    return 'undefined';\n  }\n\n  if (val === null) {\n    return 'null';\n  }\n\n  const typeOf = typeof val;\n\n  if (typeOf === 'number') {\n    return printNumber(val);\n  }\n\n  if (typeOf === 'bigint') {\n    return printBigInt(val);\n  }\n\n  if (typeOf === 'string') {\n    if (escapeString) {\n      return '\"' + val.replace(/\"|\\\\/g, '\\\\$&') + '\"';\n    }\n\n    return '\"' + val + '\"';\n  }\n\n  if (typeOf === 'function') {\n    return printFunction(val, printFunctionName);\n  }\n\n  if (typeOf === 'symbol') {\n    return printSymbol(val);\n  }\n\n  const toStringed = toString.call(val);\n\n  if (toStringed === '[object WeakMap]') {\n    return 'WeakMap {}';\n  }\n\n  if (toStringed === '[object WeakSet]') {\n    return 'WeakSet {}';\n  }\n\n  if (\n    toStringed === '[object Function]' ||\n    toStringed === '[object GeneratorFunction]'\n  ) {\n    return printFunction(val, printFunctionName);\n  }\n\n  if (toStringed === '[object Symbol]') {\n    return printSymbol(val);\n  }\n\n  if (toStringed === '[object Date]') {\n    return isNaN(+val) ? 'Date { NaN }' : toISOString.call(val);\n  }\n\n  if (toStringed === '[object Error]') {\n    return printError(val);\n  }\n\n  if (toStringed === '[object RegExp]') {\n    if (escapeRegex) {\n      // https://github.com/benjamingr/RegExp.escape/blob/main/polyfill.js\n      return regExpToString.call(val).replace(/[\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n    }\n\n    return regExpToString.call(val);\n  }\n\n  if (val instanceof Error) {\n    return printError(val);\n  }\n\n  return null;\n}\n/**\n * Handles more complex objects ( such as objects with circular references.\n * maps and sets etc )\n */\n\nfunction printComplexValue(\n  val,\n  config,\n  indentation,\n  depth,\n  refs,\n  hasCalledToJSON\n) {\n  if (refs.indexOf(val) !== -1) {\n    return '[Circular]';\n  }\n\n  refs = refs.slice();\n  refs.push(val);\n  const hitMaxDepth = ++depth > config.maxDepth;\n  const min = config.min;\n\n  if (\n    config.callToJSON &&\n    !hitMaxDepth &&\n    val.toJSON &&\n    typeof val.toJSON === 'function' &&\n    !hasCalledToJSON\n  ) {\n    return printer(val.toJSON(), config, indentation, depth, refs, true);\n  }\n\n  const toStringed = toString.call(val);\n\n  if (toStringed === '[object Arguments]') {\n    return hitMaxDepth\n      ? '[Arguments]'\n      : (min ? '' : 'Arguments ') +\n          '[' +\n          (0, _collections.printListItems)(\n            val,\n            config,\n            indentation,\n            depth,\n            refs,\n            printer\n          ) +\n          ']';\n  }\n\n  if (isToStringedArrayType(toStringed)) {\n    return hitMaxDepth\n      ? '[' + val.constructor.name + ']'\n      : (min\n          ? ''\n          : !config.printBasicPrototype && val.constructor.name === 'Array'\n          ? ''\n          : val.constructor.name + ' ') +\n          '[' +\n          (0, _collections.printListItems)(\n            val,\n            config,\n            indentation,\n            depth,\n            refs,\n            printer\n          ) +\n          ']';\n  }\n\n  if (toStringed === '[object Map]') {\n    return hitMaxDepth\n      ? '[Map]'\n      : 'Map {' +\n          (0, _collections.printIteratorEntries)(\n            val.entries(),\n            config,\n            indentation,\n            depth,\n            refs,\n            printer,\n            ' => '\n          ) +\n          '}';\n  }\n\n  if (toStringed === '[object Set]') {\n    return hitMaxDepth\n      ? '[Set]'\n      : 'Set {' +\n          (0, _collections.printIteratorValues)(\n            val.values(),\n            config,\n            indentation,\n            depth,\n            refs,\n            printer\n          ) +\n          '}';\n  } // Avoid failure to serialize global window object in jsdom test environment.\n  // For example, not even relevant if window is prop of React element.\n\n  return hitMaxDepth || isWindow(val)\n    ? '[' + getConstructorName(val) + ']'\n    : (min\n        ? ''\n        : !config.printBasicPrototype && getConstructorName(val) === 'Object'\n        ? ''\n        : getConstructorName(val) + ' ') +\n        '{' +\n        (0, _collections.printObjectProperties)(\n          val,\n          config,\n          indentation,\n          depth,\n          refs,\n          printer\n        ) +\n        '}';\n}\n\nfunction isNewPlugin(plugin) {\n  return plugin.serialize != null;\n}\n\nfunction printPlugin(plugin, val, config, indentation, depth, refs) {\n  let printed;\n\n  try {\n    printed = isNewPlugin(plugin)\n      ? plugin.serialize(val, config, indentation, depth, refs, printer)\n      : plugin.print(\n          val,\n          valChild => printer(valChild, config, indentation, depth, refs),\n          str => {\n            const indentationNext = indentation + config.indent;\n            return (\n              indentationNext +\n              str.replace(NEWLINE_REGEXP, '\\n' + indentationNext)\n            );\n          },\n          {\n            edgeSpacing: config.spacingOuter,\n            min: config.min,\n            spacing: config.spacingInner\n          },\n          config.colors\n        );\n  } catch (error) {\n    throw new PrettyFormatPluginError(error.message, error.stack);\n  }\n\n  if (typeof printed !== 'string') {\n    throw new Error(\n      `pretty-format: Plugin must return type \"string\" but instead returned \"${typeof printed}\".`\n    );\n  }\n\n  return printed;\n}\n\nfunction findPlugin(plugins, val) {\n  for (let p = 0; p < plugins.length; p++) {\n    try {\n      if (plugins[p].test(val)) {\n        return plugins[p];\n      }\n    } catch (error) {\n      throw new PrettyFormatPluginError(error.message, error.stack);\n    }\n  }\n\n  return null;\n}\n\nfunction printer(val, config, indentation, depth, refs, hasCalledToJSON) {\n  const plugin = findPlugin(config.plugins, val);\n\n  if (plugin !== null) {\n    return printPlugin(plugin, val, config, indentation, depth, refs);\n  }\n\n  const basicResult = printBasicValue(\n    val,\n    config.printFunctionName,\n    config.escapeRegex,\n    config.escapeString\n  );\n\n  if (basicResult !== null) {\n    return basicResult;\n  }\n\n  return printComplexValue(\n    val,\n    config,\n    indentation,\n    depth,\n    refs,\n    hasCalledToJSON\n  );\n}\n\nconst DEFAULT_THEME = {\n  comment: 'gray',\n  content: 'reset',\n  prop: 'yellow',\n  tag: 'cyan',\n  value: 'green'\n};\nconst DEFAULT_THEME_KEYS = Object.keys(DEFAULT_THEME);\nconst DEFAULT_OPTIONS = {\n  callToJSON: true,\n  compareKeys: undefined,\n  escapeRegex: false,\n  escapeString: true,\n  highlight: false,\n  indent: 2,\n  maxDepth: Infinity,\n  min: false,\n  plugins: [],\n  printBasicPrototype: true,\n  printFunctionName: true,\n  theme: DEFAULT_THEME\n};\nexports.DEFAULT_OPTIONS = DEFAULT_OPTIONS;\n\nfunction validateOptions(options) {\n  Object.keys(options).forEach(key => {\n    if (!DEFAULT_OPTIONS.hasOwnProperty(key)) {\n      throw new Error(`pretty-format: Unknown option \"${key}\".`);\n    }\n  });\n\n  if (options.min && options.indent !== undefined && options.indent !== 0) {\n    throw new Error(\n      'pretty-format: Options \"min\" and \"indent\" cannot be used together.'\n    );\n  }\n\n  if (options.theme !== undefined) {\n    if (options.theme === null) {\n      throw new Error('pretty-format: Option \"theme\" must not be null.');\n    }\n\n    if (typeof options.theme !== 'object') {\n      throw new Error(\n        `pretty-format: Option \"theme\" must be of type \"object\" but instead received \"${typeof options.theme}\".`\n      );\n    }\n  }\n}\n\nconst getColorsHighlight = options =>\n  DEFAULT_THEME_KEYS.reduce((colors, key) => {\n    const value =\n      options.theme && options.theme[key] !== undefined\n        ? options.theme[key]\n        : DEFAULT_THEME[key];\n    const color = value && _ansiStyles.default[value];\n\n    if (\n      color &&\n      typeof color.close === 'string' &&\n      typeof color.open === 'string'\n    ) {\n      colors[key] = color;\n    } else {\n      throw new Error(\n        `pretty-format: Option \"theme\" has a key \"${key}\" whose value \"${value}\" is undefined in ansi-styles.`\n      );\n    }\n\n    return colors;\n  }, Object.create(null));\n\nconst getColorsEmpty = () =>\n  DEFAULT_THEME_KEYS.reduce((colors, key) => {\n    colors[key] = {\n      close: '',\n      open: ''\n    };\n    return colors;\n  }, Object.create(null));\n\nconst getPrintFunctionName = options =>\n  options && options.printFunctionName !== undefined\n    ? options.printFunctionName\n    : DEFAULT_OPTIONS.printFunctionName;\n\nconst getEscapeRegex = options =>\n  options && options.escapeRegex !== undefined\n    ? options.escapeRegex\n    : DEFAULT_OPTIONS.escapeRegex;\n\nconst getEscapeString = options =>\n  options && options.escapeString !== undefined\n    ? options.escapeString\n    : DEFAULT_OPTIONS.escapeString;\n\nconst getConfig = options => {\n  var _options$printBasicPr;\n\n  return {\n    callToJSON:\n      options && options.callToJSON !== undefined\n        ? options.callToJSON\n        : DEFAULT_OPTIONS.callToJSON,\n    colors:\n      options && options.highlight\n        ? getColorsHighlight(options)\n        : getColorsEmpty(),\n    compareKeys:\n      options && typeof options.compareKeys === 'function'\n        ? options.compareKeys\n        : DEFAULT_OPTIONS.compareKeys,\n    escapeRegex: getEscapeRegex(options),\n    escapeString: getEscapeString(options),\n    indent:\n      options && options.min\n        ? ''\n        : createIndent(\n            options && options.indent !== undefined\n              ? options.indent\n              : DEFAULT_OPTIONS.indent\n          ),\n    maxDepth:\n      options && options.maxDepth !== undefined\n        ? options.maxDepth\n        : DEFAULT_OPTIONS.maxDepth,\n    min:\n      options && options.min !== undefined ? options.min : DEFAULT_OPTIONS.min,\n    plugins:\n      options && options.plugins !== undefined\n        ? options.plugins\n        : DEFAULT_OPTIONS.plugins,\n    printBasicPrototype:\n      (_options$printBasicPr =\n        options === null || options === void 0\n          ? void 0\n          : options.printBasicPrototype) !== null &&\n      _options$printBasicPr !== void 0\n        ? _options$printBasicPr\n        : true,\n    printFunctionName: getPrintFunctionName(options),\n    spacingInner: options && options.min ? ' ' : '\\n',\n    spacingOuter: options && options.min ? '' : '\\n'\n  };\n};\n\nfunction createIndent(indent) {\n  return new Array(indent + 1).join(' ');\n}\n/**\n * Returns a presentation string of your `val` object\n * @param val any potential JavaScript object\n * @param options Custom settings\n */\n\nfunction format(val, options) {\n  if (options) {\n    validateOptions(options);\n\n    if (options.plugins) {\n      const plugin = findPlugin(options.plugins, val);\n\n      if (plugin !== null) {\n        return printPlugin(plugin, val, getConfig(options), '', 0, []);\n      }\n    }\n  }\n\n  const basicResult = printBasicValue(\n    val,\n    getPrintFunctionName(options),\n    getEscapeRegex(options),\n    getEscapeString(options)\n  );\n\n  if (basicResult !== null) {\n    return basicResult;\n  }\n\n  return printComplexValue(val, getConfig(options), '', 0, []);\n}\n\nconst plugins = {\n  AsymmetricMatcher: _AsymmetricMatcher.default,\n  ConvertAnsi: _ConvertAnsi.default,\n  DOMCollection: _DOMCollection.default,\n  DOMElement: _DOMElement.default,\n  Immutable: _Immutable.default,\n  ReactElement: _ReactElement.default,\n  ReactTestComponent: _ReactTestComponent.default\n};\nexports.plugins = plugins;\nvar _default = format;\nexports[\"default\"] = _default;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS9kb20vbm9kZV9tb2R1bGVzL3ByZXR0eS1mb3JtYXQvYnVpbGQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWUsR0FBRyx1QkFBdUI7QUFDekMsY0FBYztBQUNkLGVBQWU7O0FBRWYseUNBQXlDLG1CQUFPLENBQUMsdUVBQWE7O0FBRTlELG1CQUFtQixtQkFBTyxDQUFDLHFGQUFlOztBQUUxQztBQUNBLEVBQUUsbUJBQU8sQ0FBQyxtR0FBNkI7QUFDdkM7O0FBRUEsMENBQTBDLG1CQUFPLENBQUMsNkZBQXVCOztBQUV6RSw0Q0FBNEMsbUJBQU8sQ0FBQywrRkFBeUI7O0FBRTdFLHlDQUF5QyxtQkFBTyxDQUFDLDRGQUFzQjs7QUFFdkUsd0NBQXdDLG1CQUFPLENBQUMsMkZBQXFCOztBQUVyRSwyQ0FBMkMsbUJBQU8sQ0FBQyw4RkFBd0I7O0FBRTNFO0FBQ0EsRUFBRSxtQkFBTyxDQUFDLG9HQUE4QjtBQUN4Qzs7QUFFQTtBQUNBLHdDQUF3QztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixJQUFJO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxLQUFLO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtFQUErRSxlQUFlO0FBQzlGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxJQUFJO0FBQzVEO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3RkFBd0YscUJBQXFCO0FBQzdHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLG9EQUFvRCxJQUFJLGlCQUFpQixNQUFNO0FBQy9FO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0B0ZXN0aW5nLWxpYnJhcnkvZG9tL25vZGVfbW9kdWxlcy9wcmV0dHktZm9ybWF0L2J1aWxkL2luZGV4LmpzPzgwZDMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuREVGQVVMVF9PUFRJT05TID0gdm9pZCAwO1xuZXhwb3J0cy5mb3JtYXQgPSBmb3JtYXQ7XG5leHBvcnRzLnBsdWdpbnMgPSB2b2lkIDA7XG5cbnZhciBfYW5zaVN0eWxlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZSgnYW5zaS1zdHlsZXMnKSk7XG5cbnZhciBfY29sbGVjdGlvbnMgPSByZXF1aXJlKCcuL2NvbGxlY3Rpb25zJyk7XG5cbnZhciBfQXN5bW1ldHJpY01hdGNoZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KFxuICByZXF1aXJlKCcuL3BsdWdpbnMvQXN5bW1ldHJpY01hdGNoZXInKVxuKTtcblxudmFyIF9Db252ZXJ0QW5zaSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZSgnLi9wbHVnaW5zL0NvbnZlcnRBbnNpJykpO1xuXG52YXIgX0RPTUNvbGxlY3Rpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoJy4vcGx1Z2lucy9ET01Db2xsZWN0aW9uJykpO1xuXG52YXIgX0RPTUVsZW1lbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoJy4vcGx1Z2lucy9ET01FbGVtZW50JykpO1xuXG52YXIgX0ltbXV0YWJsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZSgnLi9wbHVnaW5zL0ltbXV0YWJsZScpKTtcblxudmFyIF9SZWFjdEVsZW1lbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoJy4vcGx1Z2lucy9SZWFjdEVsZW1lbnQnKSk7XG5cbnZhciBfUmVhY3RUZXN0Q29tcG9uZW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChcbiAgcmVxdWlyZSgnLi9wbHVnaW5zL1JlYWN0VGVzdENvbXBvbmVudCcpXG4pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge2RlZmF1bHQ6IG9ian07XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgbG9jYWwvYmFuLXR5cGVzLWV2ZW50dWFsbHkgKi9cbmNvbnN0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmNvbnN0IHRvSVNPU3RyaW5nID0gRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmc7XG5jb25zdCBlcnJvclRvU3RyaW5nID0gRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nO1xuY29uc3QgcmVnRXhwVG9TdHJpbmcgPSBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nO1xuLyoqXG4gKiBFeHBsaWNpdGx5IGNvbXBhcmluZyB0eXBlb2YgY29uc3RydWN0b3IgdG8gZnVuY3Rpb24gYXZvaWRzIHVuZGVmaW5lZCBhcyBuYW1lXG4gKiB3aGVuIG1vY2sgaWRlbnRpdHktb2JqLXByb3h5IHJldHVybnMgdGhlIGtleSBhcyB0aGUgdmFsdWUgZm9yIGFueSBrZXkuXG4gKi9cblxuY29uc3QgZ2V0Q29uc3RydWN0b3JOYW1lID0gdmFsID0+XG4gICh0eXBlb2YgdmFsLmNvbnN0cnVjdG9yID09PSAnZnVuY3Rpb24nICYmIHZhbC5jb25zdHJ1Y3Rvci5uYW1lKSB8fCAnT2JqZWN0Jztcbi8qIGdsb2JhbCB3aW5kb3cgKi9cblxuLyoqIElzIHZhbCBpcyBlcXVhbCB0byBnbG9iYWwgd2luZG93IG9iamVjdD8gV29ya3MgZXZlbiBpZiBpdCBkb2VzIG5vdCBleGlzdCA6KSAqL1xuXG5jb25zdCBpc1dpbmRvdyA9IHZhbCA9PiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB2YWwgPT09IHdpbmRvdztcblxuY29uc3QgU1lNQk9MX1JFR0VYUCA9IC9eU3ltYm9sXFwoKC4qKVxcKSguKikkLztcbmNvbnN0IE5FV0xJTkVfUkVHRVhQID0gL1xcbi9naTtcblxuY2xhc3MgUHJldHR5Rm9ybWF0UGx1Z2luRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YWNrKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5zdGFjayA9IHN0YWNrO1xuICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1RvU3RyaW5nZWRBcnJheVR5cGUodG9TdHJpbmdlZCkge1xuICByZXR1cm4gKFxuICAgIHRvU3RyaW5nZWQgPT09ICdbb2JqZWN0IEFycmF5XScgfHxcbiAgICB0b1N0cmluZ2VkID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nIHx8XG4gICAgdG9TdHJpbmdlZCA9PT0gJ1tvYmplY3QgRGF0YVZpZXddJyB8fFxuICAgIHRvU3RyaW5nZWQgPT09ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nIHx8XG4gICAgdG9TdHJpbmdlZCA9PT0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScgfHxcbiAgICB0b1N0cmluZ2VkID09PSAnW29iamVjdCBJbnQ4QXJyYXldJyB8fFxuICAgIHRvU3RyaW5nZWQgPT09ICdbb2JqZWN0IEludDE2QXJyYXldJyB8fFxuICAgIHRvU3RyaW5nZWQgPT09ICdbb2JqZWN0IEludDMyQXJyYXldJyB8fFxuICAgIHRvU3RyaW5nZWQgPT09ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyB8fFxuICAgIHRvU3RyaW5nZWQgPT09ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScgfHxcbiAgICB0b1N0cmluZ2VkID09PSAnW29iamVjdCBVaW50MTZBcnJheV0nIHx8XG4gICAgdG9TdHJpbmdlZCA9PT0gJ1tvYmplY3QgVWludDMyQXJyYXldJ1xuICApO1xufVxuXG5mdW5jdGlvbiBwcmludE51bWJlcih2YWwpIHtcbiAgcmV0dXJuIE9iamVjdC5pcyh2YWwsIC0wKSA/ICctMCcgOiBTdHJpbmcodmFsKTtcbn1cblxuZnVuY3Rpb24gcHJpbnRCaWdJbnQodmFsKSB7XG4gIHJldHVybiBTdHJpbmcoYCR7dmFsfW5gKTtcbn1cblxuZnVuY3Rpb24gcHJpbnRGdW5jdGlvbih2YWwsIHByaW50RnVuY3Rpb25OYW1lKSB7XG4gIGlmICghcHJpbnRGdW5jdGlvbk5hbWUpIHtcbiAgICByZXR1cm4gJ1tGdW5jdGlvbl0nO1xuICB9XG5cbiAgcmV0dXJuICdbRnVuY3Rpb24gJyArICh2YWwubmFtZSB8fCAnYW5vbnltb3VzJykgKyAnXSc7XG59XG5cbmZ1bmN0aW9uIHByaW50U3ltYm9sKHZhbCkge1xuICByZXR1cm4gU3RyaW5nKHZhbCkucmVwbGFjZShTWU1CT0xfUkVHRVhQLCAnU3ltYm9sKCQxKScpO1xufVxuXG5mdW5jdGlvbiBwcmludEVycm9yKHZhbCkge1xuICByZXR1cm4gJ1snICsgZXJyb3JUb1N0cmluZy5jYWxsKHZhbCkgKyAnXSc7XG59XG4vKipcbiAqIFRoZSBmaXJzdCBwb3J0IG9mIGNhbGwgZm9yIHByaW50aW5nIGFuIG9iamVjdCwgaGFuZGxlcyBtb3N0IG9mIHRoZVxuICogZGF0YS10eXBlcyBpbiBKUy5cbiAqL1xuXG5mdW5jdGlvbiBwcmludEJhc2ljVmFsdWUodmFsLCBwcmludEZ1bmN0aW9uTmFtZSwgZXNjYXBlUmVnZXgsIGVzY2FwZVN0cmluZykge1xuICBpZiAodmFsID09PSB0cnVlIHx8IHZhbCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gJycgKyB2YWw7XG4gIH1cblxuICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIH1cblxuICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgcmV0dXJuICdudWxsJztcbiAgfVxuXG4gIGNvbnN0IHR5cGVPZiA9IHR5cGVvZiB2YWw7XG5cbiAgaWYgKHR5cGVPZiA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gcHJpbnROdW1iZXIodmFsKTtcbiAgfVxuXG4gIGlmICh0eXBlT2YgPT09ICdiaWdpbnQnKSB7XG4gICAgcmV0dXJuIHByaW50QmlnSW50KHZhbCk7XG4gIH1cblxuICBpZiAodHlwZU9mID09PSAnc3RyaW5nJykge1xuICAgIGlmIChlc2NhcGVTdHJpbmcpIHtcbiAgICAgIHJldHVybiAnXCInICsgdmFsLnJlcGxhY2UoL1wifFxcXFwvZywgJ1xcXFwkJicpICsgJ1wiJztcbiAgICB9XG5cbiAgICByZXR1cm4gJ1wiJyArIHZhbCArICdcIic7XG4gIH1cblxuICBpZiAodHlwZU9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHByaW50RnVuY3Rpb24odmFsLCBwcmludEZ1bmN0aW9uTmFtZSk7XG4gIH1cblxuICBpZiAodHlwZU9mID09PSAnc3ltYm9sJykge1xuICAgIHJldHVybiBwcmludFN5bWJvbCh2YWwpO1xuICB9XG5cbiAgY29uc3QgdG9TdHJpbmdlZCA9IHRvU3RyaW5nLmNhbGwodmFsKTtcblxuICBpZiAodG9TdHJpbmdlZCA9PT0gJ1tvYmplY3QgV2Vha01hcF0nKSB7XG4gICAgcmV0dXJuICdXZWFrTWFwIHt9JztcbiAgfVxuXG4gIGlmICh0b1N0cmluZ2VkID09PSAnW29iamVjdCBXZWFrU2V0XScpIHtcbiAgICByZXR1cm4gJ1dlYWtTZXQge30nO1xuICB9XG5cbiAgaWYgKFxuICAgIHRvU3RyaW5nZWQgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScgfHxcbiAgICB0b1N0cmluZ2VkID09PSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nXG4gICkge1xuICAgIHJldHVybiBwcmludEZ1bmN0aW9uKHZhbCwgcHJpbnRGdW5jdGlvbk5hbWUpO1xuICB9XG5cbiAgaWYgKHRvU3RyaW5nZWQgPT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7XG4gICAgcmV0dXJuIHByaW50U3ltYm9sKHZhbCk7XG4gIH1cblxuICBpZiAodG9TdHJpbmdlZCA9PT0gJ1tvYmplY3QgRGF0ZV0nKSB7XG4gICAgcmV0dXJuIGlzTmFOKCt2YWwpID8gJ0RhdGUgeyBOYU4gfScgOiB0b0lTT1N0cmluZy5jYWxsKHZhbCk7XG4gIH1cblxuICBpZiAodG9TdHJpbmdlZCA9PT0gJ1tvYmplY3QgRXJyb3JdJykge1xuICAgIHJldHVybiBwcmludEVycm9yKHZhbCk7XG4gIH1cblxuICBpZiAodG9TdHJpbmdlZCA9PT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICBpZiAoZXNjYXBlUmVnZXgpIHtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZW5qYW1pbmdyL1JlZ0V4cC5lc2NhcGUvYmxvYi9tYWluL3BvbHlmaWxsLmpzXG4gICAgICByZXR1cm4gcmVnRXhwVG9TdHJpbmcuY2FsbCh2YWwpLnJlcGxhY2UoL1tcXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZ0V4cFRvU3RyaW5nLmNhbGwodmFsKTtcbiAgfVxuXG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiBwcmludEVycm9yKHZhbCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogSGFuZGxlcyBtb3JlIGNvbXBsZXggb2JqZWN0cyAoIHN1Y2ggYXMgb2JqZWN0cyB3aXRoIGNpcmN1bGFyIHJlZmVyZW5jZXMuXG4gKiBtYXBzIGFuZCBzZXRzIGV0YyApXG4gKi9cblxuZnVuY3Rpb24gcHJpbnRDb21wbGV4VmFsdWUoXG4gIHZhbCxcbiAgY29uZmlnLFxuICBpbmRlbnRhdGlvbixcbiAgZGVwdGgsXG4gIHJlZnMsXG4gIGhhc0NhbGxlZFRvSlNPTlxuKSB7XG4gIGlmIChyZWZzLmluZGV4T2YodmFsKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICB9XG5cbiAgcmVmcyA9IHJlZnMuc2xpY2UoKTtcbiAgcmVmcy5wdXNoKHZhbCk7XG4gIGNvbnN0IGhpdE1heERlcHRoID0gKytkZXB0aCA+IGNvbmZpZy5tYXhEZXB0aDtcbiAgY29uc3QgbWluID0gY29uZmlnLm1pbjtcblxuICBpZiAoXG4gICAgY29uZmlnLmNhbGxUb0pTT04gJiZcbiAgICAhaGl0TWF4RGVwdGggJiZcbiAgICB2YWwudG9KU09OICYmXG4gICAgdHlwZW9mIHZhbC50b0pTT04gPT09ICdmdW5jdGlvbicgJiZcbiAgICAhaGFzQ2FsbGVkVG9KU09OXG4gICkge1xuICAgIHJldHVybiBwcmludGVyKHZhbC50b0pTT04oKSwgY29uZmlnLCBpbmRlbnRhdGlvbiwgZGVwdGgsIHJlZnMsIHRydWUpO1xuICB9XG5cbiAgY29uc3QgdG9TdHJpbmdlZCA9IHRvU3RyaW5nLmNhbGwodmFsKTtcblxuICBpZiAodG9TdHJpbmdlZCA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXScpIHtcbiAgICByZXR1cm4gaGl0TWF4RGVwdGhcbiAgICAgID8gJ1tBcmd1bWVudHNdJ1xuICAgICAgOiAobWluID8gJycgOiAnQXJndW1lbnRzICcpICtcbiAgICAgICAgICAnWycgK1xuICAgICAgICAgICgwLCBfY29sbGVjdGlvbnMucHJpbnRMaXN0SXRlbXMpKFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgaW5kZW50YXRpb24sXG4gICAgICAgICAgICBkZXB0aCxcbiAgICAgICAgICAgIHJlZnMsXG4gICAgICAgICAgICBwcmludGVyXG4gICAgICAgICAgKSArXG4gICAgICAgICAgJ10nO1xuICB9XG5cbiAgaWYgKGlzVG9TdHJpbmdlZEFycmF5VHlwZSh0b1N0cmluZ2VkKSkge1xuICAgIHJldHVybiBoaXRNYXhEZXB0aFxuICAgICAgPyAnWycgKyB2YWwuY29uc3RydWN0b3IubmFtZSArICddJ1xuICAgICAgOiAobWluXG4gICAgICAgICAgPyAnJ1xuICAgICAgICAgIDogIWNvbmZpZy5wcmludEJhc2ljUHJvdG90eXBlICYmIHZhbC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXJyYXknXG4gICAgICAgICAgPyAnJ1xuICAgICAgICAgIDogdmFsLmNvbnN0cnVjdG9yLm5hbWUgKyAnICcpICtcbiAgICAgICAgICAnWycgK1xuICAgICAgICAgICgwLCBfY29sbGVjdGlvbnMucHJpbnRMaXN0SXRlbXMpKFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgaW5kZW50YXRpb24sXG4gICAgICAgICAgICBkZXB0aCxcbiAgICAgICAgICAgIHJlZnMsXG4gICAgICAgICAgICBwcmludGVyXG4gICAgICAgICAgKSArXG4gICAgICAgICAgJ10nO1xuICB9XG5cbiAgaWYgKHRvU3RyaW5nZWQgPT09ICdbb2JqZWN0IE1hcF0nKSB7XG4gICAgcmV0dXJuIGhpdE1heERlcHRoXG4gICAgICA/ICdbTWFwXSdcbiAgICAgIDogJ01hcCB7JyArXG4gICAgICAgICAgKDAsIF9jb2xsZWN0aW9ucy5wcmludEl0ZXJhdG9yRW50cmllcykoXG4gICAgICAgICAgICB2YWwuZW50cmllcygpLFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgaW5kZW50YXRpb24sXG4gICAgICAgICAgICBkZXB0aCxcbiAgICAgICAgICAgIHJlZnMsXG4gICAgICAgICAgICBwcmludGVyLFxuICAgICAgICAgICAgJyA9PiAnXG4gICAgICAgICAgKSArXG4gICAgICAgICAgJ30nO1xuICB9XG5cbiAgaWYgKHRvU3RyaW5nZWQgPT09ICdbb2JqZWN0IFNldF0nKSB7XG4gICAgcmV0dXJuIGhpdE1heERlcHRoXG4gICAgICA/ICdbU2V0XSdcbiAgICAgIDogJ1NldCB7JyArXG4gICAgICAgICAgKDAsIF9jb2xsZWN0aW9ucy5wcmludEl0ZXJhdG9yVmFsdWVzKShcbiAgICAgICAgICAgIHZhbC52YWx1ZXMoKSxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGluZGVudGF0aW9uLFxuICAgICAgICAgICAgZGVwdGgsXG4gICAgICAgICAgICByZWZzLFxuICAgICAgICAgICAgcHJpbnRlclxuICAgICAgICAgICkgK1xuICAgICAgICAgICd9JztcbiAgfSAvLyBBdm9pZCBmYWlsdXJlIHRvIHNlcmlhbGl6ZSBnbG9iYWwgd2luZG93IG9iamVjdCBpbiBqc2RvbSB0ZXN0IGVudmlyb25tZW50LlxuICAvLyBGb3IgZXhhbXBsZSwgbm90IGV2ZW4gcmVsZXZhbnQgaWYgd2luZG93IGlzIHByb3Agb2YgUmVhY3QgZWxlbWVudC5cblxuICByZXR1cm4gaGl0TWF4RGVwdGggfHwgaXNXaW5kb3codmFsKVxuICAgID8gJ1snICsgZ2V0Q29uc3RydWN0b3JOYW1lKHZhbCkgKyAnXSdcbiAgICA6IChtaW5cbiAgICAgICAgPyAnJ1xuICAgICAgICA6ICFjb25maWcucHJpbnRCYXNpY1Byb3RvdHlwZSAmJiBnZXRDb25zdHJ1Y3Rvck5hbWUodmFsKSA9PT0gJ09iamVjdCdcbiAgICAgICAgPyAnJ1xuICAgICAgICA6IGdldENvbnN0cnVjdG9yTmFtZSh2YWwpICsgJyAnKSArXG4gICAgICAgICd7JyArXG4gICAgICAgICgwLCBfY29sbGVjdGlvbnMucHJpbnRPYmplY3RQcm9wZXJ0aWVzKShcbiAgICAgICAgICB2YWwsXG4gICAgICAgICAgY29uZmlnLFxuICAgICAgICAgIGluZGVudGF0aW9uLFxuICAgICAgICAgIGRlcHRoLFxuICAgICAgICAgIHJlZnMsXG4gICAgICAgICAgcHJpbnRlclxuICAgICAgICApICtcbiAgICAgICAgJ30nO1xufVxuXG5mdW5jdGlvbiBpc05ld1BsdWdpbihwbHVnaW4pIHtcbiAgcmV0dXJuIHBsdWdpbi5zZXJpYWxpemUgIT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcHJpbnRQbHVnaW4ocGx1Z2luLCB2YWwsIGNvbmZpZywgaW5kZW50YXRpb24sIGRlcHRoLCByZWZzKSB7XG4gIGxldCBwcmludGVkO1xuXG4gIHRyeSB7XG4gICAgcHJpbnRlZCA9IGlzTmV3UGx1Z2luKHBsdWdpbilcbiAgICAgID8gcGx1Z2luLnNlcmlhbGl6ZSh2YWwsIGNvbmZpZywgaW5kZW50YXRpb24sIGRlcHRoLCByZWZzLCBwcmludGVyKVxuICAgICAgOiBwbHVnaW4ucHJpbnQoXG4gICAgICAgICAgdmFsLFxuICAgICAgICAgIHZhbENoaWxkID0+IHByaW50ZXIodmFsQ2hpbGQsIGNvbmZpZywgaW5kZW50YXRpb24sIGRlcHRoLCByZWZzKSxcbiAgICAgICAgICBzdHIgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZW50YXRpb25OZXh0ID0gaW5kZW50YXRpb24gKyBjb25maWcuaW5kZW50O1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgaW5kZW50YXRpb25OZXh0ICtcbiAgICAgICAgICAgICAgc3RyLnJlcGxhY2UoTkVXTElORV9SRUdFWFAsICdcXG4nICsgaW5kZW50YXRpb25OZXh0KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVkZ2VTcGFjaW5nOiBjb25maWcuc3BhY2luZ091dGVyLFxuICAgICAgICAgICAgbWluOiBjb25maWcubWluLFxuICAgICAgICAgICAgc3BhY2luZzogY29uZmlnLnNwYWNpbmdJbm5lclxuICAgICAgICAgIH0sXG4gICAgICAgICAgY29uZmlnLmNvbG9yc1xuICAgICAgICApO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBQcmV0dHlGb3JtYXRQbHVnaW5FcnJvcihlcnJvci5tZXNzYWdlLCBlcnJvci5zdGFjayk7XG4gIH1cblxuICBpZiAodHlwZW9mIHByaW50ZWQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYHByZXR0eS1mb3JtYXQ6IFBsdWdpbiBtdXN0IHJldHVybiB0eXBlIFwic3RyaW5nXCIgYnV0IGluc3RlYWQgcmV0dXJuZWQgXCIke3R5cGVvZiBwcmludGVkfVwiLmBcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHByaW50ZWQ7XG59XG5cbmZ1bmN0aW9uIGZpbmRQbHVnaW4ocGx1Z2lucywgdmFsKSB7XG4gIGZvciAobGV0IHAgPSAwOyBwIDwgcGx1Z2lucy5sZW5ndGg7IHArKykge1xuICAgIHRyeSB7XG4gICAgICBpZiAocGx1Z2luc1twXS50ZXN0KHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIHBsdWdpbnNbcF07XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBQcmV0dHlGb3JtYXRQbHVnaW5FcnJvcihlcnJvci5tZXNzYWdlLCBlcnJvci5zdGFjayk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHByaW50ZXIodmFsLCBjb25maWcsIGluZGVudGF0aW9uLCBkZXB0aCwgcmVmcywgaGFzQ2FsbGVkVG9KU09OKSB7XG4gIGNvbnN0IHBsdWdpbiA9IGZpbmRQbHVnaW4oY29uZmlnLnBsdWdpbnMsIHZhbCk7XG5cbiAgaWYgKHBsdWdpbiAhPT0gbnVsbCkge1xuICAgIHJldHVybiBwcmludFBsdWdpbihwbHVnaW4sIHZhbCwgY29uZmlnLCBpbmRlbnRhdGlvbiwgZGVwdGgsIHJlZnMpO1xuICB9XG5cbiAgY29uc3QgYmFzaWNSZXN1bHQgPSBwcmludEJhc2ljVmFsdWUoXG4gICAgdmFsLFxuICAgIGNvbmZpZy5wcmludEZ1bmN0aW9uTmFtZSxcbiAgICBjb25maWcuZXNjYXBlUmVnZXgsXG4gICAgY29uZmlnLmVzY2FwZVN0cmluZ1xuICApO1xuXG4gIGlmIChiYXNpY1Jlc3VsdCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBiYXNpY1Jlc3VsdDtcbiAgfVxuXG4gIHJldHVybiBwcmludENvbXBsZXhWYWx1ZShcbiAgICB2YWwsXG4gICAgY29uZmlnLFxuICAgIGluZGVudGF0aW9uLFxuICAgIGRlcHRoLFxuICAgIHJlZnMsXG4gICAgaGFzQ2FsbGVkVG9KU09OXG4gICk7XG59XG5cbmNvbnN0IERFRkFVTFRfVEhFTUUgPSB7XG4gIGNvbW1lbnQ6ICdncmF5JyxcbiAgY29udGVudDogJ3Jlc2V0JyxcbiAgcHJvcDogJ3llbGxvdycsXG4gIHRhZzogJ2N5YW4nLFxuICB2YWx1ZTogJ2dyZWVuJ1xufTtcbmNvbnN0IERFRkFVTFRfVEhFTUVfS0VZUyA9IE9iamVjdC5rZXlzKERFRkFVTFRfVEhFTUUpO1xuY29uc3QgREVGQVVMVF9PUFRJT05TID0ge1xuICBjYWxsVG9KU09OOiB0cnVlLFxuICBjb21wYXJlS2V5czogdW5kZWZpbmVkLFxuICBlc2NhcGVSZWdleDogZmFsc2UsXG4gIGVzY2FwZVN0cmluZzogdHJ1ZSxcbiAgaGlnaGxpZ2h0OiBmYWxzZSxcbiAgaW5kZW50OiAyLFxuICBtYXhEZXB0aDogSW5maW5pdHksXG4gIG1pbjogZmFsc2UsXG4gIHBsdWdpbnM6IFtdLFxuICBwcmludEJhc2ljUHJvdG90eXBlOiB0cnVlLFxuICBwcmludEZ1bmN0aW9uTmFtZTogdHJ1ZSxcbiAgdGhlbWU6IERFRkFVTFRfVEhFTUVcbn07XG5leHBvcnRzLkRFRkFVTFRfT1BUSU9OUyA9IERFRkFVTFRfT1BUSU9OUztcblxuZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xuICAgIGlmICghREVGQVVMVF9PUFRJT05TLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgcHJldHR5LWZvcm1hdDogVW5rbm93biBvcHRpb24gXCIke2tleX1cIi5gKTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChvcHRpb25zLm1pbiAmJiBvcHRpb25zLmluZGVudCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuaW5kZW50ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ3ByZXR0eS1mb3JtYXQ6IE9wdGlvbnMgXCJtaW5cIiBhbmQgXCJpbmRlbnRcIiBjYW5ub3QgYmUgdXNlZCB0b2dldGhlci4nXG4gICAgKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnRoZW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAob3B0aW9ucy50aGVtZSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcmV0dHktZm9ybWF0OiBPcHRpb24gXCJ0aGVtZVwiIG11c3Qgbm90IGJlIG51bGwuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRoZW1lICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgcHJldHR5LWZvcm1hdDogT3B0aW9uIFwidGhlbWVcIiBtdXN0IGJlIG9mIHR5cGUgXCJvYmplY3RcIiBidXQgaW5zdGVhZCByZWNlaXZlZCBcIiR7dHlwZW9mIG9wdGlvbnMudGhlbWV9XCIuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgZ2V0Q29sb3JzSGlnaGxpZ2h0ID0gb3B0aW9ucyA9PlxuICBERUZBVUxUX1RIRU1FX0tFWVMucmVkdWNlKChjb2xvcnMsIGtleSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID1cbiAgICAgIG9wdGlvbnMudGhlbWUgJiYgb3B0aW9ucy50aGVtZVtrZXldICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLnRoZW1lW2tleV1cbiAgICAgICAgOiBERUZBVUxUX1RIRU1FW2tleV07XG4gICAgY29uc3QgY29sb3IgPSB2YWx1ZSAmJiBfYW5zaVN0eWxlcy5kZWZhdWx0W3ZhbHVlXTtcblxuICAgIGlmIChcbiAgICAgIGNvbG9yICYmXG4gICAgICB0eXBlb2YgY29sb3IuY2xvc2UgPT09ICdzdHJpbmcnICYmXG4gICAgICB0eXBlb2YgY29sb3Iub3BlbiA9PT0gJ3N0cmluZydcbiAgICApIHtcbiAgICAgIGNvbG9yc1trZXldID0gY29sb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYHByZXR0eS1mb3JtYXQ6IE9wdGlvbiBcInRoZW1lXCIgaGFzIGEga2V5IFwiJHtrZXl9XCIgd2hvc2UgdmFsdWUgXCIke3ZhbHVlfVwiIGlzIHVuZGVmaW5lZCBpbiBhbnNpLXN0eWxlcy5gXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBjb2xvcnM7XG4gIH0sIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXG5jb25zdCBnZXRDb2xvcnNFbXB0eSA9ICgpID0+XG4gIERFRkFVTFRfVEhFTUVfS0VZUy5yZWR1Y2UoKGNvbG9ycywga2V5KSA9PiB7XG4gICAgY29sb3JzW2tleV0gPSB7XG4gICAgICBjbG9zZTogJycsXG4gICAgICBvcGVuOiAnJ1xuICAgIH07XG4gICAgcmV0dXJuIGNvbG9ycztcbiAgfSwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cbmNvbnN0IGdldFByaW50RnVuY3Rpb25OYW1lID0gb3B0aW9ucyA9PlxuICBvcHRpb25zICYmIG9wdGlvbnMucHJpbnRGdW5jdGlvbk5hbWUgIT09IHVuZGVmaW5lZFxuICAgID8gb3B0aW9ucy5wcmludEZ1bmN0aW9uTmFtZVxuICAgIDogREVGQVVMVF9PUFRJT05TLnByaW50RnVuY3Rpb25OYW1lO1xuXG5jb25zdCBnZXRFc2NhcGVSZWdleCA9IG9wdGlvbnMgPT5cbiAgb3B0aW9ucyAmJiBvcHRpb25zLmVzY2FwZVJlZ2V4ICE9PSB1bmRlZmluZWRcbiAgICA/IG9wdGlvbnMuZXNjYXBlUmVnZXhcbiAgICA6IERFRkFVTFRfT1BUSU9OUy5lc2NhcGVSZWdleDtcblxuY29uc3QgZ2V0RXNjYXBlU3RyaW5nID0gb3B0aW9ucyA9PlxuICBvcHRpb25zICYmIG9wdGlvbnMuZXNjYXBlU3RyaW5nICE9PSB1bmRlZmluZWRcbiAgICA/IG9wdGlvbnMuZXNjYXBlU3RyaW5nXG4gICAgOiBERUZBVUxUX09QVElPTlMuZXNjYXBlU3RyaW5nO1xuXG5jb25zdCBnZXRDb25maWcgPSBvcHRpb25zID0+IHtcbiAgdmFyIF9vcHRpb25zJHByaW50QmFzaWNQcjtcblxuICByZXR1cm4ge1xuICAgIGNhbGxUb0pTT046XG4gICAgICBvcHRpb25zICYmIG9wdGlvbnMuY2FsbFRvSlNPTiAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy5jYWxsVG9KU09OXG4gICAgICAgIDogREVGQVVMVF9PUFRJT05TLmNhbGxUb0pTT04sXG4gICAgY29sb3JzOlxuICAgICAgb3B0aW9ucyAmJiBvcHRpb25zLmhpZ2hsaWdodFxuICAgICAgICA/IGdldENvbG9yc0hpZ2hsaWdodChvcHRpb25zKVxuICAgICAgICA6IGdldENvbG9yc0VtcHR5KCksXG4gICAgY29tcGFyZUtleXM6XG4gICAgICBvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLmNvbXBhcmVLZXlzID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gb3B0aW9ucy5jb21wYXJlS2V5c1xuICAgICAgICA6IERFRkFVTFRfT1BUSU9OUy5jb21wYXJlS2V5cyxcbiAgICBlc2NhcGVSZWdleDogZ2V0RXNjYXBlUmVnZXgob3B0aW9ucyksXG4gICAgZXNjYXBlU3RyaW5nOiBnZXRFc2NhcGVTdHJpbmcob3B0aW9ucyksXG4gICAgaW5kZW50OlxuICAgICAgb3B0aW9ucyAmJiBvcHRpb25zLm1pblxuICAgICAgICA/ICcnXG4gICAgICAgIDogY3JlYXRlSW5kZW50KFxuICAgICAgICAgICAgb3B0aW9ucyAmJiBvcHRpb25zLmluZGVudCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gb3B0aW9ucy5pbmRlbnRcbiAgICAgICAgICAgICAgOiBERUZBVUxUX09QVElPTlMuaW5kZW50XG4gICAgICAgICAgKSxcbiAgICBtYXhEZXB0aDpcbiAgICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5tYXhEZXB0aCAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy5tYXhEZXB0aFxuICAgICAgICA6IERFRkFVTFRfT1BUSU9OUy5tYXhEZXB0aCxcbiAgICBtaW46XG4gICAgICBvcHRpb25zICYmIG9wdGlvbnMubWluICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1pbiA6IERFRkFVTFRfT1BUSU9OUy5taW4sXG4gICAgcGx1Z2luczpcbiAgICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5wbHVnaW5zICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLnBsdWdpbnNcbiAgICAgICAgOiBERUZBVUxUX09QVElPTlMucGx1Z2lucyxcbiAgICBwcmludEJhc2ljUHJvdG90eXBlOlxuICAgICAgKF9vcHRpb25zJHByaW50QmFzaWNQciA9XG4gICAgICAgIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwXG4gICAgICAgICAgPyB2b2lkIDBcbiAgICAgICAgICA6IG9wdGlvbnMucHJpbnRCYXNpY1Byb3RvdHlwZSkgIT09IG51bGwgJiZcbiAgICAgIF9vcHRpb25zJHByaW50QmFzaWNQciAhPT0gdm9pZCAwXG4gICAgICAgID8gX29wdGlvbnMkcHJpbnRCYXNpY1ByXG4gICAgICAgIDogdHJ1ZSxcbiAgICBwcmludEZ1bmN0aW9uTmFtZTogZ2V0UHJpbnRGdW5jdGlvbk5hbWUob3B0aW9ucyksXG4gICAgc3BhY2luZ0lubmVyOiBvcHRpb25zICYmIG9wdGlvbnMubWluID8gJyAnIDogJ1xcbicsXG4gICAgc3BhY2luZ091dGVyOiBvcHRpb25zICYmIG9wdGlvbnMubWluID8gJycgOiAnXFxuJ1xuICB9O1xufTtcblxuZnVuY3Rpb24gY3JlYXRlSW5kZW50KGluZGVudCkge1xuICByZXR1cm4gbmV3IEFycmF5KGluZGVudCArIDEpLmpvaW4oJyAnKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHByZXNlbnRhdGlvbiBzdHJpbmcgb2YgeW91ciBgdmFsYCBvYmplY3RcbiAqIEBwYXJhbSB2YWwgYW55IHBvdGVudGlhbCBKYXZhU2NyaXB0IG9iamVjdFxuICogQHBhcmFtIG9wdGlvbnMgQ3VzdG9tIHNldHRpbmdzXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0KHZhbCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucykge1xuICAgIHZhbGlkYXRlT3B0aW9ucyhvcHRpb25zKTtcblxuICAgIGlmIChvcHRpb25zLnBsdWdpbnMpIHtcbiAgICAgIGNvbnN0IHBsdWdpbiA9IGZpbmRQbHVnaW4ob3B0aW9ucy5wbHVnaW5zLCB2YWwpO1xuXG4gICAgICBpZiAocGx1Z2luICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBwcmludFBsdWdpbihwbHVnaW4sIHZhbCwgZ2V0Q29uZmlnKG9wdGlvbnMpLCAnJywgMCwgW10pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGJhc2ljUmVzdWx0ID0gcHJpbnRCYXNpY1ZhbHVlKFxuICAgIHZhbCxcbiAgICBnZXRQcmludEZ1bmN0aW9uTmFtZShvcHRpb25zKSxcbiAgICBnZXRFc2NhcGVSZWdleChvcHRpb25zKSxcbiAgICBnZXRFc2NhcGVTdHJpbmcob3B0aW9ucylcbiAgKTtcblxuICBpZiAoYmFzaWNSZXN1bHQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gYmFzaWNSZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gcHJpbnRDb21wbGV4VmFsdWUodmFsLCBnZXRDb25maWcob3B0aW9ucyksICcnLCAwLCBbXSk7XG59XG5cbmNvbnN0IHBsdWdpbnMgPSB7XG4gIEFzeW1tZXRyaWNNYXRjaGVyOiBfQXN5bW1ldHJpY01hdGNoZXIuZGVmYXVsdCxcbiAgQ29udmVydEFuc2k6IF9Db252ZXJ0QW5zaS5kZWZhdWx0LFxuICBET01Db2xsZWN0aW9uOiBfRE9NQ29sbGVjdGlvbi5kZWZhdWx0LFxuICBET01FbGVtZW50OiBfRE9NRWxlbWVudC5kZWZhdWx0LFxuICBJbW11dGFibGU6IF9JbW11dGFibGUuZGVmYXVsdCxcbiAgUmVhY3RFbGVtZW50OiBfUmVhY3RFbGVtZW50LmRlZmF1bHQsXG4gIFJlYWN0VGVzdENvbXBvbmVudDogX1JlYWN0VGVzdENvbXBvbmVudC5kZWZhdWx0XG59O1xuZXhwb3J0cy5wbHVnaW5zID0gcGx1Z2lucztcbnZhciBfZGVmYXVsdCA9IGZvcm1hdDtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@testing-library/dom/node_modules/pretty-format/build/index.js\n")},"./node_modules/lodash/omit.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var arrayMap = __webpack_require__(\"./node_modules/lodash/_arrayMap.js\"),\n    baseClone = __webpack_require__(\"./node_modules/lodash/_baseClone.js\"),\n    baseUnset = __webpack_require__(\"./node_modules/lodash/_baseUnset.js\"),\n    castPath = __webpack_require__(\"./node_modules/lodash/_castPath.js\"),\n    copyObject = __webpack_require__(\"./node_modules/lodash/_copyObject.js\"),\n    customOmitClone = __webpack_require__(\"./node_modules/lodash/_customOmitClone.js\"),\n    flatRest = __webpack_require__(\"./node_modules/lodash/_flatRest.js\"),\n    getAllKeysIn = __webpack_require__(\"./node_modules/lodash/_getAllKeysIn.js\");\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * The opposite of `_.pick`; this method creates an object composed of the\n * own and inherited enumerable property paths of `object` that are not omitted.\n *\n * **Note:** This method is considerably slower than `_.pick`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The source object.\n * @param {...(string|string[])} [paths] The property paths to omit.\n * @returns {Object} Returns the new object.\n * @example\n *\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\n *\n * _.omit(object, ['a', 'c']);\n * // => { 'b': '2' }\n */\nvar omit = flatRest(function(object, paths) {\n  var result = {};\n  if (object == null) {\n    return result;\n  }\n  var isDeep = false;\n  paths = arrayMap(paths, function(path) {\n    path = castPath(path, object);\n    isDeep || (isDeep = path.length > 1);\n    return path;\n  });\n  copyObject(object, getAllKeysIn(object), result);\n  if (isDeep) {\n    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);\n  }\n  var length = paths.length;\n  while (length--) {\n    baseUnset(result, paths[length]);\n  }\n  return result;\n});\n\nmodule.exports = omit;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL29taXQuanMiLCJtYXBwaW5ncyI6IkFBQUEsZUFBZSxtQkFBTyxDQUFDLG9DQUFhO0FBQ3BDLGdCQUFnQixtQkFBTyxDQUFDLHFDQUFjO0FBQ3RDLGdCQUFnQixtQkFBTyxDQUFDLHFDQUFjO0FBQ3RDLGVBQWUsbUJBQU8sQ0FBQyxvQ0FBYTtBQUNwQyxpQkFBaUIsbUJBQU8sQ0FBQyxzQ0FBZTtBQUN4QyxzQkFBc0IsbUJBQU8sQ0FBQywyQ0FBb0I7QUFDbEQsZUFBZSxtQkFBTyxDQUFDLG9DQUFhO0FBQ3BDLG1CQUFtQixtQkFBTyxDQUFDLHdDQUFpQjs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHNCQUFzQjtBQUNqQyxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL2xlYWZ5Z3JlZW4tdWkvLi9ub2RlX21vZHVsZXMvbG9kYXNoL29taXQuanM/M2VlYSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGJhc2VDbG9uZSA9IHJlcXVpcmUoJy4vX2Jhc2VDbG9uZScpLFxuICAgIGJhc2VVbnNldCA9IHJlcXVpcmUoJy4vX2Jhc2VVbnNldCcpLFxuICAgIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGN1c3RvbU9taXRDbG9uZSA9IHJlcXVpcmUoJy4vX2N1c3RvbU9taXRDbG9uZScpLFxuICAgIGZsYXRSZXN0ID0gcmVxdWlyZSgnLi9fZmxhdFJlc3QnKSxcbiAgICBnZXRBbGxLZXlzSW4gPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzSW4nKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgIENMT05FX0ZMQVRfRkxBRyA9IDIsXG4gICAgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuLyoqXG4gKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucGlja2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZVxuICogb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBwYXRocyBvZiBgb2JqZWN0YCB0aGF0IGFyZSBub3Qgb21pdHRlZC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgY29uc2lkZXJhYmx5IHNsb3dlciB0aGFuIGBfLnBpY2tgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBvbWl0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gKlxuICogXy5vbWl0KG9iamVjdCwgWydhJywgJ2MnXSk7XG4gKiAvLyA9PiB7ICdiJzogJzInIH1cbiAqL1xudmFyIG9taXQgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB2YXIgaXNEZWVwID0gZmFsc2U7XG4gIHBhdGhzID0gYXJyYXlNYXAocGF0aHMsIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICBpc0RlZXAgfHwgKGlzRGVlcCA9IHBhdGgubGVuZ3RoID4gMSk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH0pO1xuICBjb3B5T2JqZWN0KG9iamVjdCwgZ2V0QWxsS2V5c0luKG9iamVjdCksIHJlc3VsdCk7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXN1bHQgPSBiYXNlQ2xvbmUocmVzdWx0LCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9GTEFUX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbU9taXRDbG9uZSk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IHBhdGhzLmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgYmFzZVVuc2V0KHJlc3VsdCwgcGF0aHNbbGVuZ3RoXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG9taXQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lodash/omit.js\n")},"./node_modules/lodash/pick.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var basePick = __webpack_require__(\"./node_modules/lodash/_basePick.js\"),\n    flatRest = __webpack_require__(\"./node_modules/lodash/_flatRest.js\");\n\n/**\n * Creates an object composed of the picked `object` properties.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The source object.\n * @param {...(string|string[])} [paths] The property paths to pick.\n * @returns {Object} Returns the new object.\n * @example\n *\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\n *\n * _.pick(object, ['a', 'c']);\n * // => { 'a': 1, 'c': 3 }\n */\nvar pick = flatRest(function(object, paths) {\n  return object == null ? {} : basePick(object, paths);\n});\n\nmodule.exports = pick;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL3BpY2suanMiLCJtYXBwaW5ncyI6IkFBQUEsZUFBZSxtQkFBTyxDQUFDLG9DQUFhO0FBQ3BDLGVBQWUsbUJBQU8sQ0FBQyxvQ0FBYTs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxzQkFBc0I7QUFDakMsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9waWNrLmpzPzI1OTMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGJhc2VQaWNrID0gcmVxdWlyZSgnLi9fYmFzZVBpY2snKSxcbiAgICBmbGF0UmVzdCA9IHJlcXVpcmUoJy4vX2ZsYXRSZXN0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBgb2JqZWN0YCBwcm9wZXJ0aWVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gKlxuICogXy5waWNrKG9iamVjdCwgWydhJywgJ2MnXSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAqL1xudmFyIHBpY2sgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHt9IDogYmFzZVBpY2sob2JqZWN0LCBwYXRocyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwaWNrO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lodash/pick.js\n")}}]);