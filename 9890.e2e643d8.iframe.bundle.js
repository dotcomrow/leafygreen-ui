(self.webpackChunkleafygreen_ui=self.webpackChunkleafygreen_ui||[]).push([[9890],{"./node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Z: () => (/* binding */ _objectDestructuringEmpty)\n/* harmony export */ });\nfunction _objectDestructuringEmpty(obj) {\n  if (obj == null) throw new TypeError("Cannot destructure " + obj);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0RGVzdHJ1Y3R1cmluZ0VtcHR5LmpzIiwibWFwcGluZ3MiOiI7OztBQUFlO0FBQ2Y7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlYWZ5Z3JlZW4tdWkvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0RGVzdHJ1Y3R1cmluZ0VtcHR5LmpzPzg0NjgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX29iamVjdERlc3RydWN0dXJpbmdFbXB0eShvYmopIHtcbiAgaWYgKG9iaiA9PSBudWxsKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGRlc3RydWN0dXJlIFwiICsgb2JqKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty.js\n')},"./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  Z: () => (/* binding */ _toConsumableArray)\n});\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js\nvar arrayLikeToArray = __webpack_require__("./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return (0,arrayLikeToArray/* default */.Z)(arr);\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);\n}\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js\nvar unsupportedIterableToArray = __webpack_require__("./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js");\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js\nfunction _nonIterableSpread() {\n  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\n\n\n\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || (0,unsupportedIterableToArray/* default */.Z)(arr) || _nonIterableSpread();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXFEO0FBQ3RDO0FBQ2YsaUNBQWlDLG1DQUFnQjtBQUNqRCxDOztBQ0hlO0FBQ2Y7QUFDQSxDOzs7O0FDRmU7QUFDZjtBQUNBLEM7O0FDRnVEO0FBQ0o7QUFDc0I7QUFDbEI7QUFDeEM7QUFDZixTQUFTLGtCQUFpQixTQUFTLGdCQUFlLFNBQVMsNkNBQTBCLFNBQVMsa0JBQWlCO0FBQy9HIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVhZnlncmVlbi11aS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheVdpdGhvdXRIb2xlcy5qcz82MDA1Iiwid2VicGFjazovL2xlYWZ5Z3JlZW4tdWkvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaXRlcmFibGVUb0FycmF5LmpzP2RiOTAiLCJ3ZWJwYWNrOi8vbGVhZnlncmVlbi11aS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9ub25JdGVyYWJsZVNwcmVhZC5qcz8zNDI3Iiwid2VicGFjazovL2xlYWZ5Z3JlZW4tdWkvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXkuanM/MjkwOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXJyYXlMaWtlVG9BcnJheSBmcm9tIFwiLi9hcnJheUxpa2VUb0FycmF5LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KGFycik7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59IiwiaW1wb3J0IGFycmF5V2l0aG91dEhvbGVzIGZyb20gXCIuL2FycmF5V2l0aG91dEhvbGVzLmpzXCI7XG5pbXBvcnQgaXRlcmFibGVUb0FycmF5IGZyb20gXCIuL2l0ZXJhYmxlVG9BcnJheS5qc1wiO1xuaW1wb3J0IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IGZyb20gXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzXCI7XG5pbXBvcnQgbm9uSXRlcmFibGVTcHJlYWQgZnJvbSBcIi4vbm9uSXRlcmFibGVTcHJlYWQuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aG91dEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5KGFycikgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub25JdGVyYWJsZVNwcmVhZCgpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\n')},"./node_modules/@storybook/testing-library/dist/index.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  mV: () => (/* binding */ dist_userEvent),\n  uh: () => (/* binding */ within)\n});\n\n// UNUSED EXPORTS: buildQueries, configure, createEvent, findAllByAltText, findAllByDisplayValue, findAllByLabelText, findAllByPlaceholderText, findAllByRole, findAllByTestId, findAllByText, findAllByTitle, findByAltText, findByDisplayValue, findByLabelText, findByPlaceholderText, findByRole, findByTestId, findByText, findByTitle, fireEvent, getAllByAltText, getAllByDisplayValue, getAllByLabelText, getAllByPlaceholderText, getAllByRole, getAllByTestId, getAllByText, getAllByTitle, getByAltText, getByDisplayValue, getByLabelText, getByPlaceholderText, getByRole, getByTestId, getByText, getByTitle, getConfig, getDefaultNormalizer, getElementError, getNodeText, getQueriesForElement, getRoles, getSuggestedQuery, isInaccessible, logDOM, logRoles, prettyDOM, prettyFormat, queries, queryAllByAltText, queryAllByAttribute, queryAllByDisplayValue, queryAllByLabelText, queryAllByPlaceholderText, queryAllByRole, queryAllByTestId, queryAllByText, queryAllByTitle, queryByAltText, queryByAttribute, queryByDisplayValue, queryByLabelText, queryByPlaceholderText, queryByRole, queryByTestId, queryByText, queryByTitle, queryHelpers, screen, waitFor, waitForElementToBeRemoved\n\n// NAMESPACE OBJECT: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/setup/api.js\nvar api_namespaceObject = {};\n__webpack_require__.r(api_namespaceObject);\n__webpack_require__.d(api_namespaceObject, {\n  clear: () => (clear),\n  click: () => (click),\n  copy: () => (copy),\n  cut: () => (cut),\n  dblClick: () => (dblClick),\n  deselectOptions: () => (deselectOptions),\n  hover: () => (hover),\n  keyboard: () => (keyboard),\n  paste: () => (paste),\n  pointer: () => (pointer),\n  selectOptions: () => (selectOptions),\n  tab: () => (tab),\n  tripleClick: () => (tripleClick),\n  type: () => (type),\n  unhover: () => (unhover),\n  upload: () => (upload)\n});\n\n// NAMESPACE OBJECT: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/setup/directApi.js\nvar directApi_namespaceObject = {};\n__webpack_require__.r(directApi_namespaceObject);\n__webpack_require__.d(directApi_namespaceObject, {\n  clear: () => (directApi_clear),\n  click: () => (directApi_click),\n  copy: () => (directApi_copy),\n  cut: () => (directApi_cut),\n  dblClick: () => (directApi_dblClick),\n  deselectOptions: () => (directApi_deselectOptions),\n  hover: () => (directApi_hover),\n  keyboard: () => (directApi_keyboard),\n  paste: () => (directApi_paste),\n  pointer: () => (directApi_pointer),\n  selectOptions: () => (directApi_selectOptions),\n  tab: () => (directApi_tab),\n  tripleClick: () => (directApi_tripleClick),\n  type: () => (directApi_type),\n  unhover: () => (directApi_unhover),\n  upload: () => (directApi_upload)\n});\n\n// EXTERNAL MODULE: ./node_modules/@testing-library/dom/dist/@testing-library/dom.esm.js\nvar dom_esm = __webpack_require__(\"./node_modules/@testing-library/dom/dist/@testing-library/dom.esm.js\");\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/utils/misc/isElementType.js\nfunction isElementType(element, tag, props) {\n    if (element.namespaceURI && element.namespaceURI !== 'http://www.w3.org/1999/xhtml') {\n        return false;\n    }\n    tag = Array.isArray(tag) ? tag : [\n        tag\n    ];\n    // tagName is uppercase in HTMLDocument and lowercase in XMLDocument\n    if (!tag.includes(element.tagName.toLowerCase())) {\n        return false;\n    }\n    if (props) {\n        return Object.entries(props).every(([k, v])=>element[k] === v);\n    }\n    return true;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/utils/click/isClickableInput.js\n\n\nvar clickableInputTypes;\n(function(clickableInputTypes) {\n    clickableInputTypes['button'] = 'button';\n    clickableInputTypes['color'] = 'color';\n    clickableInputTypes['file'] = 'file';\n    clickableInputTypes['image'] = 'image';\n    clickableInputTypes['reset'] = 'reset';\n    clickableInputTypes['submit'] = 'submit';\n    clickableInputTypes['checkbox'] = 'checkbox';\n    clickableInputTypes['radio'] = 'radio';\n})(clickableInputTypes || (clickableInputTypes = {}));\nfunction isClickableInput(element) {\n    return isElementType(element, 'button') || isElementType(element, 'input') && element.type in clickableInputTypes;\n}\n\n\n\n// EXTERNAL MODULE: ./node_modules/@testing-library/dom/dist/helpers.js\nvar helpers = __webpack_require__(\"./node_modules/@testing-library/dom/dist/helpers.js\");\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/utils/misc/getWindow.js\n\n\nfunction getWindow(node) {\n    return (0,helpers/* getWindowFromNode */.M2)(node);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/utils/dataTransfer/Blob.js\n// jsdom does not implement Blob.text()\nfunction readBlobText(blob, FileReader) {\n    return new Promise((res, rej)=>{\n        const fr = new FileReader();\n        fr.onerror = rej;\n        fr.onabort = rej;\n        fr.onload = ()=>{\n            res(String(fr.result));\n        };\n        fr.readAsText(blob);\n    });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/utils/dataTransfer/FileList.js\n// FileList can not be created per constructor.\nfunction createFileList(window, files) {\n    const list = {\n        ...files,\n        length: files.length,\n        item: (index)=>list[index],\n        [Symbol.iterator]: function* nextFile() {\n            for(let i = 0; i < list.length; i++){\n                yield list[i];\n            }\n        }\n    };\n    list.constructor = window.FileList;\n    // guard for environments without FileList\n    /* istanbul ignore else */ if (window.FileList) {\n        Object.setPrototypeOf(list, window.FileList.prototype);\n    }\n    Object.freeze(list);\n    return list;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/utils/dataTransfer/DataTransfer.js\n\n\n// DataTransfer is not implemented in jsdom.\n// DataTransfer with FileList is being created by the browser on certain events.\nclass DataTransferItemStub {\n    getAsFile() {\n        return this.file;\n    }\n    getAsString(callback) {\n        if (typeof this.data === 'string') {\n            callback(this.data);\n        }\n    }\n    /* istanbul ignore next */ webkitGetAsEntry() {\n        throw new Error('not implemented');\n    }\n    constructor(dataOrFile, type){\n        this.file = null;\n        this.data = undefined;\n        if (typeof dataOrFile === 'string') {\n            this.kind = 'string';\n            this.type = String(type);\n            this.data = dataOrFile;\n        } else {\n            this.kind = 'file';\n            this.type = dataOrFile.type;\n            this.file = dataOrFile;\n        }\n    }\n}\nclass DataTransferItemListStub extends Array {\n    add(...args) {\n        const item = new DataTransferItemStub(args[0], args[1]);\n        this.push(item);\n        return item;\n    }\n    clear() {\n        this.splice(0, this.length);\n    }\n    remove(index) {\n        this.splice(index, 1);\n    }\n}\nfunction getTypeMatcher(type, exact) {\n    const [group, sub] = type.split('/');\n    const isGroup = !sub || sub === '*';\n    return (item)=>{\n        return exact ? item.type === (isGroup ? group : type) : isGroup ? item.type.startsWith(`${group}/`) : item.type === group;\n    };\n}\nfunction createDataTransferStub(window) {\n    return new class DataTransferStub {\n        getData(format) {\n            var ref;\n            const match = (ref = this.items.find(getTypeMatcher(format, true))) !== null && ref !== void 0 ? ref : this.items.find(getTypeMatcher(format, false));\n            let text = '';\n            match === null || match === void 0 ? void 0 : match.getAsString((t)=>{\n                text = t;\n            });\n            return text;\n        }\n        setData(format, data) {\n            const matchIndex = this.items.findIndex(getTypeMatcher(format, true));\n            const item = new DataTransferItemStub(data, format);\n            if (matchIndex >= 0) {\n                this.items.splice(matchIndex, 1, item);\n            } else {\n                this.items.push(item);\n            }\n        }\n        clearData(format) {\n            if (format) {\n                const matchIndex = this.items.findIndex(getTypeMatcher(format, true));\n                if (matchIndex >= 0) {\n                    this.items.remove(matchIndex);\n                }\n            } else {\n                this.items.clear();\n            }\n        }\n        get types() {\n            const t = [];\n            if (this.files.length) {\n                t.push('Files');\n            }\n            this.items.forEach((i)=>t.push(i.type));\n            Object.freeze(t);\n            return t;\n        }\n        /* istanbul ignore next */ setDragImage() {}\n        constructor(){\n            this.dropEffect = 'none';\n            this.effectAllowed = 'uninitialized';\n            this.items = new DataTransferItemListStub();\n            this.files = createFileList(window, []);\n        }\n    }();\n}\nfunction createDataTransfer(window, files = []) {\n    // Use real DataTransfer if available\n    const dt = typeof window.DataTransfer === 'undefined' ? createDataTransferStub(window) : /* istanbul ignore next */ new window.DataTransfer();\n    Object.defineProperty(dt, 'files', {\n        get: ()=>createFileList(window, files)\n    });\n    return dt;\n}\nfunction getBlobFromDataTransferItem(window, item) {\n    if (item.kind === 'file') {\n        return item.getAsFile();\n    }\n    let data = '';\n    item.getAsString((s)=>{\n        data = s;\n    });\n    return new window.Blob([\n        data\n    ], {\n        type: item.type\n    });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/utils/dataTransfer/Clipboard.js\n\n\n\n\n// Clipboard is not available in jsdom\n// MDN lists string|Blob|Promise<Blob|string> as possible types in ClipboardItemData\n// lib.dom.d.ts lists only Promise<Blob|string>\n// https://developer.mozilla.org/en-US/docs/Web/API/ClipboardItem/ClipboardItem#syntax\nfunction createClipboardItem(window, ...blobs) {\n    const dataMap = Object.fromEntries(blobs.map((b)=>[\n            typeof b === 'string' ? 'text/plain' : b.type,\n            Promise.resolve(b), \n        ]));\n    // use real ClipboardItem if available\n    /* istanbul ignore if */ if (typeof window.ClipboardItem !== 'undefined') {\n        return new window.ClipboardItem(dataMap);\n    }\n    return new class ClipboardItem {\n        get types() {\n            return Array.from(Object.keys(this.data));\n        }\n        async getType(type) {\n            const value = await this.data[type];\n            if (!value) {\n                throw new Error(`${type} is not one of the available MIME types on this item.`);\n            }\n            return value instanceof window.Blob ? value : new window.Blob([\n                value\n            ], {\n                type\n            });\n        }\n        constructor(d){\n            this.data = d;\n        }\n    }(dataMap);\n}\nconst ClipboardStubControl = Symbol('Manage ClipboardSub');\nfunction createClipboardStub(window, control) {\n    return Object.assign(new class Clipboard extends window.EventTarget {\n        async read() {\n            return Array.from(this.items);\n        }\n        async readText() {\n            let text = '';\n            for (const item of this.items){\n                const type = item.types.includes('text/plain') ? 'text/plain' : item.types.find((t)=>t.startsWith('text/'));\n                if (type) {\n                    text += await item.getType(type).then((b)=>readBlobText(b, window.FileReader));\n                }\n            }\n            return text;\n        }\n        async write(data) {\n            this.items = data;\n        }\n        async writeText(text) {\n            this.items = [\n                createClipboardItem(window, text)\n            ];\n        }\n        constructor(...args){\n            super(...args);\n            this.items = [];\n        }\n    }(), {\n        [ClipboardStubControl]: control\n    });\n}\nfunction isClipboardStub(clipboard) {\n    var ref;\n    return !!((ref = clipboard) === null || ref === void 0 ? void 0 : ref[ClipboardStubControl]);\n}\nfunction attachClipboardStubToView(window) {\n    if (isClipboardStub(window.navigator.clipboard)) {\n        return window.navigator.clipboard[ClipboardStubControl];\n    }\n    const realClipboard = Object.getOwnPropertyDescriptor(window.navigator, 'clipboard');\n    let stub;\n    const control = {\n        resetClipboardStub: ()=>{\n            stub = createClipboardStub(window, control);\n        },\n        detachClipboardStub: ()=>{\n            /* istanbul ignore if */ if (realClipboard) {\n                Object.defineProperty(window.navigator, 'clipboard', realClipboard);\n            } else {\n                Object.defineProperty(window.navigator, 'clipboard', {\n                    value: undefined,\n                    configurable: true\n                });\n            }\n        }\n    };\n    stub = createClipboardStub(window, control);\n    Object.defineProperty(window.navigator, 'clipboard', {\n        get: ()=>stub,\n        configurable: true\n    });\n    return stub[ClipboardStubControl];\n}\nfunction resetClipboardStubOnView(window) {\n    if (isClipboardStub(window.navigator.clipboard)) {\n        window.navigator.clipboard[ClipboardStubControl].resetClipboardStub();\n    }\n}\nfunction detachClipboardStubFromView(window) {\n    if (isClipboardStub(window.navigator.clipboard)) {\n        window.navigator.clipboard[ClipboardStubControl].detachClipboardStub();\n    }\n}\nasync function readDataTransferFromClipboard(document) {\n    const window = document.defaultView;\n    const clipboard = window === null || window === void 0 ? void 0 : window.navigator.clipboard;\n    const items = clipboard && await clipboard.read();\n    if (!items) {\n        throw new Error('The Clipboard API is unavailable.');\n    }\n    const dt = createDataTransfer(window);\n    for (const item of items){\n        for (const type of item.types){\n            dt.setData(type, await item.getType(type).then((b)=>readBlobText(b, window.FileReader)));\n        }\n    }\n    return dt;\n}\nasync function writeDataTransferToClipboard(document, clipboardData) {\n    const window = getWindow(document);\n    const clipboard = window.navigator.clipboard;\n    const items = [];\n    for(let i = 0; i < clipboardData.items.length; i++){\n        const dtItem = clipboardData.items[i];\n        const blob = getBlobFromDataTransferItem(window, dtItem);\n        items.push(createClipboardItem(window, blob));\n    }\n    const written = clipboard && await clipboard.write(items).then(()=>true, // Can happen with other implementations that e.g. require permissions\n    /* istanbul ignore next */ ()=>false);\n    if (!written) {\n        throw new Error('The Clipboard API is unavailable.');\n    }\n}\n/* istanbul ignore else */ if (typeof globalThis.afterEach === 'function') {\n    globalThis.afterEach(()=>resetClipboardStubOnView(globalThis.window));\n}\n/* istanbul ignore else */ if (typeof globalThis.afterAll === 'function') {\n    globalThis.afterAll(()=>detachClipboardStubFromView(globalThis.window));\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/utils/edit/isContentEditable.js\n//jsdom is not supporting isContentEditable\nfunction isContentEditable(element) {\n    return element.hasAttribute('contenteditable') && (element.getAttribute('contenteditable') == 'true' || element.getAttribute('contenteditable') == '');\n}\n/**\n * If a node is a contenteditable or inside one, return that element.\n */ function getContentEditable(node) {\n    const element = getElement(node);\n    return element && (element.closest('[contenteditable=\"\"]') || element.closest('[contenteditable=\"true\"]'));\n}\nfunction getElement(node) {\n    return node.nodeType === 1 ? node : node.parentElement;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/utils/edit/isEditable.js\n\n\n\nfunction isEditable(element) {\n    return isEditableInputOrTextArea(element) && !element.readOnly || isContentEditable(element);\n}\nvar editableInputTypes;\n(function(editableInputTypes) {\n    editableInputTypes['text'] = 'text';\n    editableInputTypes['date'] = 'date';\n    editableInputTypes['datetime-local'] = 'datetime-local';\n    editableInputTypes['email'] = 'email';\n    editableInputTypes['month'] = 'month';\n    editableInputTypes['number'] = 'number';\n    editableInputTypes['password'] = 'password';\n    editableInputTypes['search'] = 'search';\n    editableInputTypes['tel'] = 'tel';\n    editableInputTypes['time'] = 'time';\n    editableInputTypes['url'] = 'url';\n    editableInputTypes['week'] = 'week';\n})(editableInputTypes || (editableInputTypes = {}));\nfunction isEditableInputOrTextArea(element) {\n    return isElementType(element, 'textarea') || isElementType(element, 'input') && element.type in editableInputTypes;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/utils/edit/maxLength.js\n\n\nvar maxLengthSupportedTypes;\n(function(maxLengthSupportedTypes) {\n    maxLengthSupportedTypes['email'] = 'email';\n    maxLengthSupportedTypes['password'] = 'password';\n    maxLengthSupportedTypes['search'] = 'search';\n    maxLengthSupportedTypes['telephone'] = 'telephone';\n    maxLengthSupportedTypes['text'] = 'text';\n    maxLengthSupportedTypes['url'] = 'url';\n})(maxLengthSupportedTypes || (maxLengthSupportedTypes = {}));\n// can't use .maxLength property because of a jsdom bug:\n// https://github.com/jsdom/jsdom/issues/2927\nfunction getMaxLength(element) {\n    var ref;\n    const attr = (ref = element.getAttribute('maxlength')) !== null && ref !== void 0 ? ref : '';\n    return /^\\d+$/.test(attr) && Number(attr) >= 0 ? Number(attr) : undefined;\n}\nfunction supportsMaxLength(element) {\n    return isElementType(element, 'textarea') || isElementType(element, 'input') && element.type in maxLengthSupportedTypes;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/utils/focus/selector.js\nconst FOCUSABLE_SELECTOR = [\n    'input:not([type=hidden]):not([disabled])',\n    'button:not([disabled])',\n    'select:not([disabled])',\n    'textarea:not([disabled])',\n    '[contenteditable=\"\"]',\n    '[contenteditable=\"true\"]',\n    'a[href]',\n    '[tabindex]:not([disabled])', \n].join(', ');\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/utils/focus/isFocusable.js\n\n\nfunction isFocusable(element) {\n    return element.matches(FOCUSABLE_SELECTOR);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/utils/keyDef/readNextDescriptor.js\nvar bracketDict;\n(function(bracketDict) {\n    bracketDict['{'] = '}';\n    bracketDict['['] = ']';\n})(bracketDict || (bracketDict = {}));\n/**\n * Read the next key definition from user input\n *\n * Describe key per `{descriptor}` or `[descriptor]`.\n * Everything else will be interpreted as a single character as descriptor - e.g. `a`.\n * Brackets `{` and `[` can be escaped by doubling - e.g. `foo[[bar` translates to `foo[bar`.\n * A previously pressed key can be released per `{/descriptor}`.\n * Keeping the key pressed can be written as `{descriptor>}`.\n * When keeping the key pressed you can choose how long the key is pressed `{descriptor>3}`.\n * You can then release the key per `{descriptor>3/}` or keep it pressed and continue with the next key.\n */ function readNextDescriptor(text, context) {\n    let pos = 0;\n    const startBracket = text[pos] in bracketDict ? text[pos] : '';\n    pos += startBracket.length;\n    const isEscapedChar = new RegExp(`^\\\\${startBracket}{2}`).test(text);\n    const type = isEscapedChar ? '' : startBracket;\n    return {\n        type,\n        ...type === '' ? readPrintableChar(text, pos, context) : readTag(text, pos, type, context)\n    };\n}\nfunction readPrintableChar(text, pos, context) {\n    const descriptor = text[pos];\n    assertDescriptor(descriptor, text, pos, context);\n    pos += descriptor.length;\n    return {\n        consumedLength: pos,\n        descriptor,\n        releasePrevious: false,\n        releaseSelf: true,\n        repeat: 1\n    };\n}\nfunction readTag(text, pos, startBracket, context) {\n    var ref, ref1;\n    const releasePreviousModifier = text[pos] === '/' ? '/' : '';\n    pos += releasePreviousModifier.length;\n    const escapedDescriptor = startBracket === '{' && text[pos] === '\\\\';\n    pos += Number(escapedDescriptor);\n    const descriptor = escapedDescriptor ? text[pos] : (ref = text.slice(pos).match(startBracket === '{' ? /^\\w+|^[^}>/]/ : /^\\w+/)) === null || ref === void 0 ? void 0 : ref[0];\n    assertDescriptor(descriptor, text, pos, context);\n    pos += descriptor.length;\n    var ref2;\n    const repeatModifier = (ref2 = (ref1 = text.slice(pos).match(/^>\\d+/)) === null || ref1 === void 0 ? void 0 : ref1[0]) !== null && ref2 !== void 0 ? ref2 : '';\n    pos += repeatModifier.length;\n    const releaseSelfModifier = text[pos] === '/' || !repeatModifier && text[pos] === '>' ? text[pos] : '';\n    pos += releaseSelfModifier.length;\n    const expectedEndBracket = bracketDict[startBracket];\n    const endBracket = text[pos] === expectedEndBracket ? expectedEndBracket : '';\n    if (!endBracket) {\n        throw new Error(getErrorMessage([\n            !repeatModifier && 'repeat modifier',\n            !releaseSelfModifier && 'release modifier',\n            `\"${expectedEndBracket}\"`, \n        ].filter(Boolean).join(' or '), text[pos], text, context));\n    }\n    pos += endBracket.length;\n    return {\n        consumedLength: pos,\n        descriptor,\n        releasePrevious: !!releasePreviousModifier,\n        repeat: repeatModifier ? Math.max(Number(repeatModifier.substr(1)), 1) : 1,\n        releaseSelf: hasReleaseSelf(releaseSelfModifier, repeatModifier)\n    };\n}\nfunction assertDescriptor(descriptor, text, pos, context) {\n    if (!descriptor) {\n        throw new Error(getErrorMessage('key descriptor', text[pos], text, context));\n    }\n}\nfunction hasReleaseSelf(releaseSelfModifier, repeatModifier) {\n    if (releaseSelfModifier) {\n        return releaseSelfModifier === '/';\n    }\n    if (repeatModifier) {\n        return false;\n    }\n}\nfunction getErrorMessage(expected, found, text, context) {\n    return `Expected ${expected} but found \"${found !== null && found !== void 0 ? found : ''}\" in \"${text}\"\n    See ${context === 'pointer' ? `https://testing-library.com/docs/user-event/pointer#pressing-a-button-or-touching-the-screen` : `https://testing-library.com/docs/user-event/keyboard`}\n    for more information about how userEvent parses your input.`;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/utils/misc/cloneEvent.js\nfunction cloneEvent(event) {\n    return new event.constructor(event.type, event);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/utils/misc/level.js\nvar ApiLevel;\n(function(ApiLevel) {\n    ApiLevel[ApiLevel[\"Trigger\"] = 2] = \"Trigger\";\n    ApiLevel[ApiLevel[\"Call\"] = 1] = \"Call\";\n})(ApiLevel || (ApiLevel = {}));\nfunction setLevelRef(instance, level) {\n    instance.levelRefs[level] = {};\n}\nfunction getLevelRef(instance, level) {\n    return instance.levelRefs[level];\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/options.js\nvar PointerEventsCheckLevel;\n(function(PointerEventsCheckLevel) {\n    PointerEventsCheckLevel[PointerEventsCheckLevel[/**\n   * Check pointer events on every user interaction that triggers a bunch of events.\n   * E.g. once for releasing a mouse button even though this triggers `pointerup`, `mouseup`, `click`, etc...\n   */ \"EachTrigger\"] = 4] = \"EachTrigger\";\n    PointerEventsCheckLevel[PointerEventsCheckLevel[/** Check each target once per call to pointer (related) API */ \"EachApiCall\"] = 2] = \"EachApiCall\";\n    PointerEventsCheckLevel[PointerEventsCheckLevel[/** Check each event target once */ \"EachTarget\"] = 1] = \"EachTarget\";\n    PointerEventsCheckLevel[PointerEventsCheckLevel[/** No pointer events check */ \"Never\"] = 0] = \"Never\";\n})(PointerEventsCheckLevel || (PointerEventsCheckLevel = {}));\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/utils/misc/isDisabled.js\n\n\n// This should probably just rely on the :disabled pseudo-class, but JSDOM doesn't implement it properly.\nfunction isDisabled(element) {\n    for(let el = element; el; el = el.parentElement){\n        if (isElementType(el, [\n            'button',\n            'input',\n            'select',\n            'textarea',\n            'optgroup',\n            'option', \n        ])) {\n            if (el.hasAttribute('disabled')) {\n                return true;\n            }\n        } else if (isElementType(el, 'fieldset')) {\n            var ref;\n            if (el.hasAttribute('disabled') && !((ref = el.querySelector(':scope > legend')) === null || ref === void 0 ? void 0 : ref.contains(element))) {\n                return true;\n            }\n        } else if (el.tagName.includes('-')) {\n            if (el.constructor.formAssociated && el.hasAttribute('disabled')) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/utils/focus/getActiveElement.js\n\n\nfunction getActiveElement(document) {\n    const activeElement = document.activeElement;\n    if (activeElement === null || activeElement === void 0 ? void 0 : activeElement.shadowRoot) {\n        return getActiveElement(activeElement.shadowRoot);\n    } else {\n        // Browser does not yield disabled elements as document.activeElement - jsdom does\n        if (isDisabled(activeElement)) {\n            return document.ownerDocument ? /* istanbul ignore next */ document.ownerDocument.body : document.body;\n        }\n        return activeElement;\n    }\n}\nfunction getActiveElementOrBody(document) {\n    var ref;\n    return (ref = getActiveElement(document)) !== null && ref !== void 0 ? ref : /* istanbul ignore next */ document.body;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/utils/misc/findClosest.js\nfunction findClosest(element, callback) {\n    let el = element;\n    do {\n        if (callback(el)) {\n            return el;\n        }\n        el = el.parentElement;\n    }while (el && el !== element.ownerDocument.body)\n    return undefined;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/utils/focus/selection.js\n\n\n\n/**\n * Determine if the element has its own selection implementation\n * and does not interact with the Document Selection API.\n */ function hasOwnSelection(node) {\n    return isElement(node) && isEditableInputOrTextArea(node);\n}\nfunction hasNoSelection(node) {\n    return isElement(node) && isClickableInput(node);\n}\nfunction isElement(node) {\n    return node.nodeType === 1;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/event/selection/updateSelectionOnFocus.js\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Reset the Document Selection when moving focus into an element\n * with own selection implementation.\n */ function updateSelectionOnFocus(element) {\n    const selection = element.ownerDocument.getSelection();\n    /* istanbul ignore if */ if (!(selection === null || selection === void 0 ? void 0 : selection.focusNode)) {\n        return;\n    }\n    // If the focus moves inside an element with own selection implementation,\n    // the document selection will be this element.\n    // But if the focused element is inside a contenteditable,\n    // 1) a collapsed selection will be retained.\n    // 2) other selections will be replaced by a cursor\n    //  2.a) at the start of the first child if it is a text node\n    //  2.b) at the start of the contenteditable.\n    if (hasOwnSelection(element)) {\n        const contenteditable = getContentEditable(selection.focusNode);\n        if (contenteditable) {\n            if (!selection.isCollapsed) {\n                var ref;\n                const focusNode = ((ref = contenteditable.firstChild) === null || ref === void 0 ? void 0 : ref.nodeType) === 3 ? contenteditable.firstChild : contenteditable;\n                selection.setBaseAndExtent(focusNode, 0, focusNode, 0);\n            }\n        } else {\n            selection.setBaseAndExtent(element, 0, element, 0);\n        }\n    }\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/event/wrapEvent.js\n\n\nfunction wrapEvent(cb, _element) {\n    return (0,dom_esm.getConfig)().eventWrapper(cb);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/event/focus.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Focus closest focusable element.\n */ function focusElement(element) {\n    const target = findClosest(element, isFocusable);\n    const activeElement = getActiveElement(element.ownerDocument);\n    if ((target !== null && target !== void 0 ? target : element.ownerDocument.body) === activeElement) {\n        return;\n    } else if (target) {\n        wrapEvent(()=>target.focus());\n    } else {\n        wrapEvent(()=>{\n            var ref;\n            return (ref = activeElement) === null || ref === void 0 ? void 0 : ref.blur();\n        });\n    }\n    updateSelectionOnFocus(target !== null && target !== void 0 ? target : element.ownerDocument.body);\n}\nfunction blurElement(element) {\n    if (!isFocusable(element)) return;\n    const wasActive = getActiveElement(element.ownerDocument) === element;\n    if (!wasActive) return;\n    wrapEvent(()=>element.blur());\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/event/behavior/registry.js\nconst behavior = {};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/event/behavior/click.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbehavior.click = (event, target, instance)=>{\n    const context = target.closest('button,input,label,select,textarea');\n    const control = context && isElementType(context, 'label') && context.control;\n    if (control) {\n        return ()=>{\n            if (isFocusable(control)) {\n                focusElement(control);\n            }\n            instance.dispatchEvent(control, cloneEvent(event));\n        };\n    } else if (isElementType(target, 'input', {\n        type: 'file'\n    })) {\n        return ()=>{\n            // blur fires when the file selector pops up\n            blurElement(target);\n            target.dispatchEvent(new (getWindow(target)).Event('fileDialog'));\n            // focus fires after the file selector has been closed\n            focusElement(target);\n        };\n    }\n};\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/document/UI.js\nconst UIValue = Symbol('Displayed value in UI');\nconst UISelection = Symbol('Displayed selection in UI');\nconst InitialValue = Symbol('Initial value to compare on blur');\nfunction isUIValue(value) {\n    return typeof value === 'object' && UIValue in value;\n}\nfunction isUISelectionStart(start) {\n    return !!start && typeof start === 'object' && UISelection in start;\n}\nfunction setUIValue(element, value) {\n    if (element[InitialValue] === undefined) {\n        element[InitialValue] = element.value;\n    }\n    element[UIValue] = value;\n    // eslint-disable-next-line no-new-wrappers\n    element.value = Object.assign(new String(value), {\n        [UIValue]: true\n    });\n}\nfunction getUIValue(element) {\n    return element[UIValue] === undefined ? element.value : String(element[UIValue]);\n}\n/** Flag the IDL value as clean. This does not change the value.*/ function setUIValueClean(element) {\n    element[UIValue] = undefined;\n}\nfunction clearInitialValue(element) {\n    element[InitialValue] = undefined;\n}\nfunction getInitialValue(element) {\n    return element[InitialValue];\n}\nfunction setUISelectionRaw(element, selection) {\n    element[UISelection] = selection;\n}\nfunction setUISelection(element, { focusOffset: focusOffsetParam , anchorOffset: anchorOffsetParam = focusOffsetParam  }, mode = 'replace') {\n    const valueLength = getUIValue(element).length;\n    const sanitizeOffset = (o)=>Math.max(0, Math.min(valueLength, o));\n    const anchorOffset = mode === 'replace' || element[UISelection] === undefined ? sanitizeOffset(anchorOffsetParam) : element[UISelection].anchorOffset;\n    const focusOffset = sanitizeOffset(focusOffsetParam);\n    const startOffset = Math.min(anchorOffset, focusOffset);\n    const endOffset = Math.max(anchorOffset, focusOffset);\n    element[UISelection] = {\n        anchorOffset,\n        focusOffset\n    };\n    if (element.selectionStart === startOffset && element.selectionEnd === endOffset) {\n        return;\n    }\n    // eslint-disable-next-line no-new-wrappers\n    const startObj = Object.assign(new Number(startOffset), {\n        [UISelection]: true\n    });\n    try {\n        element.setSelectionRange(startObj, endOffset);\n    } catch  {\n    // DOMException for invalid state is expected when calling this\n    // on an element without support for setSelectionRange\n    }\n}\nfunction getUISelection(element) {\n    var _selectionStart, _selectionEnd, _UISelection;\n    const sel = (_UISelection = element[UISelection]) !== null && _UISelection !== void 0 ? _UISelection : {\n        anchorOffset: (_selectionStart = element.selectionStart) !== null && _selectionStart !== void 0 ? _selectionStart : 0,\n        focusOffset: (_selectionEnd = element.selectionEnd) !== null && _selectionEnd !== void 0 ? _selectionEnd : 0\n    };\n    return {\n        ...sel,\n        startOffset: Math.min(sel.anchorOffset, sel.focusOffset),\n        endOffset: Math.max(sel.anchorOffset, sel.focusOffset)\n    };\n}\nfunction hasUISelection(element) {\n    return !!element[UISelection];\n}\n/** Flag the IDL selection as clean. This does not change the selection. */ function setUISelectionClean(element) {\n    element[UISelection] = undefined;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/utils/edit/timeValue.js\nconst timeValue_parseInt = globalThis.parseInt;\nfunction buildTimeValue(value) {\n    const onlyDigitsValue = value.replace(/\\D/g, '');\n    if (onlyDigitsValue.length < 2) {\n        return value;\n    }\n    const firstDigit = timeValue_parseInt(onlyDigitsValue[0], 10);\n    const secondDigit = timeValue_parseInt(onlyDigitsValue[1], 10);\n    if (firstDigit >= 3 || firstDigit === 2 && secondDigit >= 4) {\n        let index;\n        if (firstDigit >= 3) {\n            index = 1;\n        } else {\n            index = 2;\n        }\n        return build(onlyDigitsValue, index);\n    }\n    if (value.length === 2) {\n        return value;\n    }\n    return build(onlyDigitsValue, 2);\n}\nfunction build(onlyDigitsValue, index) {\n    const hours = onlyDigitsValue.slice(0, index);\n    const validHours = Math.min(timeValue_parseInt(hours, 10), 23);\n    const minuteCharacters = onlyDigitsValue.slice(index);\n    const parsedMinutes = timeValue_parseInt(minuteCharacters, 10);\n    const validMinutes = Math.min(parsedMinutes, 59);\n    return `${validHours.toString().padStart(2, '0')}:${validMinutes.toString().padStart(2, '0')}`;\n}\nfunction isValidDateOrTimeValue(element, value) {\n    const clone = element.cloneNode();\n    clone.value = value;\n    return clone.value === value;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/utils/focus/cursor.js\n\n\n\nfunction getNextCursorPosition(node, offset, direction, inputType) {\n    // The behavior at text node zero offset is inconsistent.\n    // When walking backwards:\n    // Firefox always moves to zero offset and jumps over last offset.\n    // Chrome jumps over zero offset per default but over last offset when Shift is pressed.\n    // The cursor always moves to zero offset if the focus area (contenteditable or body) ends there.\n    // When walking foward both ignore zero offset.\n    // When walking over input elements the cursor moves before or after that element.\n    // When walking over line breaks the cursor moves inside any following text node.\n    if (isTextNode(node) && offset + direction >= 0 && offset + direction <= node.nodeValue.length) {\n        return {\n            node,\n            offset: offset + direction\n        };\n    }\n    const nextNode = getNextCharacterContentNode(node, offset, direction);\n    if (nextNode) {\n        if (isTextNode(nextNode)) {\n            return {\n                node: nextNode,\n                offset: direction > 0 ? Math.min(1, nextNode.nodeValue.length) : Math.max(nextNode.nodeValue.length - 1, 0)\n            };\n        } else if (isElementType(nextNode, 'br')) {\n            const nextPlusOne = getNextCharacterContentNode(nextNode, undefined, direction);\n            if (!nextPlusOne) {\n                // The behavior when there is no possible cursor position beyond the line break is inconsistent.\n                // In Chrome outside of contenteditable moving before a leading line break is possible.\n                // A leading line break can still be removed per deleteContentBackward.\n                // A trailing line break on the other hand is not removed by deleteContentForward.\n                if (direction < 0 && inputType === 'deleteContentBackward') {\n                    return {\n                        node: nextNode.parentNode,\n                        offset: getOffset(nextNode)\n                    };\n                }\n                return undefined;\n            } else if (isTextNode(nextPlusOne)) {\n                return {\n                    node: nextPlusOne,\n                    offset: direction > 0 ? 0 : nextPlusOne.nodeValue.length\n                };\n            } else if (direction < 0 && isElementType(nextPlusOne, 'br')) {\n                return {\n                    node: nextNode.parentNode,\n                    offset: getOffset(nextNode)\n                };\n            } else {\n                return {\n                    node: nextPlusOne.parentNode,\n                    offset: getOffset(nextPlusOne) + (direction > 0 ? 0 : 1)\n                };\n            }\n        } else {\n            return {\n                node: nextNode.parentNode,\n                offset: getOffset(nextNode) + (direction > 0 ? 1 : 0)\n            };\n        }\n    }\n}\nfunction getNextCharacterContentNode(node, offset, direction) {\n    const nextOffset = Number(offset) + (direction < 0 ? -1 : 0);\n    if (offset !== undefined && cursor_isElement(node) && nextOffset >= 0 && nextOffset < node.children.length) {\n        node = node.children[nextOffset];\n    }\n    return walkNodes(node, direction === 1 ? 'next' : 'previous', isTreatedAsCharacterContent);\n}\nfunction isTreatedAsCharacterContent(node) {\n    if (isTextNode(node)) {\n        return true;\n    }\n    if (cursor_isElement(node)) {\n        if (isElementType(node, [\n            'input',\n            'textarea'\n        ])) {\n            return node.type !== 'hidden';\n        } else if (isElementType(node, 'br')) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction getOffset(node) {\n    let i = 0;\n    while(node.previousSibling){\n        i++;\n        node = node.previousSibling;\n    }\n    return i;\n}\nfunction cursor_isElement(node) {\n    return node.nodeType === 1;\n}\nfunction isTextNode(node) {\n    return node.nodeType === 3;\n}\nfunction walkNodes(node, direction, callback) {\n    for(;;){\n        var ref;\n        const sibling = node[`${direction}Sibling`];\n        if (sibling) {\n            node = getDescendant(sibling, direction === 'next' ? 'first' : 'last');\n            if (callback(node)) {\n                return node;\n            }\n        } else if (node.parentNode && (!cursor_isElement(node.parentNode) || !isContentEditable(node.parentNode) && node.parentNode !== ((ref = node.ownerDocument) === null || ref === void 0 ? void 0 : ref.body))) {\n            node = node.parentNode;\n        } else {\n            break;\n        }\n    }\n}\nfunction getDescendant(node, direction) {\n    while(node.hasChildNodes()){\n        node = node[`${direction}Child`];\n    }\n    return node;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/document/trackValue.js\n\n\n\n\n\n\n\n\n\n\nconst TrackChanges = Symbol('Track programmatic changes for React workaround');\n// When the input event happens in the browser, React executes all event handlers\n// and if they change state of a controlled value, nothing happens.\n// But when we trigger the event handlers in test environment with React@17,\n// the changes are rolled back before the state update is applied.\n// This results in a reset cursor.\n// There might be a better way to work around if we figure out\n// why the batched update is executed differently in our test environment.\nfunction isReact17Element(element) {\n    return Object.getOwnPropertyNames(element).some((k)=>k.startsWith('__react')) && getWindow(element).REACT_VERSION === 17;\n}\nfunction startTrackValue(element) {\n    if (!isReact17Element(element)) {\n        return;\n    }\n    element[TrackChanges] = {\n        previousValue: String(element.value),\n        tracked: []\n    };\n}\nfunction trackOrSetValue(element, v) {\n    var ref, ref1;\n    (ref = element[TrackChanges]) === null || ref === void 0 ? void 0 : (ref1 = ref.tracked) === null || ref1 === void 0 ? void 0 : ref1.push(v);\n    if (!element[TrackChanges]) {\n        setUIValueClean(element);\n        setUISelection(element, {\n            focusOffset: v.length\n        });\n    }\n}\nfunction commitValueAfterInput(element, cursorOffset) {\n    var ref;\n    const changes = element[TrackChanges];\n    element[TrackChanges] = undefined;\n    if (!(changes === null || changes === void 0 ? void 0 : (ref = changes.tracked) === null || ref === void 0 ? void 0 : ref.length)) {\n        return;\n    }\n    const isJustReactStateUpdate = changes.tracked.length === 2 && changes.tracked[0] === changes.previousValue && changes.tracked[1] === element.value;\n    if (!isJustReactStateUpdate) {\n        setUIValueClean(element);\n    }\n    if (hasUISelection(element)) {\n        setUISelection(element, {\n            focusOffset: isJustReactStateUpdate ? cursorOffset : element.value.length\n        });\n    }\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/event/selection/getTargetTypeAndSelection.js\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Determine which selection logic and selection ranges to consider.\n */ function getTargetTypeAndSelection(node) {\n    const element = getTargetTypeAndSelection_getElement(node);\n    if (element && hasOwnSelection(element)) {\n        return {\n            type: 'input',\n            selection: getUISelection(element)\n        };\n    }\n    const selection = element === null || element === void 0 ? void 0 : element.ownerDocument.getSelection();\n    // It is possible to extend a single-range selection into a contenteditable.\n    // This results in the range acting like a range outside of contenteditable.\n    const isCE = getContentEditable(node) && (selection === null || selection === void 0 ? void 0 : selection.anchorNode) && getContentEditable(selection.anchorNode);\n    return {\n        type: isCE ? 'contenteditable' : 'default',\n        selection\n    };\n}\nfunction getTargetTypeAndSelection_getElement(node) {\n    return node.nodeType === 1 ? node : node.parentElement;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/event/selection/getInputRange.js\n\n\n/**\n * Get the range that would be overwritten by input.\n */ function getInputRange(focusNode) {\n    const typeAndSelection = getTargetTypeAndSelection(focusNode);\n    if (typeAndSelection.type === 'input') {\n        return typeAndSelection.selection;\n    } else if (typeAndSelection.type === 'contenteditable') {\n        var ref;\n        // Multi-range on contenteditable edits the first selection instead of the last\n        return (ref = typeAndSelection.selection) === null || ref === void 0 ? void 0 : ref.getRangeAt(0);\n    }\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/event/selection/setSelection.js\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Set the selection\n */ function setSelection({ focusNode , focusOffset , anchorNode =focusNode , anchorOffset =focusOffset  }) {\n    var ref, ref1;\n    const typeAndSelection = getTargetTypeAndSelection(focusNode);\n    if (typeAndSelection.type === 'input') {\n        return setUISelection(focusNode, {\n            anchorOffset,\n            focusOffset\n        });\n    }\n    (ref1 = (ref = anchorNode.ownerDocument) === null || ref === void 0 ? void 0 : ref.getSelection()) === null || ref1 === void 0 ? void 0 : ref1.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/event/input.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction isDateOrTime(element) {\n    return isElementType(element, 'input') && [\n        'date',\n        'time'\n    ].includes(element.type);\n}\nfunction input(instance, element, data, inputType = 'insertText') {\n    const inputRange = getInputRange(element);\n    /* istanbul ignore if */ if (!inputRange) {\n        return;\n    }\n    // There is no `beforeinput` event on `date` and `time` input\n    if (!isDateOrTime(element)) {\n        const unprevented = instance.dispatchUIEvent(element, 'beforeinput', {\n            inputType,\n            data\n        });\n        if (!unprevented) {\n            return;\n        }\n    }\n    if ('startContainer' in inputRange) {\n        editContenteditable(instance, element, inputRange, data, inputType);\n    } else {\n        editInputElement(instance, element, inputRange, data, inputType);\n    }\n}\nfunction editContenteditable(instance, element, inputRange, data, inputType) {\n    let del = false;\n    if (!inputRange.collapsed) {\n        del = true;\n        inputRange.deleteContents();\n    } else if ([\n        'deleteContentBackward',\n        'deleteContentForward'\n    ].includes(inputType)) {\n        const nextPosition = getNextCursorPosition(inputRange.startContainer, inputRange.startOffset, inputType === 'deleteContentBackward' ? -1 : 1, inputType);\n        if (nextPosition) {\n            del = true;\n            const delRange = inputRange.cloneRange();\n            if (delRange.comparePoint(nextPosition.node, nextPosition.offset) < 0) {\n                delRange.setStart(nextPosition.node, nextPosition.offset);\n            } else {\n                delRange.setEnd(nextPosition.node, nextPosition.offset);\n            }\n            delRange.deleteContents();\n        }\n    }\n    if (data) {\n        if (inputRange.endContainer.nodeType === 3) {\n            const offset = inputRange.endOffset;\n            inputRange.endContainer.insertData(offset, data);\n            inputRange.setStart(inputRange.endContainer, offset + data.length);\n            inputRange.setEnd(inputRange.endContainer, offset + data.length);\n        } else {\n            const text = element.ownerDocument.createTextNode(data);\n            inputRange.insertNode(text);\n            inputRange.setStart(text, data.length);\n            inputRange.setEnd(text, data.length);\n        }\n    }\n    if (del || data) {\n        instance.dispatchUIEvent(element, 'input', {\n            inputType\n        });\n    }\n}\nfunction editInputElement(instance, element, inputRange, data, inputType) {\n    let dataToInsert = data;\n    if (supportsMaxLength(element)) {\n        const maxLength = getMaxLength(element);\n        if (maxLength !== undefined && data.length > 0) {\n            const spaceUntilMaxLength = maxLength - element.value.length;\n            if (spaceUntilMaxLength > 0) {\n                dataToInsert = data.substring(0, spaceUntilMaxLength);\n            } else {\n                return;\n            }\n        }\n    }\n    const { newValue , newOffset , oldValue  } = calculateNewValue(dataToInsert, element, inputRange, inputType);\n    if (newValue === oldValue && newOffset === inputRange.startOffset && newOffset === inputRange.endOffset) {\n        return;\n    }\n    if (isElementType(element, 'input', {\n        type: 'number'\n    }) && !isValidNumberInput(newValue)) {\n        return;\n    }\n    setUIValue(element, newValue);\n    setSelection({\n        focusNode: element,\n        anchorOffset: newOffset,\n        focusOffset: newOffset\n    });\n    if (isDateOrTime(element)) {\n        if (isValidDateOrTimeValue(element, newValue)) {\n            commitInput(instance, element, newOffset, {});\n            instance.dispatchUIEvent(element, 'change');\n            clearInitialValue(element);\n        }\n    } else {\n        commitInput(instance, element, newOffset, {\n            data,\n            inputType\n        });\n    }\n}\nfunction calculateNewValue(inputData, node, { startOffset , endOffset  }, inputType) {\n    const value = getUIValue(node);\n    const prologEnd = Math.max(0, startOffset === endOffset && inputType === 'deleteContentBackward' ? startOffset - 1 : startOffset);\n    const prolog = value.substring(0, prologEnd);\n    const epilogStart = Math.min(value.length, startOffset === endOffset && inputType === 'deleteContentForward' ? startOffset + 1 : endOffset);\n    const epilog = value.substring(epilogStart, value.length);\n    let newValue = `${prolog}${inputData}${epilog}`;\n    let newOffset = prologEnd + inputData.length;\n    if (isElementType(node, 'input', {\n        type: 'time'\n    })) {\n        const builtValue = buildTimeValue(newValue);\n        if (builtValue !== '' && isValidDateOrTimeValue(node, builtValue)) {\n            newValue = builtValue;\n            newOffset = builtValue.length;\n        }\n    }\n    return {\n        oldValue: value,\n        newValue,\n        newOffset\n    };\n}\nfunction commitInput(instance, element, newOffset, inputInit) {\n    instance.dispatchUIEvent(element, 'input', inputInit);\n    commitValueAfterInput(element, newOffset);\n}\nfunction isValidNumberInput(value) {\n    var ref, ref1;\n    // the browser allows some invalid input but not others\n    // it allows up to two '-' at any place before any 'e' or one directly following 'e'\n    // it allows one '.' at any place before e\n    const valueParts = value.split('e', 2);\n    return !(/[^\\d.\\-e]/.test(value) || Number((ref = value.match(/-/g)) === null || ref === void 0 ? void 0 : ref.length) > 2 || Number((ref1 = value.match(/\\./g)) === null || ref1 === void 0 ? void 0 : ref1.length) > 1 || valueParts[1] && !/^-?\\d*$/.test(valueParts[1]));\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/event/behavior/cut.js\n\n\n\n\n\n\n\n\n\n\n\nbehavior.cut = (event, target, instance)=>{\n    return ()=>{\n        if (isEditable(target)) {\n            input(instance, target, '', 'deleteByCut');\n        }\n    };\n};\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/document/getValueOrTextContent.js\n\n\n\n\n\n\n\n\n\n\n\nfunction getValueOrTextContent(element) {\n    // istanbul ignore if\n    if (!element) {\n        return null;\n    }\n    if (isContentEditable(element)) {\n        return element.textContent;\n    }\n    return getUIValue(element);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/utils/misc/isVisible.js\n\n\nfunction isVisible(element) {\n    const window = getWindow(element);\n    for(let el = element; el === null || el === void 0 ? void 0 : el.ownerDocument; el = el.parentElement){\n        const { display , visibility  } = window.getComputedStyle(el);\n        if (display === 'none') {\n            return false;\n        }\n        if (visibility === 'hidden') {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/utils/focus/getTabDestination.js\n\n\n\n\n\nfunction getTabDestination(activeElement, shift) {\n    const document = activeElement.ownerDocument;\n    const focusableElements = document.querySelectorAll(FOCUSABLE_SELECTOR);\n    const enabledElements = Array.from(focusableElements).filter((el)=>el === activeElement || !(Number(el.getAttribute('tabindex')) < 0 || isDisabled(el)));\n    // tabindex has no effect if the active element has negative tabindex\n    if (Number(activeElement.getAttribute('tabindex')) >= 0) {\n        enabledElements.sort((a, b)=>{\n            const i = Number(a.getAttribute('tabindex'));\n            const j = Number(b.getAttribute('tabindex'));\n            if (i === j) {\n                return 0;\n            } else if (i === 0) {\n                return 1;\n            } else if (j === 0) {\n                return -1;\n            }\n            return i - j;\n        });\n    }\n    const checkedRadio = {};\n    let prunedElements = [\n        document.body\n    ];\n    const activeRadioGroup = isElementType(activeElement, 'input', {\n        type: 'radio'\n    }) ? activeElement.name : undefined;\n    enabledElements.forEach((currentElement)=>{\n        const el = currentElement;\n        // For radio groups keep only the active radio\n        // If there is no active radio, keep only the checked radio\n        // If there is no checked radio, treat like everything else\n        if (isElementType(el, 'input', {\n            type: 'radio'\n        }) && el.name) {\n            // If the active element is part of the group, add only that\n            if (el === activeElement) {\n                prunedElements.push(el);\n                return;\n            } else if (el.name === activeRadioGroup) {\n                return;\n            }\n            // If we stumble upon a checked radio, remove the others\n            if (el.checked) {\n                prunedElements = prunedElements.filter((e)=>!isElementType(e, 'input', {\n                        type: 'radio',\n                        name: el.name\n                    }));\n                prunedElements.push(el);\n                checkedRadio[el.name] = el;\n                return;\n            }\n            // If we already found the checked one, skip\n            if (typeof checkedRadio[el.name] !== 'undefined') {\n                return;\n            }\n        }\n        prunedElements.push(el);\n    });\n    for(let index = prunedElements.findIndex((el)=>el === activeElement);;){\n        index += shift ? -1 : 1;\n        // loop at overflow\n        if (index === prunedElements.length) {\n            index = 0;\n        } else if (index === -1) {\n            index = prunedElements.length - 1;\n        }\n        if (prunedElements[index] === activeElement || prunedElements[index] === document.body || isVisible(prunedElements[index])) {\n            return prunedElements[index];\n        }\n    }\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/event/selection/moveSelection.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Move the selection\n */ function moveSelection(node, direction) {\n    // TODO: implement shift\n    if (hasOwnSelection(node)) {\n        const selection = getUISelection(node);\n        setSelection({\n            focusNode: node,\n            focusOffset: selection.startOffset === selection.endOffset ? selection.focusOffset + direction : direction < 0 ? selection.startOffset : selection.endOffset\n        });\n    } else {\n        const selection1 = node.ownerDocument.getSelection();\n        if (!(selection1 === null || selection1 === void 0 ? void 0 : selection1.focusNode)) {\n            return;\n        }\n        if (selection1.isCollapsed) {\n            const nextPosition = getNextCursorPosition(selection1.focusNode, selection1.focusOffset, direction);\n            if (nextPosition) {\n                setSelection({\n                    focusNode: nextPosition.node,\n                    focusOffset: nextPosition.offset\n                });\n            }\n        } else {\n            selection1[direction < 0 ? 'collapseToStart' : 'collapseToEnd']();\n        }\n    }\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/event/selection/selectAll.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Expand a selection like the browser does when pressing Ctrl+A.\n */ function selectAll(target) {\n    if (hasOwnSelection(target)) {\n        return setSelection({\n            focusNode: target,\n            anchorOffset: 0,\n            focusOffset: getUIValue(target).length\n        });\n    }\n    var ref;\n    const focusNode = (ref = getContentEditable(target)) !== null && ref !== void 0 ? ref : target.ownerDocument.body;\n    setSelection({\n        focusNode,\n        anchorOffset: 0,\n        focusOffset: focusNode.childNodes.length\n    });\n}\nfunction isAllSelected(target) {\n    if (hasOwnSelection(target)) {\n        return getUISelection(target).startOffset === 0 && getUISelection(target).endOffset === getUIValue(target).length;\n    }\n    var ref;\n    const focusNode = (ref = getContentEditable(target)) !== null && ref !== void 0 ? ref : target.ownerDocument.body;\n    const selection = target.ownerDocument.getSelection();\n    return (selection === null || selection === void 0 ? void 0 : selection.anchorNode) === focusNode && selection.focusNode === focusNode && selection.anchorOffset === 0 && selection.focusOffset === focusNode.childNodes.length;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/event/selection/setSelectionRange.js\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Backward-compatible selection.\n *\n * Handles input elements and contenteditable if it only contains a single text node.\n */ function setSelectionRange(element, anchorOffset, focusOffset) {\n    var ref;\n    if (hasOwnSelection(element)) {\n        return setSelection({\n            focusNode: element,\n            anchorOffset,\n            focusOffset\n        });\n    }\n    /* istanbul ignore else */ if (isContentEditable(element) && ((ref = element.firstChild) === null || ref === void 0 ? void 0 : ref.nodeType) === 3) {\n        return setSelection({\n            focusNode: element.firstChild,\n            anchorOffset,\n            focusOffset\n        });\n    }\n    /* istanbul ignore next */ throw new Error('Not implemented. The result of this interaction is unreliable.');\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/event/radio.js\n\n\n\n\n\n\n\n\n\n\n\nfunction walkRadio(instance, el, direction) {\n    const window = getWindow(el);\n    const group = Array.from(el.ownerDocument.querySelectorAll(el.name ? `input[type=\"radio\"][name=\"${window.CSS.escape(el.name)}\"]` : `input[type=\"radio\"][name=\"\"], input[type=\"radio\"]:not([name])`));\n    for(let i = group.findIndex((e)=>e === el) + direction;; i += direction){\n        if (!group[i]) {\n            i = direction > 0 ? 0 : group.length - 1;\n        }\n        if (group[i] === el) {\n            return;\n        }\n        if (isDisabled(group[i])) {\n            continue;\n        }\n        focusElement(group[i]);\n        instance.dispatchUIEvent(group[i], 'click');\n    }\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/event/behavior/keydown.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbehavior.keydown = (event, target, instance)=>{\n    var ref;\n    var ref1;\n    return (ref1 = (ref = keydownBehavior[event.key]) === null || ref === void 0 ? void 0 : ref.call(keydownBehavior, event, target, instance)) !== null && ref1 !== void 0 ? ref1 : combinationBehavior(event, target, instance);\n};\nconst keydownBehavior = {\n    ArrowDown: (event, target, instance)=>{\n        /* istanbul ignore else */ if (isElementType(target, 'input', {\n            type: 'radio'\n        })) {\n            return ()=>walkRadio(instance, target, -1);\n        }\n    },\n    ArrowLeft: (event, target, instance)=>{\n        if (isElementType(target, 'input', {\n            type: 'radio'\n        })) {\n            return ()=>walkRadio(instance, target, -1);\n        }\n        return ()=>moveSelection(target, -1);\n    },\n    ArrowRight: (event, target, instance)=>{\n        if (isElementType(target, 'input', {\n            type: 'radio'\n        })) {\n            return ()=>walkRadio(instance, target, 1);\n        }\n        return ()=>moveSelection(target, 1);\n    },\n    ArrowUp: (event, target, instance)=>{\n        /* istanbul ignore else */ if (isElementType(target, 'input', {\n            type: 'radio'\n        })) {\n            return ()=>walkRadio(instance, target, 1);\n        }\n    },\n    Backspace: (event, target, instance)=>{\n        if (isEditable(target)) {\n            return ()=>{\n                input(instance, target, '', 'deleteContentBackward');\n            };\n        }\n    },\n    Delete: (event, target, instance)=>{\n        if (isEditable(target)) {\n            return ()=>{\n                input(instance, target, '', 'deleteContentForward');\n            };\n        }\n    },\n    End: (event, target)=>{\n        if (isElementType(target, [\n            'input',\n            'textarea'\n        ]) || isContentEditable(target)) {\n            return ()=>{\n                var ref;\n                var ref1;\n                const newPos = (ref1 = (ref = getValueOrTextContent(target)) === null || ref === void 0 ? void 0 : ref.length) !== null && ref1 !== void 0 ? ref1 : /* istanbul ignore next */ 0;\n                setSelectionRange(target, newPos, newPos);\n            };\n        }\n    },\n    Home: (event, target)=>{\n        if (isElementType(target, [\n            'input',\n            'textarea'\n        ]) || isContentEditable(target)) {\n            return ()=>{\n                setSelectionRange(target, 0, 0);\n            };\n        }\n    },\n    PageDown: (event, target)=>{\n        if (isElementType(target, [\n            'input'\n        ])) {\n            return ()=>{\n                const newPos = getUIValue(target).length;\n                setSelectionRange(target, newPos, newPos);\n            };\n        }\n    },\n    PageUp: (event, target)=>{\n        if (isElementType(target, [\n            'input'\n        ])) {\n            return ()=>{\n                setSelectionRange(target, 0, 0);\n            };\n        }\n    },\n    Tab: (event, target, instance)=>{\n        return ()=>{\n            const dest = getTabDestination(target, instance.system.keyboard.modifiers.Shift);\n            focusElement(dest);\n            if (hasOwnSelection(dest)) {\n                setUISelection(dest, {\n                    anchorOffset: 0,\n                    focusOffset: dest.value.length\n                });\n            }\n        };\n    }\n};\nconst combinationBehavior = (event, target, instance)=>{\n    if (event.code === 'KeyA' && instance.system.keyboard.modifiers.Control) {\n        return ()=>selectAll(target);\n    }\n};\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/event/behavior/keypress.js\n\n\n\n\n\n\n\n\n\n\n\n\n\nbehavior.keypress = (event, target, instance)=>{\n    if (event.key === 'Enter') {\n        if (isElementType(target, 'button') || isElementType(target, 'input') && ClickInputOnEnter.includes(target.type) || isElementType(target, 'a') && Boolean(target.href)) {\n            return ()=>{\n                instance.dispatchUIEvent(target, 'click');\n            };\n        } else if (isElementType(target, 'input')) {\n            const form = target.form;\n            const submit = form === null || form === void 0 ? void 0 : form.querySelector('input[type=\"submit\"], button:not([type]), button[type=\"submit\"]');\n            if (submit) {\n                return ()=>instance.dispatchUIEvent(submit, 'click');\n            } else if (form && SubmitSingleInputOnEnter.includes(target.type) && form.querySelectorAll('input').length === 1) {\n                return ()=>instance.dispatchUIEvent(form, 'submit');\n            } else {\n                return;\n            }\n        }\n    }\n    if (isEditable(target)) {\n        const inputType = event.key === 'Enter' ? isContentEditable(target) && !instance.system.keyboard.modifiers.Shift ? 'insertParagraph' : 'insertLineBreak' : 'insertText';\n        const inputData = event.key === 'Enter' ? '\\n' : event.key;\n        return ()=>input(instance, target, inputData, inputType);\n    }\n};\nconst ClickInputOnEnter = [\n    'button',\n    'color',\n    'file',\n    'image',\n    'reset',\n    'submit', \n];\nconst SubmitSingleInputOnEnter = [\n    'email',\n    'month',\n    'password',\n    'search',\n    'tel',\n    'text',\n    'url',\n    'week', \n];\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/event/behavior/keyup.js\n\n\n\n\n\n\n\n\n\n\nbehavior.keyup = (event, target, instance)=>{\n    var ref;\n    return (ref = keyupBehavior[event.key]) === null || ref === void 0 ? void 0 : ref.call(keyupBehavior, event, target, instance);\n};\nconst keyupBehavior = {\n    ' ': (event, target, instance)=>{\n        if (isClickableInput(target)) {\n            return ()=>instance.dispatchUIEvent(target, 'click');\n        }\n    }\n};\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/event/behavior/paste.js\n\n\n\n\n\n\n\n\n\n\n\nbehavior.paste = (event, target, instance)=>{\n    if (isEditable(target)) {\n        return ()=>{\n            var ref;\n            const insertData = (ref = event.clipboardData) === null || ref === void 0 ? void 0 : ref.getData('text');\n            if (insertData) {\n                input(instance, target, insertData, 'insertFromPaste');\n            }\n        };\n    }\n};\n\n// EXTERNAL MODULE: ./node_modules/@testing-library/dom/dist/event-map.js\nvar event_map = __webpack_require__(\"./node_modules/@testing-library/dom/dist/event-map.js\");\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/event/eventMap.js\n\n\nconst eventMap = {\n    ...event_map/* eventMap */.Hx,\n    click: {\n        EventType: 'PointerEvent',\n        defaultInit: {\n            bubbles: true,\n            cancelable: true,\n            composed: true\n        }\n    },\n    auxclick: {\n        EventType: 'PointerEvent',\n        defaultInit: {\n            bubbles: true,\n            cancelable: true,\n            composed: true\n        }\n    },\n    contextmenu: {\n        EventType: 'PointerEvent',\n        defaultInit: {\n            bubbles: true,\n            cancelable: true,\n            composed: true\n        }\n    },\n    beforeInput: {\n        EventType: 'InputEvent',\n        defaultInit: {\n            bubbles: true,\n            cancelable: true,\n            composed: true\n        }\n    }\n};\nconst eventMapKeys = Object.fromEntries(Object.keys(eventMap).map((k)=>[\n        k.toLowerCase(),\n        k\n    ]));\nfunction getEventClass(type) {\n    const k = eventMapKeys[type];\n    return k && eventMap[k].EventType;\n}\nconst mouseEvents = [\n    'MouseEvent',\n    'PointerEvent'\n];\nfunction isMouseEvent(type) {\n    return mouseEvents.includes(getEventClass(type));\n}\nfunction isKeyboardEvent(type) {\n    return getEventClass(type) === 'KeyboardEvent';\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/event/createEvent.js\n\n\n\n\n\n\n\n\n\n\nconst eventInitializer = {\n    ClipboardEvent: [\n        initClipboardEvent\n    ],\n    InputEvent: [\n        initUIEvent,\n        initInputEvent\n    ],\n    MouseEvent: [\n        initUIEvent,\n        initUIEventModififiers,\n        initMouseEvent\n    ],\n    PointerEvent: [\n        initUIEvent,\n        initUIEventModififiers,\n        initMouseEvent,\n        initPointerEvent, \n    ],\n    KeyboardEvent: [\n        initUIEvent,\n        initUIEventModififiers,\n        initKeyboardEvent\n    ]\n};\nfunction createEvent(type, target, init) {\n    var ref;\n    const window = getWindow(target);\n    const { EventType , defaultInit  } = eventMap[eventMapKeys[type]];\n    const event = new (getEventConstructors(window))[EventType](type, defaultInit);\n    (ref = eventInitializer[EventType]) === null || ref === void 0 ? void 0 : ref.forEach((f)=>f(event, init !== null && init !== void 0 ? init : {}));\n    return event;\n}\n/* istanbul ignore next */ function getEventConstructors(window) {\n    var _Event;\n    /* eslint-disable @typescript-eslint/no-unnecessary-condition, @typescript-eslint/no-extraneous-class */ const Event = (_Event = window.Event) !== null && _Event !== void 0 ? _Event : class Event {\n    };\n    var _AnimationEvent;\n    const AnimationEvent = (_AnimationEvent = window.AnimationEvent) !== null && _AnimationEvent !== void 0 ? _AnimationEvent : class AnimationEvent extends Event {\n    };\n    var _ClipboardEvent;\n    const ClipboardEvent = (_ClipboardEvent = window.ClipboardEvent) !== null && _ClipboardEvent !== void 0 ? _ClipboardEvent : class ClipboardEvent extends Event {\n    };\n    var _PopStateEvent;\n    const PopStateEvent = (_PopStateEvent = window.PopStateEvent) !== null && _PopStateEvent !== void 0 ? _PopStateEvent : class PopStateEvent extends Event {\n    };\n    var _ProgressEvent;\n    const ProgressEvent = (_ProgressEvent = window.ProgressEvent) !== null && _ProgressEvent !== void 0 ? _ProgressEvent : class ProgressEvent extends Event {\n    };\n    var _TransitionEvent;\n    const TransitionEvent = (_TransitionEvent = window.TransitionEvent) !== null && _TransitionEvent !== void 0 ? _TransitionEvent : class TransitionEvent extends Event {\n    };\n    var _UIEvent;\n    const UIEvent = (_UIEvent = window.UIEvent) !== null && _UIEvent !== void 0 ? _UIEvent : class UIEvent extends Event {\n    };\n    var _CompositionEvent;\n    const CompositionEvent = (_CompositionEvent = window.CompositionEvent) !== null && _CompositionEvent !== void 0 ? _CompositionEvent : class CompositionEvent extends UIEvent {\n    };\n    var _FocusEvent;\n    const FocusEvent = (_FocusEvent = window.FocusEvent) !== null && _FocusEvent !== void 0 ? _FocusEvent : class FocusEvent extends UIEvent {\n    };\n    var _InputEvent;\n    const InputEvent = (_InputEvent = window.InputEvent) !== null && _InputEvent !== void 0 ? _InputEvent : class InputEvent extends UIEvent {\n    };\n    var _KeyboardEvent;\n    const KeyboardEvent = (_KeyboardEvent = window.KeyboardEvent) !== null && _KeyboardEvent !== void 0 ? _KeyboardEvent : class KeyboardEvent extends UIEvent {\n    };\n    var _MouseEvent;\n    const MouseEvent = (_MouseEvent = window.MouseEvent) !== null && _MouseEvent !== void 0 ? _MouseEvent : class MouseEvent extends UIEvent {\n    };\n    var _DragEvent;\n    const DragEvent = (_DragEvent = window.DragEvent) !== null && _DragEvent !== void 0 ? _DragEvent : class DragEvent extends MouseEvent {\n    };\n    var _PointerEvent;\n    const PointerEvent = (_PointerEvent = window.PointerEvent) !== null && _PointerEvent !== void 0 ? _PointerEvent : class PointerEvent extends MouseEvent {\n    };\n    var _TouchEvent;\n    const TouchEvent = (_TouchEvent = window.TouchEvent) !== null && _TouchEvent !== void 0 ? _TouchEvent : class TouchEvent extends UIEvent {\n    };\n    /* eslint-enable @typescript-eslint/no-unnecessary-condition, @typescript-eslint/no-extraneous-class */ return {\n        Event,\n        AnimationEvent,\n        ClipboardEvent,\n        PopStateEvent,\n        ProgressEvent,\n        TransitionEvent,\n        UIEvent,\n        CompositionEvent,\n        FocusEvent,\n        InputEvent,\n        KeyboardEvent,\n        MouseEvent,\n        DragEvent,\n        PointerEvent,\n        TouchEvent\n    };\n}\nfunction assignProps(obj, props) {\n    for (const [key, value] of Object.entries(props)){\n        Object.defineProperty(obj, key, {\n            get: ()=>value !== null && value !== void 0 ? value : null\n        });\n    }\n}\nfunction sanitizeNumber(n) {\n    return Number(n !== null && n !== void 0 ? n : 0);\n}\nfunction initClipboardEvent(event, { clipboardData  }) {\n    assignProps(event, {\n        clipboardData\n    });\n}\nfunction initInputEvent(event, { data , inputType , isComposing  }) {\n    assignProps(event, {\n        data,\n        isComposing: Boolean(isComposing),\n        inputType: String(inputType)\n    });\n}\nfunction initUIEvent(event, { view , detail  }) {\n    assignProps(event, {\n        view,\n        detail: sanitizeNumber(detail !== null && detail !== void 0 ? detail : 0)\n    });\n}\nfunction initUIEventModififiers(event, { altKey , ctrlKey , metaKey , shiftKey , modifierAltGraph , modifierCapsLock , modifierFn , modifierFnLock , modifierNumLock , modifierScrollLock , modifierSymbol , modifierSymbolLock  }) {\n    assignProps(event, {\n        altKey: Boolean(altKey),\n        ctrlKey: Boolean(ctrlKey),\n        metaKey: Boolean(metaKey),\n        shiftKey: Boolean(shiftKey),\n        getModifierState (k) {\n            return Boolean({\n                Alt: altKey,\n                AltGraph: modifierAltGraph,\n                CapsLock: modifierCapsLock,\n                Control: ctrlKey,\n                Fn: modifierFn,\n                FnLock: modifierFnLock,\n                Meta: metaKey,\n                NumLock: modifierNumLock,\n                ScrollLock: modifierScrollLock,\n                Shift: shiftKey,\n                Symbol: modifierSymbol,\n                SymbolLock: modifierSymbolLock\n            }[k]);\n        }\n    });\n}\nfunction initKeyboardEvent(event, { key , code , location , repeat , isComposing , charCode  }) {\n    assignProps(event, {\n        key: String(key),\n        code: String(code),\n        location: sanitizeNumber(location),\n        repeat: Boolean(repeat),\n        isComposing: Boolean(isComposing),\n        charCode\n    });\n}\nfunction initMouseEvent(event, { x , y , screenX , screenY , clientX =x , clientY =y , button , buttons , relatedTarget  }) {\n    assignProps(event, {\n        screenX: sanitizeNumber(screenX),\n        screenY: sanitizeNumber(screenY),\n        clientX: sanitizeNumber(clientX),\n        x: sanitizeNumber(clientX),\n        clientY: sanitizeNumber(clientY),\n        y: sanitizeNumber(clientY),\n        button: sanitizeNumber(button),\n        buttons: sanitizeNumber(buttons),\n        relatedTarget\n    });\n}\nfunction initPointerEvent(event, { pointerId , width , height , pressure , tangentialPressure , tiltX , tiltY , twist , pointerType , isPrimary  }) {\n    assignProps(event, {\n        pointerId: sanitizeNumber(pointerId),\n        width: sanitizeNumber(width),\n        height: sanitizeNumber(height),\n        pressure: sanitizeNumber(pressure),\n        tangentialPressure: sanitizeNumber(tangentialPressure),\n        tiltX: sanitizeNumber(tiltX),\n        tiltY: sanitizeNumber(tiltY),\n        twist: sanitizeNumber(twist),\n        pointerType: String(pointerType),\n        isPrimary: Boolean(isPrimary)\n    });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/event/dispatchEvent.js\n\n\n\n\n\n\n\n\n\n\n\nfunction dispatchUIEvent(target, type, init, preventDefault = false) {\n    if (isMouseEvent(type) || isKeyboardEvent(type)) {\n        init = {\n            ...init,\n            ...this.system.getUIEventModifiers()\n        };\n    }\n    const event = createEvent(type, target, init);\n    return dispatchEvent.call(this, target, event, preventDefault);\n}\nfunction dispatchEvent(target, event, preventDefault = false) {\n    var ref;\n    const type = event.type;\n    const behaviorImplementation = preventDefault ? ()=>{} : (ref = behavior[type]) === null || ref === void 0 ? void 0 : ref(event, target, this);\n    if (behaviorImplementation) {\n        event.preventDefault();\n        let defaultPrevented = false;\n        Object.defineProperty(event, 'defaultPrevented', {\n            get: ()=>defaultPrevented\n        });\n        Object.defineProperty(event, 'preventDefault', {\n            value: ()=>{\n                defaultPrevented = event.cancelable;\n            }\n        });\n        wrapEvent(()=>target.dispatchEvent(event));\n        if (!defaultPrevented) {\n            behaviorImplementation();\n        }\n        return !defaultPrevented;\n    }\n    return wrapEvent(()=>target.dispatchEvent(event));\n}\nfunction dispatchDOMEvent(target, type, init) {\n    const event = createEvent(type, target, init);\n    wrapEvent(()=>target.dispatchEvent(event));\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/document/interceptor.js\n\n\n\n\n\n\n\n\n\n\n\n\nconst Interceptor = Symbol('Interceptor for programmatical calls');\nfunction prepareInterceptor(element, propName, interceptorImpl) {\n    const prototypeDescriptor = Object.getOwnPropertyDescriptor(element.constructor.prototype, propName);\n    const objectDescriptor = Object.getOwnPropertyDescriptor(element, propName);\n    const target = (prototypeDescriptor === null || prototypeDescriptor === void 0 ? void 0 : prototypeDescriptor.set) ? 'set' : 'value';\n    /* istanbul ignore if */ if (typeof (prototypeDescriptor === null || prototypeDescriptor === void 0 ? void 0 : prototypeDescriptor[target]) !== 'function' || prototypeDescriptor[target][Interceptor]) {\n        throw new Error(`Element ${element.tagName} does not implement \"${String(propName)}\".`);\n    }\n    function intercept(...args) {\n        const { applyNative =false , realArgs , then ,  } = interceptorImpl.call(this, ...args);\n        const realFunc = (!applyNative && objectDescriptor || prototypeDescriptor)[target];\n        if (target === 'set') {\n            realFunc.call(this, realArgs);\n        } else {\n            realFunc.call(this, ...realArgs);\n        }\n        then === null || then === void 0 ? void 0 : then();\n    }\n    intercept[Interceptor] = Interceptor;\n    Object.defineProperty(element, propName, {\n        ...objectDescriptor !== null && objectDescriptor !== void 0 ? objectDescriptor : prototypeDescriptor,\n        [target]: intercept\n    });\n}\nfunction prepareValueInterceptor(element) {\n    prepareInterceptor(element, 'value', function interceptorImpl(v) {\n        const isUI = isUIValue(v);\n        if (isUI) {\n            startTrackValue(this);\n        }\n        return {\n            applyNative: !!isUI,\n            realArgs: sanitizeValue(this, v),\n            then: isUI ? undefined : ()=>trackOrSetValue(this, String(v))\n        };\n    });\n}\nfunction sanitizeValue(element, v) {\n    // Workaround for JSDOM\n    if (isElementType(element, 'input', {\n        type: 'number'\n    }) && String(v) !== '' && !Number.isNaN(Number(v))) {\n        // Setting value to \"1.\" results in `null` in JSDOM\n        return String(Number(v));\n    }\n    return String(v);\n}\nfunction prepareSelectionInterceptor(element) {\n    prepareInterceptor(element, 'setSelectionRange', function interceptorImpl(start, ...others) {\n        const isUI = isUISelectionStart(start);\n        return {\n            applyNative: !!isUI,\n            realArgs: [\n                Number(start),\n                ...others\n            ],\n            then: ()=>isUI ? undefined : setUISelectionClean(element)\n        };\n    });\n    prepareInterceptor(element, 'selectionStart', function interceptorImpl(v) {\n        return {\n            realArgs: v,\n            then: ()=>setUISelectionClean(element)\n        };\n    });\n    prepareInterceptor(element, 'selectionEnd', function interceptorImpl(v) {\n        return {\n            realArgs: v,\n            then: ()=>setUISelectionClean(element)\n        };\n    });\n    prepareInterceptor(element, 'select', function interceptorImpl() {\n        return {\n            realArgs: [],\n            then: ()=>setUISelectionRaw(element, {\n                    anchorOffset: 0,\n                    focusOffset: getUIValue(element).length\n                })\n        };\n    });\n}\nfunction prepareRangeTextInterceptor(element) {\n    prepareInterceptor(element, 'setRangeText', function interceptorImpl(...realArgs) {\n        return {\n            realArgs,\n            then: ()=>{\n                setUIValueClean(element);\n                setUISelectionClean(element);\n            }\n        };\n    });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/document/prepareDocument.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst isPrepared = Symbol('Node prepared with document state workarounds');\nfunction prepareDocument(document) {\n    if (document[isPrepared]) {\n        return;\n    }\n    document.addEventListener('focus', (e)=>{\n        const el = e.target;\n        prepareElement(el);\n    }, {\n        capture: true,\n        passive: true\n    });\n    // Our test environment defaults to `document.body` as `activeElement`.\n    // In other environments this might be `null` when preparing.\n    // istanbul ignore else\n    if (document.activeElement) {\n        prepareElement(document.activeElement);\n    }\n    document.addEventListener('blur', (e)=>{\n        const el = e.target;\n        const initialValue = getInitialValue(el);\n        if (initialValue !== undefined) {\n            if (el.value !== initialValue) {\n                dispatchDOMEvent(el, 'change');\n            }\n            clearInitialValue(el);\n        }\n    }, {\n        capture: true,\n        passive: true\n    });\n    document[isPrepared] = isPrepared;\n}\nfunction prepareElement(el) {\n    if (el[isPrepared]) {\n        return;\n    }\n    if (isElementType(el, [\n        'input',\n        'textarea'\n    ])) {\n        prepareValueInterceptor(el);\n        prepareSelectionInterceptor(el);\n        prepareRangeTextInterceptor(el);\n    }\n    el[isPrepared] = isPrepared;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/utils/misc/getDocumentFromNode.js\nfunction getDocumentFromNode(el) {\n    return isDocument(el) ? el : el.ownerDocument;\n}\nfunction isDocument(node) {\n    return node.nodeType === 9;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/utils/misc/wait.js\nfunction wait(config) {\n    const delay = config.delay;\n    if (typeof delay !== 'number') {\n        return;\n    }\n    return Promise.all([\n        new Promise((resolve)=>globalThis.setTimeout(()=>resolve(), delay)),\n        config.advanceTimers(delay), \n    ]);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/system/keyboard.js\n\n\n\n\n\n\n\n\n\n\nvar _pressed, _code, _code1;\nvar DOM_KEY_LOCATION;\n(function(DOM_KEY_LOCATION) {\n    DOM_KEY_LOCATION[DOM_KEY_LOCATION[\"STANDARD\"] = 0] = \"STANDARD\";\n    DOM_KEY_LOCATION[DOM_KEY_LOCATION[\"LEFT\"] = 1] = \"LEFT\";\n    DOM_KEY_LOCATION[DOM_KEY_LOCATION[\"RIGHT\"] = 2] = \"RIGHT\";\n    DOM_KEY_LOCATION[DOM_KEY_LOCATION[\"NUMPAD\"] = 3] = \"NUMPAD\";\n})(DOM_KEY_LOCATION || (DOM_KEY_LOCATION = {}));\nconst modifierKeys = [\n    'Alt',\n    'AltGraph',\n    'Control',\n    'Fn',\n    'Meta',\n    'Shift',\n    'Symbol', \n];\nfunction isModifierKey(key) {\n    return modifierKeys.includes(key);\n}\nconst modifierLocks = [\n    'CapsLock',\n    'FnLock',\n    'NumLock',\n    'ScrollLock',\n    'SymbolLock', \n];\nfunction isModifierLock(key) {\n    return modifierLocks.includes(key);\n}\nclass KeyboardHost {\n    isKeyPressed(keyDef) {\n        return !!this.pressed[String(keyDef.code)];\n    }\n    getPressedKeys() {\n        return Object.values(this.pressed).map((p)=>p.keyDef);\n    }\n    /** Press a key */ async keydown(instance, keyDef) {\n        const key = String(keyDef.key);\n        const code = String(keyDef.code);\n        const target = getActiveElementOrBody(instance.config.document);\n        this.setKeydownTarget(target);\n        var ref;\n        (ref = (_pressed = this.pressed)[_code = code]) !== null && ref !== void 0 ? ref : _pressed[_code] = {\n            keyDef,\n            unpreventedDefault: false\n        };\n        if (isModifierKey(key)) {\n            this.modifiers[key] = true;\n        }\n        const unprevented = instance.dispatchUIEvent(target, 'keydown', {\n            key,\n            code\n        });\n        if (isModifierLock(key) && !this.modifiers[key]) {\n            this.modifiers[key] = true;\n            this.modifierLockStart[key] = true;\n        }\n        (_code1 = this.pressed[code]).unpreventedDefault || (_code1.unpreventedDefault = unprevented);\n        if (unprevented && this.hasKeyPress(key)) {\n            instance.dispatchUIEvent(getActiveElementOrBody(instance.config.document), 'keypress', {\n                key,\n                code,\n                charCode: keyDef.key === 'Enter' ? 13 : String(keyDef.key).charCodeAt(0)\n            });\n        }\n    }\n    /** Release a key */ async keyup(instance, keyDef) {\n        const key = String(keyDef.key);\n        const code = String(keyDef.code);\n        const unprevented = this.pressed[code].unpreventedDefault;\n        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n        delete this.pressed[code];\n        if (isModifierKey(key) && !Object.values(this.pressed).find((p)=>p.keyDef.key === key)) {\n            this.modifiers[key] = false;\n        }\n        instance.dispatchUIEvent(getActiveElementOrBody(instance.config.document), 'keyup', {\n            key,\n            code\n        }, !unprevented);\n        if (isModifierLock(key) && this.modifiers[key]) {\n            if (this.modifierLockStart[key]) {\n                this.modifierLockStart[key] = false;\n            } else {\n                this.modifiers[key] = false;\n            }\n        }\n    }\n    setKeydownTarget(target) {\n        if (target !== this.lastKeydownTarget) {\n            this.carryChar = '';\n        }\n        this.lastKeydownTarget = target;\n    }\n    hasKeyPress(key) {\n        return (key.length === 1 || key === 'Enter') && !this.modifiers.Control && !this.modifiers.Alt;\n    }\n    constructor(system){\n        this.modifiers = {\n            Alt: false,\n            AltGraph: false,\n            CapsLock: false,\n            Control: false,\n            Fn: false,\n            FnLock: false,\n            Meta: false,\n            NumLock: false,\n            ScrollLock: false,\n            Shift: false,\n            Symbol: false,\n            SymbolLock: false\n        };\n        this.pressed = {};\n        this.carryChar = '';\n        this.lastKeydownTarget = undefined;\n        this.modifierLockStart = {};\n        this.system = system;\n    }\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/keyboard/keyMap.js\n\n\n/**\n * Mapping for a default US-104-QWERTY keyboard\n */ const defaultKeyMap = [\n    // alphanumeric keys\n    ...'0123456789'.split('').map((c)=>({\n            code: `Digit${c}`,\n            key: c\n        })),\n    ...')!@#$%^&*('.split('').map((c, i)=>({\n            code: `Digit${i}`,\n            key: c,\n            shiftKey: true\n        })),\n    ...'abcdefghijklmnopqrstuvwxyz'.split('').map((c)=>({\n            code: `Key${c.toUpperCase()}`,\n            key: c\n        })),\n    ...'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('').map((c)=>({\n            code: `Key${c}`,\n            key: c,\n            shiftKey: true\n        })),\n    // alphanumeric block - functional\n    {\n        code: 'Space',\n        key: ' '\n    },\n    {\n        code: 'AltLeft',\n        key: 'Alt',\n        location: DOM_KEY_LOCATION.LEFT\n    },\n    {\n        code: 'AltRight',\n        key: 'Alt',\n        location: DOM_KEY_LOCATION.RIGHT\n    },\n    {\n        code: 'ShiftLeft',\n        key: 'Shift',\n        location: DOM_KEY_LOCATION.LEFT\n    },\n    {\n        code: 'ShiftRight',\n        key: 'Shift',\n        location: DOM_KEY_LOCATION.RIGHT\n    },\n    {\n        code: 'ControlLeft',\n        key: 'Control',\n        location: DOM_KEY_LOCATION.LEFT\n    },\n    {\n        code: 'ControlRight',\n        key: 'Control',\n        location: DOM_KEY_LOCATION.RIGHT\n    },\n    {\n        code: 'MetaLeft',\n        key: 'Meta',\n        location: DOM_KEY_LOCATION.LEFT\n    },\n    {\n        code: 'MetaRight',\n        key: 'Meta',\n        location: DOM_KEY_LOCATION.RIGHT\n    },\n    {\n        code: 'OSLeft',\n        key: 'OS',\n        location: DOM_KEY_LOCATION.LEFT\n    },\n    {\n        code: 'OSRight',\n        key: 'OS',\n        location: DOM_KEY_LOCATION.RIGHT\n    },\n    {\n        code: 'Tab',\n        key: 'Tab'\n    },\n    {\n        code: 'CapsLock',\n        key: 'CapsLock'\n    },\n    {\n        code: 'Backspace',\n        key: 'Backspace'\n    },\n    {\n        code: 'Enter',\n        key: 'Enter'\n    },\n    // function\n    {\n        code: 'Escape',\n        key: 'Escape'\n    },\n    // arrows\n    {\n        code: 'ArrowUp',\n        key: 'ArrowUp'\n    },\n    {\n        code: 'ArrowDown',\n        key: 'ArrowDown'\n    },\n    {\n        code: 'ArrowLeft',\n        key: 'ArrowLeft'\n    },\n    {\n        code: 'ArrowRight',\n        key: 'ArrowRight'\n    },\n    // control pad\n    {\n        code: 'Home',\n        key: 'Home'\n    },\n    {\n        code: 'End',\n        key: 'End'\n    },\n    {\n        code: 'Delete',\n        key: 'Delete'\n    },\n    {\n        code: 'PageUp',\n        key: 'PageUp'\n    },\n    {\n        code: 'PageDown',\n        key: 'PageDown'\n    },\n    // Special keys that are not part of a default US-layout but included for specific behavior\n    {\n        code: 'Fn',\n        key: 'Fn'\n    },\n    {\n        code: 'Symbol',\n        key: 'Symbol'\n    },\n    {\n        code: 'AltRight',\n        key: 'AltGraph'\n    }\n];\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/pointer/keyMap.js\nconst keyMap_defaultKeyMap = [\n    {\n        name: 'MouseLeft',\n        pointerType: 'mouse',\n        button: 'primary'\n    },\n    {\n        name: 'MouseRight',\n        pointerType: 'mouse',\n        button: 'secondary'\n    },\n    {\n        name: 'MouseMiddle',\n        pointerType: 'mouse',\n        button: 'auxiliary'\n    },\n    {\n        name: 'TouchA',\n        pointerType: 'touch'\n    },\n    {\n        name: 'TouchB',\n        pointerType: 'touch'\n    },\n    {\n        name: 'TouchC',\n        pointerType: 'touch'\n    }, \n];\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/system/pointer/buttons.js\nclass Buttons {\n    getButtons() {\n        let v = 0;\n        for (const button of Object.keys(this.pressed)){\n            // eslint-disable-next-line no-bitwise\n            v |= 2 ** Number(button);\n        }\n        return v;\n    }\n    down(keyDef) {\n        const button = getMouseButtonId(keyDef.button);\n        if (button in this.pressed) {\n            this.pressed[button].push(keyDef);\n            return undefined;\n        }\n        this.pressed[button] = [\n            keyDef\n        ];\n        return button;\n    }\n    up(keyDef) {\n        const button = getMouseButtonId(keyDef.button);\n        if (button in this.pressed) {\n            this.pressed[button] = this.pressed[button].filter((k)=>k.name !== keyDef.name);\n            if (this.pressed[button].length === 0) {\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete this.pressed[button];\n                return button;\n            }\n        }\n        return undefined;\n    }\n    constructor(){\n        this.pressed = {};\n    }\n}\nconst MouseButton = {\n    primary: 0,\n    secondary: 1,\n    auxiliary: 2,\n    back: 3,\n    X1: 3,\n    forward: 4,\n    X2: 4\n};\nfunction getMouseButtonId(button = 0) {\n    if (button in MouseButton) {\n        return MouseButton[button];\n    }\n    return Number(button);\n}\n// On the `MouseEvent.button` property auxiliary and secondary button are flipped compared to `MouseEvent.buttons`.\nconst MouseButtonFlip = {\n    1: 2,\n    2: 1\n};\nfunction getMouseEventButton(button) {\n    button = getMouseButtonId(button);\n    if (button in MouseButtonFlip) {\n        return MouseButtonFlip[button];\n    }\n    return button;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/system/pointer/device.js\nclass Device {\n    get countPressed() {\n        return this.pressedKeys.size;\n    }\n    isPressed(keyDef) {\n        return this.pressedKeys.has(keyDef.name);\n    }\n    addPressed(keyDef) {\n        return this.pressedKeys.add(keyDef.name);\n    }\n    removePressed(keyDef) {\n        return this.pressedKeys.delete(keyDef.name);\n    }\n    constructor(){\n        this.pressedKeys = new Set();\n    }\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/utils/misc/getTreeDiff.js\nfunction getTreeDiff(a, b) {\n    const treeA = [];\n    for(let el = a; el; el = el.parentElement){\n        treeA.push(el);\n    }\n    const treeB = [];\n    for(let el1 = b; el1; el1 = el1.parentElement){\n        treeB.push(el1);\n    }\n    let i = 0;\n    for(;; i++){\n        if (i >= treeA.length || i >= treeB.length || treeA[treeA.length - 1 - i] !== treeB[treeB.length - 1 - i]) {\n            break;\n        }\n    }\n    return [\n        treeA.slice(0, treeA.length - i),\n        treeB.slice(0, treeB.length - i),\n        treeB.slice(treeB.length - i), \n    ];\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/event/selection/resolveCaretPosition.js\n\n\n\n\n\n\n\n\n\n\n\nfunction resolveCaretPosition({ target , node , offset  }) {\n    if (hasOwnSelection(target)) {\n        return {\n            node: target,\n            offset: offset !== null && offset !== void 0 ? offset : getUIValue(target).length\n        };\n    } else if (node) {\n        return {\n            node,\n            offset: offset !== null && offset !== void 0 ? offset : node.nodeType === 3 ? node.nodeValue.length : node.childNodes.length\n        };\n    }\n    return findNodeAtTextOffset(target, offset);\n}\nfunction findNodeAtTextOffset(node, offset, isRoot = true) {\n    // When clicking after the content the browser behavior can be complicated:\n    // 1. If there is textContent after the last element child,\n    // the cursor is moved there.\n    // 2. If there is textContent in the last element child,\n    // the browser moves the cursor to the last non-empty text node inside this element.\n    // 3. Otherwise the cursor is moved to the end of the target.\n    let i = offset === undefined ? node.childNodes.length - 1 : 0;\n    const step = offset === undefined ? -1 : +1;\n    while(offset === undefined ? i >= (isRoot ? Math.max(node.childNodes.length - 1, 0) : 0) : i <= node.childNodes.length){\n        if (offset && i === node.childNodes.length) {\n            throw new Error('The given offset is out of bounds.');\n        }\n        const c = node.childNodes.item(i);\n        const text = String(c.textContent);\n        if (text.length) {\n            if (offset !== undefined && text.length < offset) {\n                offset -= text.length;\n            } else if (c.nodeType === 1) {\n                return findNodeAtTextOffset(c, offset, false);\n            } else {\n                // The pre-commit hooks keeps changing this\n                // See https://github.com/kentcdodds/kcd-scripts/issues/218\n                /* istanbul ignore else */ // eslint-disable-next-line no-lonely-if\n                if (c.nodeType === 3) {\n                    return {\n                        node: c,\n                        offset: offset !== null && offset !== void 0 ? offset : c.nodeValue.length\n                    };\n                }\n            }\n        }\n        i += step;\n    }\n    return {\n        node,\n        offset: node.childNodes.length\n    };\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/event/selection/setSelectionPerMouse.js\n\n\n\n\n\n\n\n\n\n\n\n\nfunction setSelectionPerMouseDown({ document , target , clickCount , node , offset  }) {\n    if (hasNoSelection(target)) {\n        return;\n    }\n    const targetHasOwnSelection = hasOwnSelection(target);\n    // On non-input elements the text selection per multiple click\n    // can extend beyond the target boundaries.\n    // The exact mechanism what is considered in the same line is unclear.\n    // Looks it might be every inline element.\n    // TODO: Check what might be considered part of the same line of text.\n    const text = String(targetHasOwnSelection ? getUIValue(target) : target.textContent);\n    const [start, end] = node ? // which elements might be considered in the same line of text.\n    // TODO: support expanding initial range on multiple clicks if node is given\n    [\n        offset,\n        offset\n    ] : getTextRange(text, offset, clickCount);\n    // TODO: implement modifying selection per shift/ctrl+mouse\n    if (targetHasOwnSelection) {\n        setUISelection(target, {\n            anchorOffset: start !== null && start !== void 0 ? start : text.length,\n            focusOffset: end !== null && end !== void 0 ? end : text.length\n        });\n        return {\n            node: target,\n            start: start !== null && start !== void 0 ? start : 0,\n            end: end !== null && end !== void 0 ? end : text.length\n        };\n    } else {\n        const { node: startNode , offset: startOffset  } = resolveCaretPosition({\n            target,\n            node,\n            offset: start\n        });\n        const { node: endNode , offset: endOffset  } = resolveCaretPosition({\n            target,\n            node,\n            offset: end\n        });\n        const range = target.ownerDocument.createRange();\n        try {\n            range.setStart(startNode, startOffset);\n            range.setEnd(endNode, endOffset);\n        } catch (e) {\n            throw new Error('The given offset is out of bounds.');\n        }\n        const selection = document.getSelection();\n        selection === null || selection === void 0 ? void 0 : selection.removeAllRanges();\n        selection === null || selection === void 0 ? void 0 : selection.addRange(range.cloneRange());\n        return range;\n    }\n}\nfunction getTextRange(text, pos, clickCount) {\n    if (clickCount % 3 === 1 || text.length === 0) {\n        return [\n            pos,\n            pos\n        ];\n    }\n    const textPos = pos !== null && pos !== void 0 ? pos : text.length;\n    if (clickCount % 3 === 2) {\n        return [\n            textPos - text.substr(0, pos).match(/(\\w+|\\s+|\\W)?$/)[0].length,\n            pos === undefined ? pos : pos + text.substr(pos).match(/^(\\w+|\\s+|\\W)?/)[0].length, \n        ];\n    }\n    // triple click\n    return [\n        textPos - text.substr(0, pos).match(/[^\\r\\n]*$/)[0].length,\n        pos === undefined ? pos : pos + text.substr(pos).match(/^[^\\r\\n]*/)[0].length, \n    ];\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/event/selection/modifySelectionPerMouse.js\n\n\n\n\n\n\n\n\n\n\n\nfunction modifySelectionPerMouseMove(selectionRange, { document , target , node , offset  }) {\n    const selectionFocus = resolveCaretPosition({\n        target,\n        node,\n        offset\n    });\n    if ('node' in selectionRange) {\n        // When the mouse is dragged outside of an input/textarea,\n        // the selection is extended to the beginning or end of the input\n        // depending on pointer position.\n        // TODO: extend selection according to pointer position\n        /* istanbul ignore else */ if (selectionFocus.node === selectionRange.node) {\n            const anchorOffset = selectionFocus.offset < selectionRange.start ? selectionRange.end : selectionRange.start;\n            const focusOffset = selectionFocus.offset > selectionRange.end || selectionFocus.offset < selectionRange.start ? selectionFocus.offset : selectionRange.end;\n            setUISelection(selectionRange.node, {\n                anchorOffset,\n                focusOffset\n            });\n        }\n    } else {\n        const range = selectionRange.cloneRange();\n        const cmp = range.comparePoint(selectionFocus.node, selectionFocus.offset);\n        if (cmp < 0) {\n            range.setStart(selectionFocus.node, selectionFocus.offset);\n        } else if (cmp > 0) {\n            range.setEnd(selectionFocus.node, selectionFocus.offset);\n        }\n        const selection = document.getSelection();\n        selection === null || selection === void 0 ? void 0 : selection.removeAllRanges();\n        selection === null || selection === void 0 ? void 0 : selection.addRange(range.cloneRange());\n    }\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/system/pointer/shared.js\nfunction isDifferentPointerPosition(positionA, positionB) {\n    var ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7;\n    return positionA.target !== positionB.target || ((ref = positionA.coords) === null || ref === void 0 ? void 0 : ref.x) !== ((ref1 = positionB.coords) === null || ref1 === void 0 ? void 0 : ref1.y) || ((ref2 = positionA.coords) === null || ref2 === void 0 ? void 0 : ref2.y) !== ((ref3 = positionB.coords) === null || ref3 === void 0 ? void 0 : ref3.y) || ((ref4 = positionA.caret) === null || ref4 === void 0 ? void 0 : ref4.node) !== ((ref5 = positionB.caret) === null || ref5 === void 0 ? void 0 : ref5.node) || ((ref6 = positionA.caret) === null || ref6 === void 0 ? void 0 : ref6.offset) !== ((ref7 = positionB.caret) === null || ref7 === void 0 ? void 0 : ref7.offset);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/system/pointer/mouse.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * This object is the single \"virtual\" mouse that might be controlled by multiple different pointer devices.\n */ class Mouse {\n    move(instance, position) {\n        const prevPosition = this.position;\n        const prevTarget = this.getTarget(instance);\n        this.position = position;\n        if (!isDifferentPointerPosition(prevPosition, position)) {\n            return;\n        }\n        const nextTarget = this.getTarget(instance);\n        const init = this.getEventInit('mousemove');\n        const [leave, enter] = getTreeDiff(prevTarget, nextTarget);\n        return {\n            leave: ()=>{\n                if (prevTarget !== nextTarget) {\n                    instance.dispatchUIEvent(prevTarget, 'mouseout', init);\n                    leave.forEach((el)=>instance.dispatchUIEvent(el, 'mouseleave', init));\n                }\n            },\n            enter: ()=>{\n                if (prevTarget !== nextTarget) {\n                    instance.dispatchUIEvent(nextTarget, 'mouseover', init);\n                    enter.forEach((el)=>instance.dispatchUIEvent(el, 'mouseenter', init));\n                }\n            },\n            move: ()=>{\n                instance.dispatchUIEvent(nextTarget, 'mousemove', init);\n                this.modifySelecting(instance);\n            }\n        };\n    }\n    down(instance, keyDef, pointer) {\n        const button = this.buttons.down(keyDef);\n        if (button === undefined) {\n            return;\n        }\n        const target = this.getTarget(instance);\n        this.buttonDownTarget[button] = target;\n        const disabled = isDisabled(target);\n        const init = this.getEventInit('mousedown', keyDef.button);\n        if (disabled || instance.dispatchUIEvent(target, 'mousedown', init)) {\n            this.startSelecting(instance, init.detail);\n            focusElement(target);\n        }\n        if (!disabled && getMouseEventButton(keyDef.button) === 2) {\n            instance.dispatchUIEvent(target, 'contextmenu', this.getEventInit('contextmenu', keyDef.button, pointer));\n        }\n    }\n    up(instance, keyDef, pointer) {\n        const button = this.buttons.up(keyDef);\n        if (button === undefined) {\n            return;\n        }\n        const target = this.getTarget(instance);\n        if (!isDisabled(target)) {\n            instance.dispatchUIEvent(target, 'mouseup', this.getEventInit('mouseup', keyDef.button));\n            this.endSelecting();\n            const clickTarget = getTreeDiff(this.buttonDownTarget[button], target)[2][0];\n            if (clickTarget) {\n                const init = this.getEventInit('click', keyDef.button, pointer);\n                if (init.detail) {\n                    instance.dispatchUIEvent(clickTarget, init.button === 0 ? 'click' : 'auxclick', init);\n                    if (init.button === 0 && init.detail === 2) {\n                        instance.dispatchUIEvent(clickTarget, 'dblclick', {\n                            ...this.getEventInit('dblclick', keyDef.button),\n                            detail: init.detail\n                        });\n                    }\n                }\n            }\n        }\n    }\n    resetClickCount() {\n        this.clickCount.reset();\n    }\n    getEventInit(type, button, pointer) {\n        const init = {\n            ...this.position.coords\n        };\n        if (pointer) {\n            init.pointerId = pointer.pointerId;\n            init.pointerType = pointer.pointerType;\n            init.isPrimary = pointer.isPrimary;\n        }\n        init.button = getMouseEventButton(button);\n        init.buttons = this.buttons.getButtons();\n        if (type === 'mousedown') {\n            init.detail = this.clickCount.getOnDown(init.button);\n        } else if (type === 'mouseup') {\n            init.detail = this.clickCount.getOnUp(init.button);\n        } else if (type === 'click' || type === 'auxclick') {\n            init.detail = this.clickCount.incOnClick(init.button);\n        }\n        return init;\n    }\n    getTarget(instance) {\n        var _target;\n        return (_target = this.position.target) !== null && _target !== void 0 ? _target : instance.config.document.body;\n    }\n    startSelecting(instance, clickCount) {\n        var ref, ref1;\n        // TODO: support extending range (shift)\n        this.selecting = setSelectionPerMouseDown({\n            document: instance.config.document,\n            target: this.getTarget(instance),\n            node: (ref = this.position.caret) === null || ref === void 0 ? void 0 : ref.node,\n            offset: (ref1 = this.position.caret) === null || ref1 === void 0 ? void 0 : ref1.offset,\n            clickCount\n        });\n    }\n    modifySelecting(instance) {\n        var ref, ref1;\n        if (!this.selecting) {\n            return;\n        }\n        modifySelectionPerMouseMove(this.selecting, {\n            document: instance.config.document,\n            target: this.getTarget(instance),\n            node: (ref = this.position.caret) === null || ref === void 0 ? void 0 : ref.node,\n            offset: (ref1 = this.position.caret) === null || ref1 === void 0 ? void 0 : ref1.offset\n        });\n    }\n    endSelecting() {\n        this.selecting = undefined;\n    }\n    constructor(){\n        this.position = {};\n        this.buttons = new Buttons();\n        this.buttonDownTarget = {};\n        // According to spec the `detail` on click events should be the number\n        // of *consecutive* clicks with a specific button.\n        // On `mousedown` and `mouseup` it should be this number increased by one.\n        // But the browsers don't implement it this way.\n        // If another button is pressed,\n        //   in Webkit: the `mouseup` on the previously pressed button has `detail: 0` and no `click`/`auxclick`.\n        //   in Gecko: the `mouseup` and click events have the same detail as the `mousedown`.\n        // If there is a delay while a button is pressed,\n        // the `mouseup` and `click` are normal, but a following `mousedown` starts a new click count.\n        // We'll follow the minimal implementation of Webkit.\n        this.clickCount = new class {\n            incOnClick(button) {\n                const current = this.down[button] === undefined ? undefined : Number(this.down[button]) + 1;\n                this.count = this.count[button] === undefined ? {} : {\n                    [button]: Number(this.count[button]) + 1\n                };\n                return current;\n            }\n            getOnDown(button) {\n                var _button;\n                this.down = {\n                    [button]: (_button = this.count[button]) !== null && _button !== void 0 ? _button : 0\n                };\n                var _button1;\n                this.count = {\n                    [button]: (_button1 = this.count[button]) !== null && _button1 !== void 0 ? _button1 : 0\n                };\n                return Number(this.count[button]) + 1;\n            }\n            getOnUp(button) {\n                return this.down[button] === undefined ? undefined : Number(this.down[button]) + 1;\n            }\n            reset() {\n                this.count = {};\n            }\n            constructor(){\n                this.down = {};\n                this.count = {};\n            }\n        }();\n    }\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/utils/pointer/cssPointerEvents.js\n\n\n\n\n\nfunction hasPointerEvents(instance, element) {\n    var ref;\n    return ((ref = checkPointerEvents(instance, element)) === null || ref === void 0 ? void 0 : ref.pointerEvents) !== 'none';\n}\nfunction closestPointerEventsDeclaration(element) {\n    const window = getWindow(element);\n    for(let el = element, tree = []; el === null || el === void 0 ? void 0 : el.ownerDocument; el = el.parentElement){\n        tree.push(el);\n        const pointerEvents = window.getComputedStyle(el).pointerEvents;\n        if (pointerEvents && ![\n            'inherit',\n            'unset'\n        ].includes(pointerEvents)) {\n            return {\n                pointerEvents,\n                tree\n            };\n        }\n    }\n    return undefined;\n}\nconst PointerEventsCheck = Symbol('Last check for pointer-events');\nfunction checkPointerEvents(instance, element) {\n    const lastCheck = element[PointerEventsCheck];\n    const needsCheck = instance.config.pointerEventsCheck !== PointerEventsCheckLevel.Never && (!lastCheck || hasBitFlag(instance.config.pointerEventsCheck, PointerEventsCheckLevel.EachApiCall) && lastCheck[ApiLevel.Call] !== getLevelRef(instance, ApiLevel.Call) || hasBitFlag(instance.config.pointerEventsCheck, PointerEventsCheckLevel.EachTrigger) && lastCheck[ApiLevel.Trigger] !== getLevelRef(instance, ApiLevel.Trigger));\n    if (!needsCheck) {\n        return lastCheck === null || lastCheck === void 0 ? void 0 : lastCheck.result;\n    }\n    const declaration = closestPointerEventsDeclaration(element);\n    element[PointerEventsCheck] = {\n        [ApiLevel.Call]: getLevelRef(instance, ApiLevel.Call),\n        [ApiLevel.Trigger]: getLevelRef(instance, ApiLevel.Trigger),\n        result: declaration\n    };\n    return declaration;\n}\nfunction assertPointerEvents(instance, element) {\n    const declaration = checkPointerEvents(instance, element);\n    if ((declaration === null || declaration === void 0 ? void 0 : declaration.pointerEvents) === 'none') {\n        throw new Error([\n            `Unable to perform pointer interaction as the element ${declaration.tree.length > 1 ? 'inherits' : 'has'} \\`pointer-events: none\\`:`,\n            '',\n            printTree(declaration.tree), \n        ].join('\\n'));\n    }\n}\nfunction printTree(tree) {\n    return tree.reverse().map((el, i)=>[\n            ''.padEnd(i),\n            el.tagName,\n            el.id && `#${el.id}`,\n            el.hasAttribute('data-testid') && `(testId=${el.getAttribute('data-testid')})`,\n            getLabelDescr(el),\n            tree.length > 1 && i === 0 && '  <-- This element declared `pointer-events: none`',\n            tree.length > 1 && i === tree.length - 1 && '  <-- Asserted pointer events here', \n        ].filter(Boolean).join('')).join('\\n');\n}\nfunction getLabelDescr(element) {\n    var ref;\n    let label;\n    if (element.hasAttribute('aria-label')) {\n        label = element.getAttribute('aria-label');\n    } else if (element.hasAttribute('aria-labelledby')) {\n        var ref1, ref2;\n        label = (ref1 = element.ownerDocument.getElementById(element.getAttribute('aria-labelledby'))) === null || ref1 === void 0 ? void 0 : (ref2 = ref1.textContent) === null || ref2 === void 0 ? void 0 : ref2.trim();\n    } else if (isElementType(element, [\n        'button',\n        'input',\n        'meter',\n        'output',\n        'progress',\n        'select',\n        'textarea', \n    ]) && ((ref = element.labels) === null || ref === void 0 ? void 0 : ref.length)) {\n        label = Array.from(element.labels).map((el)=>{\n            var ref;\n            return (ref = el.textContent) === null || ref === void 0 ? void 0 : ref.trim();\n        }).join('|');\n    } else if (isElementType(element, 'button')) {\n        var ref3;\n        label = (ref3 = element.textContent) === null || ref3 === void 0 ? void 0 : ref3.trim();\n    }\n    label = label === null || label === void 0 ? void 0 : label.replace(/\\n/g, '  ');\n    if (Number(label === null || label === void 0 ? void 0 : label.length) > 30) {\n        label = `${label === null || label === void 0 ? void 0 : label.substring(0, 29)}…`;\n    }\n    return label ? `(label=${label})` : '';\n}\n// With the eslint rule and prettier the bitwise operation isn't nice to read\nfunction hasBitFlag(conf, flag) {\n    // eslint-disable-next-line no-bitwise\n    return (conf & flag) > 0;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/system/pointer/pointer.js\n\n\n\n\n\n\n\n\n\n\n\nclass Pointer {\n    init(instance, position) {\n        this.position = position;\n        const target = this.getTarget(instance);\n        const [, enter] = getTreeDiff(null, target);\n        const init = this.getEventInit();\n        assertPointerEvents(instance, target);\n        instance.dispatchUIEvent(target, 'pointerover', init);\n        enter.forEach((el)=>instance.dispatchUIEvent(el, 'pointerenter', init));\n        return this;\n    }\n    move(instance, position) {\n        const prevPosition = this.position;\n        const prevTarget = this.getTarget(instance);\n        this.position = position;\n        if (!isDifferentPointerPosition(prevPosition, position)) {\n            return;\n        }\n        const nextTarget = this.getTarget(instance);\n        const init = this.getEventInit();\n        const [leave, enter] = getTreeDiff(prevTarget, nextTarget);\n        return {\n            leave: ()=>{\n                if (hasPointerEvents(instance, prevTarget)) {\n                    if (prevTarget !== nextTarget) {\n                        instance.dispatchUIEvent(prevTarget, 'pointerout', init);\n                        leave.forEach((el)=>instance.dispatchUIEvent(el, 'pointerleave', init));\n                    }\n                }\n            },\n            enter: ()=>{\n                assertPointerEvents(instance, nextTarget);\n                if (prevTarget !== nextTarget) {\n                    instance.dispatchUIEvent(nextTarget, 'pointerover', init);\n                    enter.forEach((el)=>instance.dispatchUIEvent(el, 'pointerenter', init));\n                }\n            },\n            move: ()=>{\n                instance.dispatchUIEvent(nextTarget, 'pointermove', init);\n            }\n        };\n    }\n    down(instance, _keyDef) {\n        if (this.isDown) {\n            return;\n        }\n        const target = this.getTarget(instance);\n        assertPointerEvents(instance, target);\n        this.isDown = true;\n        this.isPrevented = !instance.dispatchUIEvent(target, 'pointerdown', this.getEventInit());\n    }\n    up(instance, _keyDef) {\n        if (!this.isDown) {\n            return;\n        }\n        const target = this.getTarget(instance);\n        assertPointerEvents(instance, target);\n        this.isDown = false;\n        instance.dispatchUIEvent(target, 'pointerup', this.getEventInit());\n    }\n    release(instance) {\n        const target = this.getTarget(instance);\n        const [leave] = getTreeDiff(target, null);\n        const init = this.getEventInit();\n        // Currently there is no PointerEventsCheckLevel that would\n        // make this check not use the *asserted* cached value from `up`.\n        /* istanbul ignore else */ if (hasPointerEvents(instance, target)) {\n            instance.dispatchUIEvent(target, 'pointerout', init);\n            leave.forEach((el)=>instance.dispatchUIEvent(el, 'pointerleave', init));\n        }\n        this.isCancelled = true;\n    }\n    getTarget(instance) {\n        var _target;\n        return (_target = this.position.target) !== null && _target !== void 0 ? _target : instance.config.document.body;\n    }\n    getEventInit() {\n        return {\n            ...this.position.coords,\n            pointerId: this.pointerId,\n            pointerType: this.pointerType,\n            isPrimary: this.isPrimary\n        };\n    }\n    constructor({ pointerId , pointerType , isPrimary  }){\n        this.isMultitouch = false;\n        this.isCancelled = false;\n        this.isDown = false;\n        this.isPrevented = false;\n        this.position = {};\n        this.pointerId = pointerId;\n        this.pointerType = pointerType;\n        this.isPrimary = isPrimary;\n        this.isMultitouch = !isPrimary;\n    }\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/system/pointer/index.js\n\n\n\n\n\nvar _registry, _k;\nclass PointerHost {\n    isKeyPressed(keyDef) {\n        return this.devices.get(keyDef.pointerType).isPressed(keyDef);\n    }\n    async press(instance, keyDef, position) {\n        const pointerName = this.getPointerName(keyDef);\n        const pointer = keyDef.pointerType === 'touch' ? this.pointers.new(pointerName, keyDef).init(instance, position) : this.pointers.get(pointerName);\n        // TODO: deprecate the following implicit setting of position\n        pointer.position = position;\n        if (pointer.pointerType !== 'touch') {\n            this.mouse.position = position;\n        }\n        this.devices.get(keyDef.pointerType).addPressed(keyDef);\n        this.buttons.down(keyDef);\n        pointer.down(instance, keyDef);\n        if (pointer.pointerType !== 'touch' && !pointer.isPrevented) {\n            this.mouse.down(instance, keyDef, pointer);\n        }\n    }\n    async move(instance, pointerName, position) {\n        const pointer = this.pointers.get(pointerName);\n        // In (some?) browsers this order of events can be observed.\n        // This interweaving of events is probably unnecessary.\n        // While the order of mouse (or pointer) events is defined per spec,\n        // the order in which they interweave/follow on a user interaction depends on the implementation.\n        const pointermove = pointer.move(instance, position);\n        const mousemove = pointer.pointerType === 'touch' || pointer.isPrevented && pointer.isDown ? undefined : this.mouse.move(instance, position);\n        pointermove === null || pointermove === void 0 ? void 0 : pointermove.leave();\n        mousemove === null || mousemove === void 0 ? void 0 : mousemove.leave();\n        pointermove === null || pointermove === void 0 ? void 0 : pointermove.enter();\n        mousemove === null || mousemove === void 0 ? void 0 : mousemove.enter();\n        pointermove === null || pointermove === void 0 ? void 0 : pointermove.move();\n        mousemove === null || mousemove === void 0 ? void 0 : mousemove.move();\n    }\n    async release(instance, keyDef, position) {\n        const device = this.devices.get(keyDef.pointerType);\n        device.removePressed(keyDef);\n        this.buttons.up(keyDef);\n        const pointer = this.pointers.get(this.getPointerName(keyDef));\n        // TODO: deprecate the following implicit setting of position\n        pointer.position = position;\n        if (pointer.pointerType !== 'touch') {\n            this.mouse.position = position;\n        }\n        if (device.countPressed === 0) {\n            pointer.up(instance, keyDef);\n        }\n        if (pointer.pointerType === 'touch') {\n            pointer.release(instance);\n        }\n        if (!pointer.isPrevented) {\n            if (pointer.pointerType === 'touch' && !pointer.isMultitouch) {\n                const mousemove = this.mouse.move(instance, pointer.position);\n                mousemove === null || mousemove === void 0 ? void 0 : mousemove.leave();\n                mousemove === null || mousemove === void 0 ? void 0 : mousemove.enter();\n                mousemove === null || mousemove === void 0 ? void 0 : mousemove.move();\n                this.mouse.down(instance, keyDef, pointer);\n            }\n            if (!pointer.isMultitouch) {\n                const mousemove1 = this.mouse.move(instance, pointer.position);\n                mousemove1 === null || mousemove1 === void 0 ? void 0 : mousemove1.leave();\n                mousemove1 === null || mousemove1 === void 0 ? void 0 : mousemove1.enter();\n                mousemove1 === null || mousemove1 === void 0 ? void 0 : mousemove1.move();\n                this.mouse.up(instance, keyDef, pointer);\n            }\n        }\n    }\n    getPointerName(keyDef) {\n        return keyDef.pointerType === 'touch' ? keyDef.name : keyDef.pointerType;\n    }\n    getPreviousPosition(pointerName) {\n        return this.pointers.has(pointerName) ? this.pointers.get(pointerName).position : undefined;\n    }\n    resetClickCount() {\n        this.mouse.resetClickCount();\n    }\n    getMouseTarget(instance) {\n        var _target;\n        return (_target = this.mouse.position.target) !== null && _target !== void 0 ? _target : instance.config.document.body;\n    }\n    setMousePosition(position) {\n        this.mouse.position = position;\n        this.pointers.get('mouse').position = position;\n    }\n    constructor(system){\n        this.devices = new class {\n            get(k) {\n                var ref;\n                (ref = (_registry = this.registry)[_k = k]) !== null && ref !== void 0 ? ref : _registry[_k] = new Device();\n                return this.registry[k];\n            }\n            constructor(){\n                this.registry = {};\n            }\n        }();\n        this.pointers = new class {\n            new(pointerName, keyDef) {\n                const isPrimary = keyDef.pointerType !== 'touch' || !Object.values(this.registry).some((p)=>p.pointerType === 'touch' && !p.isCancelled);\n                if (!isPrimary) {\n                    Object.values(this.registry).forEach((p)=>{\n                        if (p.pointerType === keyDef.pointerType && !p.isCancelled) {\n                            p.isMultitouch = true;\n                        }\n                    });\n                }\n                this.registry[pointerName] = new Pointer({\n                    pointerId: this.nextId++,\n                    pointerType: keyDef.pointerType,\n                    isPrimary\n                });\n                return this.registry[pointerName];\n            }\n            get(pointerName) {\n                if (!this.has(pointerName)) {\n                    throw new Error(`Trying to access pointer \"${pointerName}\" which does not exist.`);\n                }\n                return this.registry[pointerName];\n            }\n            has(pointerName) {\n                return pointerName in this.registry;\n            }\n            constructor(){\n                this.registry = {\n                    mouse: new Pointer({\n                        pointerId: 1,\n                        pointerType: 'mouse',\n                        isPrimary: true\n                    })\n                };\n                this.nextId = 2;\n            }\n        }();\n        this.system = system;\n        this.buttons = new Buttons();\n        this.mouse = new Mouse();\n    }\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/system/index.js\n\n\n\n/**\n * @internal Do not create/alter this by yourself as this type might be subject to changes.\n */ class System {\n    getUIEventModifiers() {\n        return {\n            altKey: this.keyboard.modifiers.Alt,\n            ctrlKey: this.keyboard.modifiers.Control,\n            metaKey: this.keyboard.modifiers.Meta,\n            shiftKey: this.keyboard.modifiers.Shift,\n            modifierAltGraph: this.keyboard.modifiers.AltGraph,\n            modifierCapsLock: this.keyboard.modifiers.CapsLock,\n            modifierFn: this.keyboard.modifiers.Fn,\n            modifierFnLock: this.keyboard.modifiers.FnLock,\n            modifierNumLock: this.keyboard.modifiers.NumLock,\n            modifierScrollLock: this.keyboard.modifiers.ScrollLock,\n            modifierSymbol: this.keyboard.modifiers.Symbol,\n            modifierSymbolLock: this.keyboard.modifiers.SymbolLock\n        };\n    }\n    constructor(){\n        this.keyboard = new KeyboardHost(this);\n        this.pointer = new PointerHost(this);\n    }\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/convenience/click.js\nasync function click(element) {\n    const pointerIn = [];\n    if (!this.config.skipHover) {\n        pointerIn.push({\n            target: element\n        });\n    }\n    pointerIn.push({\n        keys: '[MouseLeft]',\n        target: element\n    });\n    return this.pointer(pointerIn);\n}\nasync function dblClick(element) {\n    return this.pointer([\n        {\n            target: element\n        },\n        '[MouseLeft][MouseLeft]'\n    ]);\n}\nasync function tripleClick(element) {\n    return this.pointer([\n        {\n            target: element\n        },\n        '[MouseLeft][MouseLeft][MouseLeft]'\n    ]);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/convenience/hover.js\n\n\n\n\n\n\n\n\n\nasync function hover(element) {\n    return this.pointer({\n        target: element\n    });\n}\nasync function unhover(element) {\n    assertPointerEvents(this, this.system.pointer.getMouseTarget(this));\n    return this.pointer({\n        target: element.ownerDocument.body\n    });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/convenience/tab.js\nasync function tab({ shift  } = {}) {\n    return this.keyboard(shift === true ? '{Shift>}{Tab}{/Shift}' : shift === false ? '[/ShiftLeft][/ShiftRight]{Tab}' : '{Tab}');\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/keyboard/parseKeyDef.js\n\n\n\n\n\n\n\n\n\n/**\n * Parse key defintions per `keyboardMap`\n *\n * Keys can be referenced by `{key}` or `{special}` as well as physical locations per `[code]`.\n * Everything else will be interpreted as a typed character - e.g. `a`.\n * Brackets `{` and `[` can be escaped by doubling - e.g. `foo[[bar` translates to `foo[bar`.\n * Keeping the key pressed can be written as `{key>}`.\n * When keeping the key pressed you can choose how long (how many keydown and keypress) the key is pressed `{key>3}`.\n * You can then release the key per `{key>3/}` or keep it pressed and continue with the next key.\n */ function parseKeyDef(keyboardMap, text) {\n    const defs = [];\n    do {\n        const { type , descriptor , consumedLength , releasePrevious , releaseSelf =true , repeat ,  } = readNextDescriptor(text, 'keyboard');\n        var ref;\n        const keyDef = (ref = keyboardMap.find((def)=>{\n            if (type === '[') {\n                var ref;\n                return ((ref = def.code) === null || ref === void 0 ? void 0 : ref.toLowerCase()) === descriptor.toLowerCase();\n            } else if (type === '{') {\n                var ref1;\n                return ((ref1 = def.key) === null || ref1 === void 0 ? void 0 : ref1.toLowerCase()) === descriptor.toLowerCase();\n            }\n            return def.key === descriptor;\n        })) !== null && ref !== void 0 ? ref : {\n            key: 'Unknown',\n            code: 'Unknown',\n            [type === '[' ? 'code' : 'key']: descriptor\n        };\n        defs.push({\n            keyDef,\n            releasePrevious,\n            releaseSelf,\n            repeat\n        });\n        text = text.slice(consumedLength);\n    }while (text)\n    return defs;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/keyboard/index.js\n\n\n\n\n\n\n\n\n\n\n\nasync function keyboard(text) {\n    const actions = parseKeyDef(this.config.keyboardMap, text);\n    for(let i = 0; i < actions.length; i++){\n        await wait(this.config);\n        await keyboardAction(this, actions[i]);\n    }\n}\nasync function keyboardAction(instance, { keyDef , releasePrevious , releaseSelf , repeat  }) {\n    const { system  } = instance;\n    // Release the key automatically if it was pressed before.\n    if (system.keyboard.isKeyPressed(keyDef)) {\n        await system.keyboard.keyup(instance, keyDef);\n    }\n    if (!releasePrevious) {\n        for(let i = 1; i <= repeat; i++){\n            await system.keyboard.keydown(instance, keyDef);\n            if (i < repeat) {\n                await wait(instance.config);\n            }\n        }\n        // Release the key only on the last iteration on `state.repeatKey`.\n        if (releaseSelf) {\n            await system.keyboard.keyup(instance, keyDef);\n        }\n    }\n}\nasync function releaseAllKeys(instance) {\n    for (const k of instance.system.keyboard.getPressedKeys()){\n        await instance.system.keyboard.keyup(instance, k);\n    }\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/document/copySelection.js\n\n\n\n\n\n\n\n\n\n\n\n\nfunction copySelection(target) {\n    const data = hasOwnSelection(target) ? {\n        'text/plain': readSelectedValueFromInput(target)\n    } : {\n        'text/plain': String(target.ownerDocument.getSelection())\n    };\n    const dt = createDataTransfer(getWindow(target));\n    for(const type in data){\n        if (data[type]) {\n            dt.setData(type, data[type]);\n        }\n    }\n    return dt;\n}\nfunction readSelectedValueFromInput(target) {\n    const sel = getUISelection(target);\n    const val = getUIValue(target);\n    return val.substring(sel.startOffset, sel.endOffset);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/clipboard/copy.js\n\n\n\n\n\n\n\n\n\n\nasync function copy() {\n    const doc = this.config.document;\n    var _activeElement;\n    const target = (_activeElement = doc.activeElement) !== null && _activeElement !== void 0 ? _activeElement : /* istanbul ignore next */ doc.body;\n    const clipboardData = copySelection(target);\n    if (clipboardData.items.length === 0) {\n        return;\n    }\n    if (this.dispatchUIEvent(target, 'copy', {\n        clipboardData\n    }) && this.config.writeToClipboard) {\n        await writeDataTransferToClipboard(doc, clipboardData);\n    }\n    return clipboardData;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/clipboard/cut.js\n\n\n\n\n\n\n\n\n\n\nasync function cut() {\n    const doc = this.config.document;\n    var _activeElement;\n    const target = (_activeElement = doc.activeElement) !== null && _activeElement !== void 0 ? _activeElement : /* istanbul ignore next */ doc.body;\n    const clipboardData = copySelection(target);\n    if (clipboardData.items.length === 0) {\n        return;\n    }\n    if (this.dispatchUIEvent(target, 'cut', {\n        clipboardData\n    }) && this.config.writeToClipboard) {\n        await writeDataTransferToClipboard(target.ownerDocument, clipboardData);\n    }\n    return clipboardData;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/clipboard/paste.js\n\n\n\n\n\n\n\n\n\n\nasync function paste(clipboardData) {\n    const doc = this.config.document;\n    var _activeElement;\n    const target = (_activeElement = doc.activeElement) !== null && _activeElement !== void 0 ? _activeElement : /* istanbul ignore next */ doc.body;\n    var ref;\n    const dataTransfer = (ref = typeof clipboardData === 'string' ? getClipboardDataFromString(doc, clipboardData) : clipboardData) !== null && ref !== void 0 ? ref : await readDataTransferFromClipboard(doc).catch(()=>{\n        throw new Error('`userEvent.paste()` without `clipboardData` requires the `ClipboardAPI` to be available.');\n    });\n    this.dispatchUIEvent(target, 'paste', {\n        clipboardData: dataTransfer\n    });\n}\nfunction getClipboardDataFromString(doc, text) {\n    const dt = createDataTransfer(getWindow(doc));\n    dt.setData('text', text);\n    return dt;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/pointer/parseKeyDef.js\n\n\n\n\n\n\n\n\n\nfunction parseKeyDef_parseKeyDef(pointerMap, keys) {\n    const defs = [];\n    do {\n        const { descriptor , consumedLength , releasePrevious , releaseSelf =true ,  } = readNextDescriptor(keys, 'pointer');\n        const keyDef = pointerMap.find((p)=>p.name === descriptor);\n        if (keyDef) {\n            defs.push({\n                keyDef,\n                releasePrevious,\n                releaseSelf\n            });\n        }\n        keys = keys.slice(consumedLength);\n    }while (keys)\n    return defs;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/pointer/index.js\n\n\n\n\n\n\n\n\n\n\n\nasync function pointer(input) {\n    const { pointerMap  } = this.config;\n    const actions = [];\n    (Array.isArray(input) ? input : [\n        input\n    ]).forEach((actionInput)=>{\n        if (typeof actionInput === 'string') {\n            actions.push(...parseKeyDef_parseKeyDef(pointerMap, actionInput));\n        } else if ('keys' in actionInput) {\n            actions.push(...parseKeyDef_parseKeyDef(pointerMap, actionInput.keys).map((i)=>({\n                    ...actionInput,\n                    ...i\n                })));\n        } else {\n            actions.push(actionInput);\n        }\n    });\n    for(let i = 0; i < actions.length; i++){\n        await wait(this.config);\n        await pointerAction(this, actions[i]);\n    }\n    this.system.pointer.resetClickCount();\n}\nasync function pointerAction(instance, action) {\n    var ref, ref1;\n    const pointerName = 'pointerName' in action && action.pointerName ? action.pointerName : 'keyDef' in action ? instance.system.pointer.getPointerName(action.keyDef) : 'mouse';\n    const previousPosition = instance.system.pointer.getPreviousPosition(pointerName);\n    var _target, _coords, _node, _offset;\n    const position = {\n        target: (_target = action.target) !== null && _target !== void 0 ? _target : getPrevTarget(instance, previousPosition),\n        coords: (_coords = action.coords) !== null && _coords !== void 0 ? _coords : previousPosition === null || previousPosition === void 0 ? void 0 : previousPosition.coords,\n        caret: {\n            node: (_node = action.node) !== null && _node !== void 0 ? _node : hasCaretPosition(action) ? undefined : previousPosition === null || previousPosition === void 0 ? void 0 : (ref = previousPosition.caret) === null || ref === void 0 ? void 0 : ref.node,\n            offset: (_offset = action.offset) !== null && _offset !== void 0 ? _offset : hasCaretPosition(action) ? undefined : previousPosition === null || previousPosition === void 0 ? void 0 : (ref1 = previousPosition.caret) === null || ref1 === void 0 ? void 0 : ref1.offset\n        }\n    };\n    if ('keyDef' in action) {\n        if (instance.system.pointer.isKeyPressed(action.keyDef)) {\n            setLevelRef(instance, ApiLevel.Trigger);\n            await instance.system.pointer.release(instance, action.keyDef, position);\n        }\n        if (!action.releasePrevious) {\n            setLevelRef(instance, ApiLevel.Trigger);\n            await instance.system.pointer.press(instance, action.keyDef, position);\n            if (action.releaseSelf) {\n                setLevelRef(instance, ApiLevel.Trigger);\n                await instance.system.pointer.release(instance, action.keyDef, position);\n            }\n        }\n    } else {\n        setLevelRef(instance, ApiLevel.Trigger);\n        await instance.system.pointer.move(instance, pointerName, position);\n    }\n}\nfunction hasCaretPosition(action) {\n    var _target, ref;\n    return !!((ref = (_target = action.target) !== null && _target !== void 0 ? _target : action.node) !== null && ref !== void 0 ? ref : action.offset !== undefined);\n}\nfunction getPrevTarget(instance, position) {\n    if (!position) {\n        throw new Error('This pointer has no previous position. Provide a target property!');\n    }\n    var _target;\n    return (_target = position.target) !== null && _target !== void 0 ? _target : instance.config.document.body;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/utility/clear.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nasync function clear(element) {\n    if (!isEditable(element) || isDisabled(element)) {\n        throw new Error('clear()` is only supported on editable elements.');\n    }\n    focusElement(element);\n    if (element.ownerDocument.activeElement !== element) {\n        throw new Error('The element to be cleared could not be focused.');\n    }\n    selectAll(element);\n    if (!isAllSelected(element)) {\n        throw new Error('The element content to be cleared could not be selected.');\n    }\n    input(this, element, '', 'deleteContentBackward');\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/utility/selectOptions.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nasync function selectOptions(select, values) {\n    return selectOptionsBase.call(this, true, select, values);\n}\nasync function deselectOptions(select, values) {\n    return selectOptionsBase.call(this, false, select, values);\n}\nasync function selectOptionsBase(newValue, select, values) {\n    if (!newValue && !select.multiple) {\n        throw (0,dom_esm.getConfig)().getElementError(`Unable to deselect an option in a non-multiple select. Use selectOptions to change the selection instead.`, select);\n    }\n    const valArray = Array.isArray(values) ? values : [\n        values\n    ];\n    const allOptions = Array.from(select.querySelectorAll('option, [role=\"option\"]'));\n    const selectedOptions = valArray.map((val)=>{\n        if (typeof val !== 'string' && allOptions.includes(val)) {\n            return val;\n        } else {\n            const matchingOption = allOptions.find((o)=>o.value === val || o.innerHTML === val);\n            if (matchingOption) {\n                return matchingOption;\n            } else {\n                throw (0,dom_esm.getConfig)().getElementError(`Value \"${String(val)}\" not found in options`, select);\n            }\n        }\n    }).filter((option)=>!isDisabled(option));\n    if (isDisabled(select) || !selectedOptions.length) return;\n    const selectOption = (option)=>{\n        option.selected = newValue;\n        this.dispatchUIEvent(select, 'input', {\n            bubbles: true,\n            cancelable: false,\n            composed: true\n        });\n        this.dispatchUIEvent(select, 'change');\n    };\n    if (isElementType(select, 'select')) {\n        if (select.multiple) {\n            for (const option of selectedOptions){\n                const withPointerEvents = this.config.pointerEventsCheck === 0 ? true : hasPointerEvents(this, option);\n                // events fired for multiple select are weird. Can't use hover...\n                if (withPointerEvents) {\n                    this.dispatchUIEvent(option, 'pointerover');\n                    this.dispatchUIEvent(select, 'pointerenter');\n                    this.dispatchUIEvent(option, 'mouseover');\n                    this.dispatchUIEvent(select, 'mouseenter');\n                    this.dispatchUIEvent(option, 'pointermove');\n                    this.dispatchUIEvent(option, 'mousemove');\n                    this.dispatchUIEvent(option, 'pointerdown');\n                    this.dispatchUIEvent(option, 'mousedown');\n                }\n                focusElement(select);\n                if (withPointerEvents) {\n                    this.dispatchUIEvent(option, 'pointerup');\n                    this.dispatchUIEvent(option, 'mouseup');\n                }\n                selectOption(option);\n                if (withPointerEvents) {\n                    this.dispatchUIEvent(option, 'click');\n                }\n                await wait(this.config);\n            }\n        } else if (selectedOptions.length === 1) {\n            const withPointerEvents1 = this.config.pointerEventsCheck === 0 ? true : hasPointerEvents(this, select);\n            // the click to open the select options\n            if (withPointerEvents1) {\n                await this.click(select);\n            } else {\n                focusElement(select);\n            }\n            selectOption(selectedOptions[0]);\n            if (withPointerEvents1) {\n                // the browser triggers another click event on the select for the click on the option\n                // this second click has no 'down' phase\n                this.dispatchUIEvent(select, 'pointerover');\n                this.dispatchUIEvent(select, 'pointerenter');\n                this.dispatchUIEvent(select, 'mouseover');\n                this.dispatchUIEvent(select, 'mouseenter');\n                this.dispatchUIEvent(select, 'pointerup');\n                this.dispatchUIEvent(select, 'mouseup');\n                this.dispatchUIEvent(select, 'click');\n            }\n            await wait(this.config);\n        } else {\n            throw (0,dom_esm.getConfig)().getElementError(`Cannot select multiple options on a non-multiple select`, select);\n        }\n    } else if (select.getAttribute('role') === 'listbox') {\n        for (const option1 of selectedOptions){\n            await this.click(option1);\n            await this.unhover(option1);\n        }\n    } else {\n        throw (0,dom_esm.getConfig)().getElementError(`Cannot select options on elements that are neither select nor listbox elements`, select);\n    }\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/utility/type.js\n\n\n\n\n\n\n\n\n\n\n\nasync function type(element, text, { skipClick =this.config.skipClick , skipAutoClose =this.config.skipAutoClose , initialSelectionStart , initialSelectionEnd  } = {}) {\n    // TODO: properly type guard\n    // we use this workaround for now to prevent changing behavior\n    if (element.disabled) return;\n    if (!skipClick) {\n        await this.click(element);\n    }\n    if (initialSelectionStart !== undefined) {\n        setSelectionRange(element, initialSelectionStart, initialSelectionEnd !== null && initialSelectionEnd !== void 0 ? initialSelectionEnd : initialSelectionStart);\n    }\n    await this.keyboard(text);\n    if (!skipAutoClose) {\n        await releaseAllKeys(this);\n    }\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/utils/edit/setFiles.js\n// It is not possible to create a real FileList programmatically.\n// Therefore assigning `files` property with a programmatically created FileList results in an error.\n// Just assigning the property (as per fireEvent) breaks the interweaving with the `value` property.\nconst fakeFiles = Symbol('files and value properties are mocked');\nfunction restoreProperty(obj, prop, descriptor) {\n    if (descriptor) {\n        Object.defineProperty(obj, prop, descriptor);\n    } else {\n        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n        delete obj[prop];\n    }\n}\nfunction setFiles(el, files) {\n    var ref;\n    (ref = el[fakeFiles]) === null || ref === void 0 ? void 0 : ref.restore();\n    const typeDescr = Object.getOwnPropertyDescriptor(el, 'type');\n    const valueDescr = Object.getOwnPropertyDescriptor(el, 'value');\n    const filesDescr = Object.getOwnPropertyDescriptor(el, 'files');\n    function restore() {\n        restoreProperty(el, 'type', typeDescr);\n        restoreProperty(el, 'value', valueDescr);\n        restoreProperty(el, 'files', filesDescr);\n    }\n    el[fakeFiles] = {\n        restore\n    };\n    Object.defineProperties(el, {\n        files: {\n            configurable: true,\n            get: ()=>files\n        },\n        value: {\n            configurable: true,\n            get: ()=>files.length ? `C:\\\\fakepath\\\\${files[0].name}` : '',\n            set (v) {\n                if (v === '') {\n                    restore();\n                } else {\n                    var ref;\n                    valueDescr === null || valueDescr === void 0 ? void 0 : (ref = valueDescr.set) === null || ref === void 0 ? void 0 : ref.call(el, v);\n                }\n            }\n        },\n        type: {\n            configurable: true,\n            get: ()=>'file',\n            set (v) {\n                if (v !== 'file') {\n                    restore();\n                    el.type = v;\n                }\n            }\n        }\n    });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/utility/upload.js\n\n\n\n\n\n\n\n\n\n\n\n\n\nasync function upload(element, fileOrFiles) {\n    const input = isElementType(element, 'label') ? element.control : element;\n    if (!input || !isElementType(input, 'input', {\n        type: 'file'\n    })) {\n        throw new TypeError(`The ${input === element ? 'given' : 'associated'} ${input === null || input === void 0 ? void 0 : input.tagName} element does not accept file uploads`);\n    }\n    if (isDisabled(element)) return;\n    const files = (Array.isArray(fileOrFiles) ? fileOrFiles : [\n        fileOrFiles\n    ]).filter((file)=>!this.config.applyAccept || isAcceptableFile(file, input.accept)).slice(0, input.multiple ? undefined : 1);\n    const fileDialog = ()=>{\n        var ref;\n        // do not fire an input event if the file selection does not change\n        if (files.length === ((ref = input.files) === null || ref === void 0 ? void 0 : ref.length) && files.every((f, i)=>{\n            var ref;\n            return f === ((ref = input.files) === null || ref === void 0 ? void 0 : ref.item(i));\n        })) {\n            return;\n        }\n        setFiles(input, createFileList(getWindow(element), files));\n        this.dispatchUIEvent(input, 'input');\n        this.dispatchUIEvent(input, 'change');\n    };\n    input.addEventListener('fileDialog', fileDialog);\n    await this.click(element);\n    input.removeEventListener('fileDialog', fileDialog);\n}\nfunction isAcceptableFile(file, accept) {\n    if (!accept) {\n        return true;\n    }\n    const wildcards = [\n        'audio/*',\n        'image/*',\n        'video/*'\n    ];\n    return accept.split(',').some((acceptToken)=>{\n        if (acceptToken.startsWith('.')) {\n            // tokens starting with a dot represent a file extension\n            return file.name.endsWith(acceptToken);\n        } else if (wildcards.includes(acceptToken)) {\n            return file.type.startsWith(acceptToken.substr(0, acceptToken.length - 1));\n        }\n        return file.type === acceptToken;\n    });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/setup/api.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/setup/wrapAsync.js\n\n\n/**\n * Wrap an internal Promise\n */ function wrapAsync(implementation) {\n    return (0,dom_esm.getConfig)().asyncWrapper(implementation);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/setup/setup.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Default options applied when API is called per `userEvent.anyApi()`\n */ const defaultOptionsDirect = {\n    applyAccept: true,\n    autoModify: true,\n    delay: 0,\n    document: globalThis.document,\n    keyboardMap: defaultKeyMap,\n    pointerMap: keyMap_defaultKeyMap,\n    pointerEventsCheck: PointerEventsCheckLevel.EachApiCall,\n    skipAutoClose: false,\n    skipClick: false,\n    skipHover: false,\n    writeToClipboard: false,\n    advanceTimers: ()=>Promise.resolve()\n};\n/**\n * Default options applied when API is called per `userEvent().anyApi()`\n */ const defaultOptionsSetup = {\n    ...defaultOptionsDirect,\n    writeToClipboard: true\n};\nfunction createConfig(options = {}, defaults = defaultOptionsSetup, node) {\n    const document = getDocument(options, node, defaults);\n    return {\n        ...defaults,\n        ...options,\n        document\n    };\n}\n/**\n * Start a \"session\" with userEvent.\n * All APIs returned by this function share an input device state and a default configuration.\n */ function setupMain(options = {}) {\n    const config = createConfig(options);\n    prepareDocument(config.document);\n    var _defaultView;\n    const view = (_defaultView = config.document.defaultView) !== null && _defaultView !== void 0 ? _defaultView : /* istanbul ignore next */ globalThis.window;\n    attachClipboardStubToView(view);\n    return createInstance(config).api;\n}\n/**\n * Setup in direct call per `userEvent.anyApi()`\n */ function setupDirect({ keyboardState , pointerState , ...options } = {}, node) {\n    const config = createConfig(options, defaultOptionsDirect, node);\n    prepareDocument(config.document);\n    var ref;\n    const system = (ref = pointerState !== null && pointerState !== void 0 ? pointerState : keyboardState) !== null && ref !== void 0 ? ref : new System();\n    return {\n        api: createInstance(config, system).api,\n        system\n    };\n}\n/**\n * Create a set of callbacks with different default settings but the same state.\n */ function setupSub(options) {\n    return createInstance({\n        ...this.config,\n        ...options\n    }, this.system).api;\n}\nfunction wrapAndBindImpl(instance, impl) {\n    function method(...args) {\n        setLevelRef(instance, ApiLevel.Call);\n        return wrapAsync(()=>impl.apply(instance, args).then(async (ret)=>{\n                await wait(instance.config);\n                return ret;\n            }));\n    }\n    Object.defineProperty(method, 'name', {\n        get: ()=>impl.name\n    });\n    return method;\n}\nfunction createInstance(config, system = new System()) {\n    const instance = {};\n    Object.assign(instance, {\n        config,\n        dispatchEvent: dispatchEvent.bind(instance),\n        dispatchUIEvent: dispatchUIEvent.bind(instance),\n        system,\n        levelRefs: {},\n        ...api_namespaceObject\n    });\n    return {\n        instance,\n        api: {\n            ...Object.fromEntries(Object.entries(api_namespaceObject).map(([name, api])=>[\n                    name,\n                    wrapAndBindImpl(instance, api), \n                ])),\n            setup: setupSub.bind(instance)\n        }\n    };\n}\nfunction getDocument(options, node, defaults) {\n    var _document, ref;\n    return (ref = (_document = options.document) !== null && _document !== void 0 ? _document : node && getDocumentFromNode(node)) !== null && ref !== void 0 ? ref : defaults.document;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/setup/directApi.js\n\n\nfunction directApi_clear(element) {\n    return setupDirect().api.clear(element);\n}\nfunction directApi_click(element, options = {}) {\n    return setupDirect(options, element).api.click(element);\n}\nfunction directApi_copy(options = {}) {\n    return setupDirect(options).api.copy();\n}\nfunction directApi_cut(options = {}) {\n    return setupDirect(options).api.cut();\n}\nfunction directApi_dblClick(element, options = {}) {\n    return setupDirect(options).api.dblClick(element);\n}\nfunction directApi_deselectOptions(select, values, options = {}) {\n    return setupDirect(options).api.deselectOptions(select, values);\n}\nfunction directApi_hover(element, options = {}) {\n    return setupDirect(options).api.hover(element);\n}\nasync function directApi_keyboard(text, options = {}) {\n    const { api , system  } = setupDirect(options);\n    return api.keyboard(text).then(()=>system);\n}\nasync function directApi_pointer(input, options = {}) {\n    const { api , system  } = setupDirect(options);\n    return api.pointer(input).then(()=>system);\n}\nfunction directApi_paste(clipboardData, options) {\n    return setupDirect(options).api.paste(clipboardData);\n}\nfunction directApi_selectOptions(select, values, options = {}) {\n    return setupDirect(options).api.selectOptions(select, values);\n}\nfunction directApi_tripleClick(element, options = {}) {\n    return setupDirect(options).api.tripleClick(element);\n}\nfunction directApi_type(element, text, options = {}) {\n    return setupDirect(options, element).api.type(element, text, options);\n}\nfunction directApi_unhover(element, options = {}) {\n    const { api , system  } = setupDirect(options);\n    system.pointer.setMousePosition({\n        target: element\n    });\n    return api.unhover(element);\n}\nfunction directApi_upload(element, fileOrFiles, options = {}) {\n    return setupDirect(options).api.upload(element, fileOrFiles);\n}\nfunction directApi_tab(options = {}) {\n    return setupDirect().api.tab(options);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/setup/index.js\n\n\n\nconst userEvent = {\n    ...directApi_namespaceObject,\n    setup: setupMain\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/node_modules/@testing-library/user-event/dist/esm/index.js\n\n\n\n// EXTERNAL MODULE: ./node_modules/ts-dedent/esm/index.js\nvar esm = __webpack_require__(\"./node_modules/ts-dedent/esm/index.js\");\n;// CONCATENATED MODULE: ./node_modules/@storybook/testing-library/dist/index.mjs\n// node_modules/@storybook/global/dist/index.mjs\nvar scope = (() => {\n  let win;\n  return typeof window < \"u\" ? win = window : typeof globalThis < \"u\" ? win = globalThis : typeof __webpack_require__.g < \"u\" ? win = __webpack_require__.g : typeof self < \"u\" ? win = self : win = {}, win;\n})();\n\n// node_modules/@storybook/client-logger/dist/index.mjs\nvar { LOGLEVEL } = scope, levels = { trace: 1, debug: 2, info: 3, warn: 4, error: 5, silent: 10 }, currentLogLevelString = LOGLEVEL, currentLogLevelNumber = levels[currentLogLevelString] || levels.info, logger = { trace: (message, ...rest) => {\n  currentLogLevelNumber <= levels.trace && console.trace(message, ...rest);\n}, debug: (message, ...rest) => {\n  currentLogLevelNumber <= levels.debug && console.debug(message, ...rest);\n}, info: (message, ...rest) => {\n  currentLogLevelNumber <= levels.info && console.info(message, ...rest);\n}, warn: (message, ...rest) => {\n  currentLogLevelNumber <= levels.warn && console.warn(message, ...rest);\n}, error: (message, ...rest) => {\n  currentLogLevelNumber <= levels.error && console.error(message, ...rest);\n}, log: (message, ...rest) => {\n  currentLogLevelNumber < levels.silent && console.log(message, ...rest);\n} }, logged = /* @__PURE__ */ new Set(), once = (type) => (message, ...rest) => {\n  if (!logged.has(message))\n    return logged.add(message), logger[type](message, ...rest);\n};\nonce.clear = () => logged.clear();\nonce.trace = once(\"trace\");\nonce.debug = once(\"debug\");\nonce.info = once(\"info\");\nonce.warn = once(\"warn\");\nonce.error = once(\"error\");\nonce.log = once(\"log\");\nvar deprecate = once(\"warn\"), pretty = (type) => (...args) => {\n  let argArray = [];\n  if (args.length) {\n    let startTagRe = /<span\\s+style=(['\"])([^'\"]*)\\1\\s*>/gi, endTagRe = /<\\/span>/gi, reResultArray;\n    for (argArray.push(args[0].replace(startTagRe, \"%c\").replace(endTagRe, \"%c\")); reResultArray = startTagRe.exec(args[0]); )\n      argArray.push(reResultArray[2]), argArray.push(\"\");\n    for (let j = 1; j < args.length; j++)\n      argArray.push(args[j]);\n  }\n  logger[type].apply(logger, argArray);\n};\npretty.trace = pretty(\"trace\");\npretty.debug = pretty(\"debug\");\npretty.info = pretty(\"info\");\npretty.warn = pretty(\"warn\");\npretty.error = pretty(\"error\");\n\n// node_modules/@storybook/channels/dist/index.mjs\nvar generateRandomId = () => Math.random().toString(16).slice(2), Channel = class {\n  constructor({ transport, async = !1 } = {}) {\n    this.sender = generateRandomId(), this.events = {}, this.data = {}, this.transport = void 0, this.isAsync = async, transport && (this.transport = transport, this.transport.setHandler((event) => this.handleEvent(event)));\n  }\n  get hasTransport() {\n    return !!this.transport;\n  }\n  addListener(eventName, listener) {\n    this.events[eventName] = this.events[eventName] || [], this.events[eventName].push(listener);\n  }\n  emit(eventName, ...args) {\n    let event = { type: eventName, args, from: this.sender }, options = {};\n    args.length >= 1 && args[0] && args[0].options && (options = args[0].options);\n    let handler = () => {\n      this.transport && this.transport.send(event, options), this.handleEvent(event);\n    };\n    this.isAsync ? setImmediate(handler) : handler();\n  }\n  last(eventName) {\n    return this.data[eventName];\n  }\n  eventNames() {\n    return Object.keys(this.events);\n  }\n  listenerCount(eventName) {\n    let listeners = this.listeners(eventName);\n    return listeners ? listeners.length : 0;\n  }\n  listeners(eventName) {\n    return this.events[eventName] || void 0;\n  }\n  once(eventName, listener) {\n    let onceListener = this.onceListener(eventName, listener);\n    this.addListener(eventName, onceListener);\n  }\n  removeAllListeners(eventName) {\n    eventName ? this.events[eventName] && delete this.events[eventName] : this.events = {};\n  }\n  removeListener(eventName, listener) {\n    let listeners = this.listeners(eventName);\n    listeners && (this.events[eventName] = listeners.filter((l) => l !== listener));\n  }\n  on(eventName, listener) {\n    this.addListener(eventName, listener);\n  }\n  off(eventName, listener) {\n    this.removeListener(eventName, listener);\n  }\n  handleEvent(event) {\n    let listeners = this.listeners(event.type);\n    listeners && listeners.length && listeners.forEach((fn) => {\n      fn.apply(event, event.args);\n    }), this.data[event.type] = event.args;\n  }\n  onceListener(eventName, listener) {\n    let onceListener = (...args) => (this.removeListener(eventName, onceListener), listener(...args));\n    return onceListener;\n  }\n};\n\n// node_modules/@storybook/core-events/dist/index.mjs\nvar events = ((events2) => (events2.CHANNEL_CREATED = \"channelCreated\", events2.CONFIG_ERROR = \"configError\", events2.STORY_INDEX_INVALIDATED = \"storyIndexInvalidated\", events2.STORY_SPECIFIED = \"storySpecified\", events2.SET_CONFIG = \"setConfig\", events2.SET_STORIES = \"setStories\", events2.SET_INDEX = \"setIndex\", events2.SET_CURRENT_STORY = \"setCurrentStory\", events2.CURRENT_STORY_WAS_SET = \"currentStoryWasSet\", events2.FORCE_RE_RENDER = \"forceReRender\", events2.FORCE_REMOUNT = \"forceRemount\", events2.PRELOAD_ENTRIES = \"preloadStories\", events2.STORY_PREPARED = \"storyPrepared\", events2.DOCS_PREPARED = \"docsPrepared\", events2.STORY_CHANGED = \"storyChanged\", events2.STORY_UNCHANGED = \"storyUnchanged\", events2.STORY_RENDERED = \"storyRendered\", events2.STORY_MISSING = \"storyMissing\", events2.STORY_ERRORED = \"storyErrored\", events2.STORY_THREW_EXCEPTION = \"storyThrewException\", events2.STORY_RENDER_PHASE_CHANGED = \"storyRenderPhaseChanged\", events2.PLAY_FUNCTION_THREW_EXCEPTION = \"playFunctionThrewException\", events2.UPDATE_STORY_ARGS = \"updateStoryArgs\", events2.STORY_ARGS_UPDATED = \"storyArgsUpdated\", events2.RESET_STORY_ARGS = \"resetStoryArgs\", events2.SET_GLOBALS = \"setGlobals\", events2.UPDATE_GLOBALS = \"updateGlobals\", events2.GLOBALS_UPDATED = \"globalsUpdated\", events2.REGISTER_SUBSCRIPTION = \"registerSubscription\", events2.PREVIEW_KEYDOWN = \"previewKeydown\", events2.PREVIEW_BUILDER_PROGRESS = \"preview_builder_progress\", events2.SELECT_STORY = \"selectStory\", events2.STORIES_COLLAPSE_ALL = \"storiesCollapseAll\", events2.STORIES_EXPAND_ALL = \"storiesExpandAll\", events2.DOCS_RENDERED = \"docsRendered\", events2.SHARED_STATE_CHANGED = \"sharedStateChanged\", events2.SHARED_STATE_SET = \"sharedStateSet\", events2.NAVIGATE_URL = \"navigateUrl\", events2.UPDATE_QUERY_PARAMS = \"updateQueryParams\", events2))(events || {});\nvar { CHANNEL_CREATED, CONFIG_ERROR, CURRENT_STORY_WAS_SET, DOCS_PREPARED, DOCS_RENDERED, FORCE_RE_RENDER, FORCE_REMOUNT, GLOBALS_UPDATED, NAVIGATE_URL, PLAY_FUNCTION_THREW_EXCEPTION, PRELOAD_ENTRIES, PREVIEW_BUILDER_PROGRESS, PREVIEW_KEYDOWN, REGISTER_SUBSCRIPTION, RESET_STORY_ARGS, SELECT_STORY, SET_CONFIG, SET_CURRENT_STORY, SET_GLOBALS, SET_INDEX, SET_STORIES, SHARED_STATE_CHANGED, SHARED_STATE_SET, STORIES_COLLAPSE_ALL, STORIES_EXPAND_ALL, STORY_ARGS_UPDATED, STORY_CHANGED, STORY_ERRORED, STORY_INDEX_INVALIDATED, STORY_MISSING, STORY_PREPARED, STORY_RENDER_PHASE_CHANGED, STORY_RENDERED, STORY_SPECIFIED, STORY_THREW_EXCEPTION, STORY_UNCHANGED, UPDATE_GLOBALS, UPDATE_QUERY_PARAMS, UPDATE_STORY_ARGS } = events, IGNORED_EXCEPTION = new Error(\"ignoredException\");\n\n// node_modules/@storybook/preview-api/dist/chunk-BOMSN7HZ.mjs\nfunction mockChannel() {\n  let transport = { setHandler: () => {\n  }, send: () => {\n  } };\n  return new Channel({ transport });\n}\nvar AddonStore = class {\n  constructor() {\n    this.getChannel = () => {\n      if (!this.channel) {\n        let channel = mockChannel();\n        return this.setChannel(channel), channel;\n      }\n      return this.channel;\n    }, this.getServerChannel = () => {\n      if (!this.serverChannel)\n        throw new Error(\"Accessing non-existent serverChannel\");\n      return this.serverChannel;\n    }, this.ready = () => this.promise, this.hasChannel = () => !!this.channel, this.hasServerChannel = () => !!this.serverChannel, this.setChannel = (channel) => {\n      this.channel = channel, this.resolve();\n    }, this.setServerChannel = (channel) => {\n      this.serverChannel = channel;\n    }, this.promise = new Promise((res) => {\n      this.resolve = () => res(this.getChannel());\n    });\n  }\n}, KEY = \"__STORYBOOK_ADDONS_PREVIEW\";\nfunction getAddonsStore() {\n  return scope[KEY] || (scope[KEY] = new AddonStore()), scope[KEY];\n}\nvar addons = getAddonsStore();\n\n// node_modules/@storybook/instrumenter/dist/index.mjs\nvar CallStates = ((CallStates2) => (CallStates2.DONE = \"done\", CallStates2.ERROR = \"error\", CallStates2.ACTIVE = \"active\", CallStates2.WAITING = \"waiting\", CallStates2))(CallStates || {}), EVENTS = { CALL: \"storybook/instrumenter/call\", SYNC: \"storybook/instrumenter/sync\", START: \"storybook/instrumenter/start\", BACK: \"storybook/instrumenter/back\", GOTO: \"storybook/instrumenter/goto\", NEXT: \"storybook/instrumenter/next\", END: \"storybook/instrumenter/end\" }, controlsDisabled = { start: !1, back: !1, goto: !1, next: !1, end: !1 }, alreadyCompletedException = new Error(\"This function ran after the play function completed. Did you forget to `await` it?\"), isObject = (o) => Object.prototype.toString.call(o) === \"[object Object]\", isModule = (o) => Object.prototype.toString.call(o) === \"[object Module]\", isInstrumentable = (o) => {\n  if (!isObject(o) && !isModule(o))\n    return !1;\n  if (o.constructor === void 0)\n    return !0;\n  let proto = o.constructor.prototype;\n  return !(!isObject(proto) || Object.prototype.hasOwnProperty.call(proto, \"isPrototypeOf\") === !1);\n}, construct = (obj) => {\n  try {\n    return new obj.constructor();\n  } catch {\n    return {};\n  }\n}, getInitialState = () => ({ renderPhase: void 0, isDebugging: !1, isPlaying: !1, isLocked: !1, cursor: 0, calls: [], shadowCalls: [], callRefsByResult: /* @__PURE__ */ new Map(), chainedCallIds: /* @__PURE__ */ new Set(), ancestors: [], playUntil: void 0, resolvers: {}, syncTimeout: void 0 }), getRetainedState = (state, isDebugging = !1) => {\n  let calls = (isDebugging ? state.shadowCalls : state.calls).filter((call) => call.retain);\n  if (!calls.length)\n    return;\n  let callRefsByResult = new Map(Array.from(state.callRefsByResult.entries()).filter(([, ref]) => ref.retain));\n  return { cursor: calls.length, calls, callRefsByResult };\n}, Instrumenter = class {\n  constructor() {\n    this.initialized = !1, this.channel = addons.getChannel(), this.state = scope.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ || {};\n    let resetState = ({ storyId, isPlaying = !0, isDebugging = !1 }) => {\n      let state = this.getState(storyId);\n      this.setState(storyId, { ...getInitialState(), ...getRetainedState(state, isDebugging), shadowCalls: isDebugging ? state.shadowCalls : [], chainedCallIds: isDebugging ? state.chainedCallIds : /* @__PURE__ */ new Set(), playUntil: isDebugging ? state.playUntil : void 0, isPlaying, isDebugging }), this.sync(storyId);\n    };\n    this.channel.on(FORCE_REMOUNT, resetState), this.channel.on(STORY_RENDER_PHASE_CHANGED, ({ storyId, newPhase }) => {\n      let { isDebugging } = this.getState(storyId);\n      this.setState(storyId, { renderPhase: newPhase }), newPhase === \"preparing\" && isDebugging && resetState({ storyId }), newPhase === \"playing\" && resetState({ storyId, isDebugging }), newPhase === \"played\" && this.setState(storyId, { isLocked: !1, isPlaying: !1, isDebugging: !1 }), newPhase === \"errored\" && this.setState(storyId, { isLocked: !1, isPlaying: !1 });\n    }), this.channel.on(SET_CURRENT_STORY, () => {\n      this.initialized ? this.cleanup() : this.initialized = !0;\n    });\n    let start = ({ storyId, playUntil }) => {\n      this.getState(storyId).isDebugging || this.setState(storyId, ({ calls }) => ({ calls: [], shadowCalls: calls.map((call) => ({ ...call, status: \"waiting\" })), isDebugging: !0 }));\n      let log = this.getLog(storyId);\n      this.setState(storyId, ({ shadowCalls }) => {\n        if (playUntil || !log.length)\n          return { playUntil };\n        let firstRowIndex = shadowCalls.findIndex((call) => call.id === log[0].callId);\n        return { playUntil: shadowCalls.slice(0, firstRowIndex).filter((call) => call.interceptable && !call.ancestors.length).slice(-1)[0]?.id };\n      }), this.channel.emit(FORCE_REMOUNT, { storyId, isDebugging: !0 });\n    }, back = ({ storyId }) => {\n      let log = this.getLog(storyId).filter((call) => !call.ancestors.length), last = log.reduceRight((res, item, index) => res >= 0 || item.status === \"waiting\" ? res : index, -1);\n      start({ storyId, playUntil: log[last - 1]?.callId });\n    }, goto = ({ storyId, callId }) => {\n      let { calls, shadowCalls, resolvers } = this.getState(storyId), call = calls.find(({ id }) => id === callId), shadowCall = shadowCalls.find(({ id }) => id === callId);\n      if (!call && shadowCall && Object.values(resolvers).length > 0) {\n        let nextId = this.getLog(storyId).find((c) => c.status === \"waiting\")?.callId;\n        shadowCall.id !== nextId && this.setState(storyId, { playUntil: shadowCall.id }), Object.values(resolvers).forEach((resolve) => resolve());\n      } else\n        start({ storyId, playUntil: callId });\n    }, next = ({ storyId }) => {\n      let { resolvers } = this.getState(storyId);\n      if (Object.values(resolvers).length > 0)\n        Object.values(resolvers).forEach((resolve) => resolve());\n      else {\n        let nextId = this.getLog(storyId).find((c) => c.status === \"waiting\")?.callId;\n        nextId ? start({ storyId, playUntil: nextId }) : end({ storyId });\n      }\n    }, end = ({ storyId }) => {\n      this.setState(storyId, { playUntil: void 0, isDebugging: !1 }), Object.values(this.getState(storyId).resolvers).forEach((resolve) => resolve());\n    };\n    this.channel.on(EVENTS.START, start), this.channel.on(EVENTS.BACK, back), this.channel.on(EVENTS.GOTO, goto), this.channel.on(EVENTS.NEXT, next), this.channel.on(EVENTS.END, end);\n  }\n  getState(storyId) {\n    return this.state[storyId] || getInitialState();\n  }\n  setState(storyId, update) {\n    let state = this.getState(storyId), patch = typeof update == \"function\" ? update(state) : update;\n    this.state = { ...this.state, [storyId]: { ...state, ...patch } }, scope.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ = this.state;\n  }\n  cleanup() {\n    this.state = Object.entries(this.state).reduce((acc, [storyId, state]) => {\n      let retainedState = getRetainedState(state);\n      return retainedState && (acc[storyId] = Object.assign(getInitialState(), retainedState)), acc;\n    }, {});\n    let payload = { controlStates: controlsDisabled, logItems: [] };\n    this.channel.emit(EVENTS.SYNC, payload), scope.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ = this.state;\n  }\n  getLog(storyId) {\n    let { calls, shadowCalls } = this.getState(storyId), merged = [...shadowCalls];\n    calls.forEach((call, index) => {\n      merged[index] = call;\n    });\n    let seen = /* @__PURE__ */ new Set();\n    return merged.reduceRight((acc, call) => (call.args.forEach((arg) => {\n      arg?.__callId__ && seen.add(arg.__callId__);\n    }), call.path.forEach((node) => {\n      node.__callId__ && seen.add(node.__callId__);\n    }), (call.interceptable || call.exception) && !seen.has(call.id) && (acc.unshift({ callId: call.id, status: call.status, ancestors: call.ancestors }), seen.add(call.id)), acc), []);\n  }\n  instrument(obj, options) {\n    if (!isInstrumentable(obj))\n      return obj;\n    let { mutate = !1, path = [] } = options;\n    return Object.keys(obj).reduce((acc, key) => {\n      let value = obj[key];\n      return typeof value != \"function\" ? (acc[key] = this.instrument(value, { ...options, path: path.concat(key) }), acc) : typeof value.__originalFn__ == \"function\" ? (acc[key] = value, acc) : (acc[key] = (...args) => this.track(key, value, args, options), acc[key].__originalFn__ = value, Object.defineProperty(acc[key], \"name\", { value: key, writable: !1 }), Object.keys(value).length > 0 && Object.assign(acc[key], this.instrument({ ...value }, { ...options, path: path.concat(key) })), acc);\n    }, mutate ? obj : construct(obj));\n  }\n  track(method, fn, args, options) {\n    let storyId = args?.[0]?.__storyId__ || scope.__STORYBOOK_PREVIEW__?.selectionStore?.selection?.storyId, { cursor, ancestors } = this.getState(storyId);\n    this.setState(storyId, { cursor: cursor + 1 });\n    let id = `${ancestors.slice(-1)[0] || storyId} [${cursor}] ${method}`, { path = [], intercept = !1, retain = !1 } = options, interceptable = typeof intercept == \"function\" ? intercept(method, path) : intercept, call = { id, cursor, storyId, ancestors, path, method, args, interceptable, retain }, result = (interceptable && !ancestors.length ? this.intercept : this.invoke).call(this, fn, call, options);\n    return this.instrument(result, { ...options, mutate: !0, path: [{ __callId__: call.id }] });\n  }\n  intercept(fn, call, options) {\n    let { chainedCallIds, isDebugging, playUntil } = this.getState(call.storyId), isChainedUpon = chainedCallIds.has(call.id);\n    return !isDebugging || isChainedUpon || playUntil ? (playUntil === call.id && this.setState(call.storyId, { playUntil: void 0 }), this.invoke(fn, call, options)) : new Promise((resolve) => {\n      this.setState(call.storyId, ({ resolvers }) => ({ isLocked: !1, resolvers: { ...resolvers, [call.id]: resolve } }));\n    }).then(() => (this.setState(call.storyId, (state) => {\n      let { [call.id]: _, ...resolvers } = state.resolvers;\n      return { isLocked: !0, resolvers };\n    }), this.invoke(fn, call, options)));\n  }\n  invoke(fn, call, options) {\n    let { callRefsByResult, renderPhase } = this.getState(call.storyId), serializeValues = (value) => {\n      if (callRefsByResult.has(value))\n        return callRefsByResult.get(value);\n      if (value instanceof Array)\n        return value.map(serializeValues);\n      if (value instanceof Date)\n        return { __date__: { value: value.toISOString() } };\n      if (value instanceof Error) {\n        let { name, message, stack } = value;\n        return { __error__: { name, message, stack } };\n      }\n      if (value instanceof RegExp) {\n        let { flags, source } = value;\n        return { __regexp__: { flags, source } };\n      }\n      if (value instanceof scope.window.HTMLElement) {\n        let { prefix, localName, id, classList, innerText } = value, classNames = Array.from(classList);\n        return { __element__: { prefix, localName, id, classNames, innerText } };\n      }\n      return typeof value == \"function\" ? { __function__: { name: value.name } } : typeof value == \"symbol\" ? { __symbol__: { description: value.description } } : typeof value == \"object\" && value?.constructor?.name && value?.constructor?.name !== \"Object\" ? { __class__: { name: value.constructor.name } } : Object.prototype.toString.call(value) === \"[object Object]\" ? Object.fromEntries(Object.entries(value).map(([key, val]) => [key, serializeValues(val)])) : value;\n    }, info = { ...call, args: call.args.map(serializeValues) };\n    call.path.forEach((ref) => {\n      ref?.__callId__ && this.setState(call.storyId, ({ chainedCallIds }) => ({ chainedCallIds: new Set(Array.from(chainedCallIds).concat(ref.__callId__)) }));\n    });\n    let handleException = (e) => {\n      if (e instanceof Error) {\n        let { name, message, stack, callId = call.id } = e, exception = { name, message, stack, callId };\n        if (this.update({ ...info, status: \"error\", exception }), this.setState(call.storyId, (state) => ({ callRefsByResult: new Map([...Array.from(state.callRefsByResult.entries()), [e, { __callId__: call.id, retain: call.retain }]]) })), call.ancestors.length)\n          throw Object.prototype.hasOwnProperty.call(e, \"callId\") || Object.defineProperty(e, \"callId\", { value: call.id }), e;\n        if (e !== alreadyCompletedException)\n          throw logger.warn(e), IGNORED_EXCEPTION;\n      }\n      throw e;\n    };\n    try {\n      if (renderPhase === \"played\" && !call.retain)\n        throw alreadyCompletedException;\n      let finalArgs = (options.getArgs ? options.getArgs(call, this.getState(call.storyId)) : call.args).map((arg) => typeof arg != \"function\" || Object.keys(arg).length ? arg : (...args) => {\n        let { cursor, ancestors } = this.getState(call.storyId);\n        this.setState(call.storyId, { cursor: 0, ancestors: [...ancestors, call.id] });\n        let restore = () => this.setState(call.storyId, { cursor, ancestors }), willRestore = !1;\n        try {\n          let res = arg(...args);\n          return res instanceof Promise ? (willRestore = !0, res.finally(restore)) : res;\n        } finally {\n          willRestore || restore();\n        }\n      }), result = fn(...finalArgs);\n      return result && [\"object\", \"function\", \"symbol\"].includes(typeof result) && this.setState(call.storyId, (state) => ({ callRefsByResult: new Map([...Array.from(state.callRefsByResult.entries()), [result, { __callId__: call.id, retain: call.retain }]]) })), this.update({ ...info, status: result instanceof Promise ? \"active\" : \"done\" }), result instanceof Promise ? result.then((value) => (this.update({ ...info, status: \"done\" }), value), handleException) : result;\n    } catch (e) {\n      return handleException(e);\n    }\n  }\n  update(call) {\n    this.channel.emit(EVENTS.CALL, call), this.setState(call.storyId, ({ calls }) => {\n      let callsById = calls.concat(call).reduce((a, c) => Object.assign(a, { [c.id]: c }), {});\n      return { calls: Object.values(callsById).sort((a, b) => a.id.localeCompare(b.id, void 0, { numeric: !0 })) };\n    }), this.sync(call.storyId);\n  }\n  sync(storyId) {\n    let synchronize = () => {\n      let { isLocked, isPlaying } = this.getState(storyId), logItems = this.getLog(storyId), pausedAt = logItems.filter(({ ancestors }) => !ancestors.length).find((item) => item.status === \"waiting\")?.callId, hasActive = logItems.some((item) => item.status === \"active\");\n      if (isLocked || hasActive || logItems.length === 0) {\n        let payload2 = { controlStates: controlsDisabled, logItems };\n        this.channel.emit(EVENTS.SYNC, payload2);\n        return;\n      }\n      let hasPrevious = logItems.some((item) => [\"done\", \"error\"].includes(item.status)), payload = { controlStates: { start: hasPrevious, back: hasPrevious, goto: !0, next: isPlaying, end: isPlaying }, logItems, pausedAt };\n      this.channel.emit(EVENTS.SYNC, payload);\n    };\n    this.setState(storyId, ({ syncTimeout }) => (clearTimeout(syncTimeout), { syncTimeout: setTimeout(synchronize, 0) }));\n  }\n};\nfunction instrument(obj, options = {}) {\n  try {\n    let forceInstrument = !1, skipInstrument = !1;\n    return scope.window.location?.search?.includes(\"instrument=true\") ? forceInstrument = !0 : scope.window.location?.search?.includes(\"instrument=false\") && (skipInstrument = !0), scope.window.parent === scope.window && !forceInstrument || skipInstrument ? obj : (scope.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ || (scope.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ = new Instrumenter()), scope.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__.instrument(obj, options));\n  } catch (e) {\n    return once.warn(e), obj;\n  }\n}\n\n// src/index.ts\n\n\n\nvar _userEvent = userEvent[\"default\"] || userEvent, testingLibrary = instrument(\n  { ...dom_esm },\n  {\n    intercept: (method, path) => path[0] === \"fireEvent\" || method.startsWith(\"findBy\") || method.startsWith(\"waitFor\")\n  }\n);\ntestingLibrary.screen = Object.entries(testingLibrary.screen).reduce(\n  (acc, [key, val]) => Object.defineProperty(acc, key, {\n    get() {\n      return once.warn((0,esm/* default */.C)`\n          You are using Testing Library's \\`screen\\` object. Use \\`within(canvasElement)\\` instead.\n          More info: https://storybook.js.org/docs/react/essentials/interactions\n        `), val;\n    }\n  }),\n  { ...testingLibrary.screen }\n);\nvar {\n  buildQueries,\n  configure,\n  createEvent: dist_createEvent,\n  findAllByAltText,\n  findAllByDisplayValue,\n  findAllByLabelText,\n  findAllByPlaceholderText,\n  findAllByRole,\n  findAllByTestId,\n  findAllByText,\n  findAllByTitle,\n  findByAltText,\n  findByDisplayValue,\n  findByLabelText,\n  findByPlaceholderText,\n  findByRole,\n  findByTestId,\n  findByText,\n  findByTitle,\n  fireEvent,\n  getAllByAltText,\n  getAllByDisplayValue,\n  getAllByLabelText,\n  getAllByPlaceholderText,\n  getAllByRole,\n  getAllByTestId,\n  getAllByText,\n  getAllByTitle,\n  getByAltText,\n  getByDisplayValue,\n  getByLabelText,\n  getByPlaceholderText,\n  getByRole,\n  getByTestId,\n  getByText,\n  getByTitle,\n  getConfig,\n  getDefaultNormalizer,\n  getElementError,\n  getNodeText,\n  getQueriesForElement,\n  getRoles,\n  getSuggestedQuery,\n  isInaccessible,\n  logDOM,\n  logRoles,\n  prettyDOM,\n  queries,\n  queryAllByAltText,\n  queryAllByAttribute,\n  queryAllByDisplayValue,\n  queryAllByLabelText,\n  queryAllByPlaceholderText,\n  queryAllByRole,\n  queryAllByTestId,\n  queryAllByText,\n  queryAllByTitle,\n  queryByAltText,\n  queryByAttribute,\n  queryByDisplayValue,\n  queryByLabelText,\n  queryByPlaceholderText,\n  queryByRole,\n  queryByTestId,\n  queryByText,\n  queryByTitle,\n  queryHelpers,\n  screen,\n  waitFor,\n  waitForElementToBeRemoved,\n  within,\n  prettyFormat\n} = testingLibrary, dist_userEvent = instrument(\n  { userEvent: _userEvent },\n  { intercept: !0 }\n).userEvent;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN0b3J5Ym9vay90ZXN0aW5nLWxpYnJhcnkvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeUI7OztBQ2pCZ0M7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrREFBa0Q7QUFDbkQ7QUFDQSxXQUFXLGFBQWEsdUJBQXVCLGFBQWE7QUFDNUQ7O0FBRTRCOzs7OztBQ2pCNkM7O0FBRXpFO0FBQ0EsV0FBVyxxQ0FBaUI7QUFDNUI7O0FBRXFCOzs7QUNOckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRXdCOzs7QUNieEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMEI7OztBQ3JCcUI7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHLE1BQU07QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTBCLEVBQUU7QUFDNUI7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwwQkFBMEIsRUFBRTtBQUM1QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBLFNBQVM7QUFDVDtBQUNBLHdCQUF3QixFQUFFO0FBQzFCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNM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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGtCQUFrQixjQUFTO0FBQzdCLElBQUksdUJBQXVCO0FBQzNCLElBQUk7QUFDSjtBQTJFRSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlYWZ5Z3JlZW4tdWkvLi9ub2RlX21vZHVsZXMvQHN0b3J5Ym9vay90ZXN0aW5nLWxpYnJhcnkvbm9kZV9tb2R1bGVzL0B0ZXN0aW5nLWxpYnJhcnkvdXNlci1ldmVudC9kaXN0L2VzbS91dGlscy9taXNjL2lzRWxlbWVudFR5cGUuanM/ZWM5YiIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vdXRpbHMvY2xpY2svaXNDbGlja2FibGVJbnB1dC5qcz9kMWYyIiwid2VicGFjazovL2xlYWZ5Z3JlZW4tdWkvLi9ub2RlX21vZHVsZXMvQHN0b3J5Ym9vay90ZXN0aW5nLWxpYnJhcnkvbm9kZV9tb2R1bGVzL0B0ZXN0aW5nLWxpYnJhcnkvdXNlci1ldmVudC9kaXN0L2VzbS91dGlscy9taXNjL2dldFdpbmRvdy5qcz85NDgxIiwid2VicGFjazovL2xlYWZ5Z3JlZW4tdWkvLi9ub2RlX21vZHVsZXMvQHN0b3J5Ym9vay90ZXN0aW5nLWxpYnJhcnkvbm9kZV9tb2R1bGVzL0B0ZXN0aW5nLWxpYnJhcnkvdXNlci1ldmVudC9kaXN0L2VzbS91dGlscy9kYXRhVHJhbnNmZXIvQmxvYi5qcz81ZGMxIiwid2VicGFjazovL2xlYWZ5Z3JlZW4tdWkvLi9ub2RlX21vZHVsZXMvQHN0b3J5Ym9vay90ZXN0aW5nLWxpYnJhcnkvbm9kZV9tb2R1bGVzL0B0ZXN0aW5nLWxpYnJhcnkvdXNlci1ldmVudC9kaXN0L2VzbS91dGlscy9kYXRhVHJhbnNmZXIvRmlsZUxpc3QuanM/MTUyMyIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vdXRpbHMvZGF0YVRyYW5zZmVyL0RhdGFUcmFuc2Zlci5qcz9kNTU1Iiwid2VicGFjazovL2xlYWZ5Z3JlZW4tdWkvLi9ub2RlX21vZHVsZXMvQHN0b3J5Ym9vay90ZXN0aW5nLWxpYnJhcnkvbm9kZV9tb2R1bGVzL0B0ZXN0aW5nLWxpYnJhcnkvdXNlci1ldmVudC9kaXN0L2VzbS91dGlscy9kYXRhVHJhbnNmZXIvQ2xpcGJvYXJkLmpzP2JiNjEiLCJ3ZWJwYWNrOi8vbGVhZnlncmVlbi11aS8uL25vZGVfbW9kdWxlcy9Ac3Rvcnlib29rL3Rlc3RpbmctbGlicmFyeS9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50L2Rpc3QvZXNtL3V0aWxzL2VkaXQvaXNDb250ZW50RWRpdGFibGUuanM/MjY4ZiIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vdXRpbHMvZWRpdC9pc0VkaXRhYmxlLmpzPzg5Y2EiLCJ3ZWJwYWNrOi8vbGVhZnlncmVlbi11aS8uL25vZGVfbW9kdWxlcy9Ac3Rvcnlib29rL3Rlc3RpbmctbGlicmFyeS9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50L2Rpc3QvZXNtL3V0aWxzL2VkaXQvbWF4TGVuZ3RoLmpzP2YzNmQiLCJ3ZWJwYWNrOi8vbGVhZnlncmVlbi11aS8uL25vZGVfbW9kdWxlcy9Ac3Rvcnlib29rL3Rlc3RpbmctbGlicmFyeS9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50L2Rpc3QvZXNtL3V0aWxzL2ZvY3VzL3NlbGVjdG9yLmpzPzQ5NDEiLCJ3ZWJwYWNrOi8vbGVhZnlncmVlbi11aS8uL25vZGVfbW9kdWxlcy9Ac3Rvcnlib29rL3Rlc3RpbmctbGlicmFyeS9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50L2Rpc3QvZXNtL3V0aWxzL2ZvY3VzL2lzRm9jdXNhYmxlLmpzP2EwMTUiLCJ3ZWJwYWNrOi8vbGVhZnlncmVlbi11aS8uL25vZGVfbW9kdWxlcy9Ac3Rvcnlib29rL3Rlc3RpbmctbGlicmFyeS9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50L2Rpc3QvZXNtL3V0aWxzL2tleURlZi9yZWFkTmV4dERlc2NyaXB0b3IuanM/MGJmNCIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vdXRpbHMvbWlzYy9jbG9uZUV2ZW50LmpzP2ZhYmQiLCJ3ZWJwYWNrOi8vbGVhZnlncmVlbi11aS8uL25vZGVfbW9kdWxlcy9Ac3Rvcnlib29rL3Rlc3RpbmctbGlicmFyeS9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50L2Rpc3QvZXNtL3V0aWxzL21pc2MvbGV2ZWwuanM/MjJlZCIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vb3B0aW9ucy5qcz8wMzBjIiwid2VicGFjazovL2xlYWZ5Z3JlZW4tdWkvLi9ub2RlX21vZHVsZXMvQHN0b3J5Ym9vay90ZXN0aW5nLWxpYnJhcnkvbm9kZV9tb2R1bGVzL0B0ZXN0aW5nLWxpYnJhcnkvdXNlci1ldmVudC9kaXN0L2VzbS91dGlscy9taXNjL2lzRGlzYWJsZWQuanM/N2IzMSIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vdXRpbHMvZm9jdXMvZ2V0QWN0aXZlRWxlbWVudC5qcz8wZGQ2Iiwid2VicGFjazovL2xlYWZ5Z3JlZW4tdWkvLi9ub2RlX21vZHVsZXMvQHN0b3J5Ym9vay90ZXN0aW5nLWxpYnJhcnkvbm9kZV9tb2R1bGVzL0B0ZXN0aW5nLWxpYnJhcnkvdXNlci1ldmVudC9kaXN0L2VzbS91dGlscy9taXNjL2ZpbmRDbG9zZXN0LmpzPzVkYWEiLCJ3ZWJwYWNrOi8vbGVhZnlncmVlbi11aS8uL25vZGVfbW9kdWxlcy9Ac3Rvcnlib29rL3Rlc3RpbmctbGlicmFyeS9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50L2Rpc3QvZXNtL3V0aWxzL2ZvY3VzL3NlbGVjdGlvbi5qcz9kMTY5Iiwid2VicGFjazovL2xlYWZ5Z3JlZW4tdWkvLi9ub2RlX21vZHVsZXMvQHN0b3J5Ym9vay90ZXN0aW5nLWxpYnJhcnkvbm9kZV9tb2R1bGVzL0B0ZXN0aW5nLWxpYnJhcnkvdXNlci1ldmVudC9kaXN0L2VzbS9ldmVudC9zZWxlY3Rpb24vdXBkYXRlU2VsZWN0aW9uT25Gb2N1cy5qcz9hMzI5Iiwid2VicGFjazovL2xlYWZ5Z3JlZW4tdWkvLi9ub2RlX21vZHVsZXMvQHN0b3J5Ym9vay90ZXN0aW5nLWxpYnJhcnkvbm9kZV9tb2R1bGVzL0B0ZXN0aW5nLWxpYnJhcnkvdXNlci1ldmVudC9kaXN0L2VzbS9ldmVudC93cmFwRXZlbnQuanM/NDhjOSIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vZXZlbnQvZm9jdXMuanM/ZGY5NSIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vZXZlbnQvYmVoYXZpb3IvcmVnaXN0cnkuanM/MjVhZSIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vZXZlbnQvYmVoYXZpb3IvY2xpY2suanM/MzBjZSIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vZG9jdW1lbnQvVUkuanM/NGVkZCIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vdXRpbHMvZWRpdC90aW1lVmFsdWUuanM/YzU1OSIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vdXRpbHMvZm9jdXMvY3Vyc29yLmpzPzczMjAiLCJ3ZWJwYWNrOi8vbGVhZnlncmVlbi11aS8uL25vZGVfbW9kdWxlcy9Ac3Rvcnlib29rL3Rlc3RpbmctbGlicmFyeS9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50L2Rpc3QvZXNtL2RvY3VtZW50L3RyYWNrVmFsdWUuanM/NjkyNiIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vZXZlbnQvc2VsZWN0aW9uL2dldFRhcmdldFR5cGVBbmRTZWxlY3Rpb24uanM/MWRlZiIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vZXZlbnQvc2VsZWN0aW9uL2dldElucHV0UmFuZ2UuanM/ODU3ZCIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vZXZlbnQvc2VsZWN0aW9uL3NldFNlbGVjdGlvbi5qcz84ZjdiIiwid2VicGFjazovL2xlYWZ5Z3JlZW4tdWkvLi9ub2RlX21vZHVsZXMvQHN0b3J5Ym9vay90ZXN0aW5nLWxpYnJhcnkvbm9kZV9tb2R1bGVzL0B0ZXN0aW5nLWxpYnJhcnkvdXNlci1ldmVudC9kaXN0L2VzbS9ldmVudC9pbnB1dC5qcz84MzRmIiwid2VicGFjazovL2xlYWZ5Z3JlZW4tdWkvLi9ub2RlX21vZHVsZXMvQHN0b3J5Ym9vay90ZXN0aW5nLWxpYnJhcnkvbm9kZV9tb2R1bGVzL0B0ZXN0aW5nLWxpYnJhcnkvdXNlci1ldmVudC9kaXN0L2VzbS9ldmVudC9iZWhhdmlvci9jdXQuanM/YmU4MiIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vZG9jdW1lbnQvZ2V0VmFsdWVPclRleHRDb250ZW50LmpzP2MyZGUiLCJ3ZWJwYWNrOi8vbGVhZnlncmVlbi11aS8uL25vZGVfbW9kdWxlcy9Ac3Rvcnlib29rL3Rlc3RpbmctbGlicmFyeS9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50L2Rpc3QvZXNtL3V0aWxzL21pc2MvaXNWaXNpYmxlLmpzP2M1ZjgiLCJ3ZWJwYWNrOi8vbGVhZnlncmVlbi11aS8uL25vZGVfbW9kdWxlcy9Ac3Rvcnlib29rL3Rlc3RpbmctbGlicmFyeS9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50L2Rpc3QvZXNtL3V0aWxzL2ZvY3VzL2dldFRhYkRlc3RpbmF0aW9uLmpzP2ZhZDYiLCJ3ZWJwYWNrOi8vbGVhZnlncmVlbi11aS8uL25vZGVfbW9kdWxlcy9Ac3Rvcnlib29rL3Rlc3RpbmctbGlicmFyeS9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50L2Rpc3QvZXNtL2V2ZW50L3NlbGVjdGlvbi9tb3ZlU2VsZWN0aW9uLmpzP2UyMjAiLCJ3ZWJwYWNrOi8vbGVhZnlncmVlbi11aS8uL25vZGVfbW9kdWxlcy9Ac3Rvcnlib29rL3Rlc3RpbmctbGlicmFyeS9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50L2Rpc3QvZXNtL2V2ZW50L3NlbGVjdGlvbi9zZWxlY3RBbGwuanM/ZWEzOSIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vZXZlbnQvc2VsZWN0aW9uL3NldFNlbGVjdGlvblJhbmdlLmpzPzAyOGYiLCJ3ZWJwYWNrOi8vbGVhZnlncmVlbi11aS8uL25vZGVfbW9kdWxlcy9Ac3Rvcnlib29rL3Rlc3RpbmctbGlicmFyeS9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50L2Rpc3QvZXNtL2V2ZW50L3JhZGlvLmpzP2NkNWYiLCJ3ZWJwYWNrOi8vbGVhZnlncmVlbi11aS8uL25vZGVfbW9kdWxlcy9Ac3Rvcnlib29rL3Rlc3RpbmctbGlicmFyeS9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50L2Rpc3QvZXNtL2V2ZW50L2JlaGF2aW9yL2tleWRvd24uanM/ZDI4MiIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vZXZlbnQvYmVoYXZpb3Iva2V5cHJlc3MuanM/OTk5NyIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vZXZlbnQvYmVoYXZpb3Iva2V5dXAuanM/NDAwZSIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vZXZlbnQvYmVoYXZpb3IvcGFzdGUuanM/YzFhYiIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vZXZlbnQvZXZlbnRNYXAuanM/NDM2OCIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vZXZlbnQvY3JlYXRlRXZlbnQuanM/MjNiMCIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vZXZlbnQvZGlzcGF0Y2hFdmVudC5qcz9mNTRlIiwid2VicGFjazovL2xlYWZ5Z3JlZW4tdWkvLi9ub2RlX21vZHVsZXMvQHN0b3J5Ym9vay90ZXN0aW5nLWxpYnJhcnkvbm9kZV9tb2R1bGVzL0B0ZXN0aW5nLWxpYnJhcnkvdXNlci1ldmVudC9kaXN0L2VzbS9kb2N1bWVudC9pbnRlcmNlcHRvci5qcz85YmUzIiwid2VicGFjazovL2xlYWZ5Z3JlZW4tdWkvLi9ub2RlX21vZHVsZXMvQHN0b3J5Ym9vay90ZXN0aW5nLWxpYnJhcnkvbm9kZV9tb2R1bGVzL0B0ZXN0aW5nLWxpYnJhcnkvdXNlci1ldmVudC9kaXN0L2VzbS9kb2N1bWVudC9wcmVwYXJlRG9jdW1lbnQuanM/OGVkMyIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vdXRpbHMvbWlzYy9nZXREb2N1bWVudEZyb21Ob2RlLmpzPzM1YjciLCJ3ZWJwYWNrOi8vbGVhZnlncmVlbi11aS8uL25vZGVfbW9kdWxlcy9Ac3Rvcnlib29rL3Rlc3RpbmctbGlicmFyeS9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50L2Rpc3QvZXNtL3V0aWxzL21pc2Mvd2FpdC5qcz80OTJkIiwid2VicGFjazovL2xlYWZ5Z3JlZW4tdWkvLi9ub2RlX21vZHVsZXMvQHN0b3J5Ym9vay90ZXN0aW5nLWxpYnJhcnkvbm9kZV9tb2R1bGVzL0B0ZXN0aW5nLWxpYnJhcnkvdXNlci1ldmVudC9kaXN0L2VzbS9zeXN0ZW0va2V5Ym9hcmQuanM/OWNhZCIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20va2V5Ym9hcmQva2V5TWFwLmpzPzdjZmIiLCJ3ZWJwYWNrOi8vbGVhZnlncmVlbi11aS8uL25vZGVfbW9kdWxlcy9Ac3Rvcnlib29rL3Rlc3RpbmctbGlicmFyeS9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50L2Rpc3QvZXNtL3BvaW50ZXIva2V5TWFwLmpzPzVhMjAiLCJ3ZWJwYWNrOi8vbGVhZnlncmVlbi11aS8uL25vZGVfbW9kdWxlcy9Ac3Rvcnlib29rL3Rlc3RpbmctbGlicmFyeS9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50L2Rpc3QvZXNtL3N5c3RlbS9wb2ludGVyL2J1dHRvbnMuanM/OTExZCIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vc3lzdGVtL3BvaW50ZXIvZGV2aWNlLmpzP2MxZTQiLCJ3ZWJwYWNrOi8vbGVhZnlncmVlbi11aS8uL25vZGVfbW9kdWxlcy9Ac3Rvcnlib29rL3Rlc3RpbmctbGlicmFyeS9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50L2Rpc3QvZXNtL3V0aWxzL21pc2MvZ2V0VHJlZURpZmYuanM/MTI5OCIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vZXZlbnQvc2VsZWN0aW9uL3Jlc29sdmVDYXJldFBvc2l0aW9uLmpzPzM3NjgiLCJ3ZWJwYWNrOi8vbGVhZnlncmVlbi11aS8uL25vZGVfbW9kdWxlcy9Ac3Rvcnlib29rL3Rlc3RpbmctbGlicmFyeS9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50L2Rpc3QvZXNtL2V2ZW50L3NlbGVjdGlvbi9zZXRTZWxlY3Rpb25QZXJNb3VzZS5qcz81NmQyIiwid2VicGFjazovL2xlYWZ5Z3JlZW4tdWkvLi9ub2RlX21vZHVsZXMvQHN0b3J5Ym9vay90ZXN0aW5nLWxpYnJhcnkvbm9kZV9tb2R1bGVzL0B0ZXN0aW5nLWxpYnJhcnkvdXNlci1ldmVudC9kaXN0L2VzbS9ldmVudC9zZWxlY3Rpb24vbW9kaWZ5U2VsZWN0aW9uUGVyTW91c2UuanM/ODk1OSIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vc3lzdGVtL3BvaW50ZXIvc2hhcmVkLmpzPzY0YTUiLCJ3ZWJwYWNrOi8vbGVhZnlncmVlbi11aS8uL25vZGVfbW9kdWxlcy9Ac3Rvcnlib29rL3Rlc3RpbmctbGlicmFyeS9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50L2Rpc3QvZXNtL3N5c3RlbS9wb2ludGVyL21vdXNlLmpzP2MzNjAiLCJ3ZWJwYWNrOi8vbGVhZnlncmVlbi11aS8uL25vZGVfbW9kdWxlcy9Ac3Rvcnlib29rL3Rlc3RpbmctbGlicmFyeS9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50L2Rpc3QvZXNtL3V0aWxzL3BvaW50ZXIvY3NzUG9pbnRlckV2ZW50cy5qcz9lNDM5Iiwid2VicGFjazovL2xlYWZ5Z3JlZW4tdWkvLi9ub2RlX21vZHVsZXMvQHN0b3J5Ym9vay90ZXN0aW5nLWxpYnJhcnkvbm9kZV9tb2R1bGVzL0B0ZXN0aW5nLWxpYnJhcnkvdXNlci1ldmVudC9kaXN0L2VzbS9zeXN0ZW0vcG9pbnRlci9wb2ludGVyLmpzPzk3YjciLCJ3ZWJwYWNrOi8vbGVhZnlncmVlbi11aS8uL25vZGVfbW9kdWxlcy9Ac3Rvcnlib29rL3Rlc3RpbmctbGlicmFyeS9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50L2Rpc3QvZXNtL3N5c3RlbS9wb2ludGVyL2luZGV4LmpzPzgxY2YiLCJ3ZWJwYWNrOi8vbGVhZnlncmVlbi11aS8uL25vZGVfbW9kdWxlcy9Ac3Rvcnlib29rL3Rlc3RpbmctbGlicmFyeS9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50L2Rpc3QvZXNtL3N5c3RlbS9pbmRleC5qcz9jOTMxIiwid2VicGFjazovL2xlYWZ5Z3JlZW4tdWkvLi9ub2RlX21vZHVsZXMvQHN0b3J5Ym9vay90ZXN0aW5nLWxpYnJhcnkvbm9kZV9tb2R1bGVzL0B0ZXN0aW5nLWxpYnJhcnkvdXNlci1ldmVudC9kaXN0L2VzbS9jb252ZW5pZW5jZS9jbGljay5qcz84MDUzIiwid2VicGFjazovL2xlYWZ5Z3JlZW4tdWkvLi9ub2RlX21vZHVsZXMvQHN0b3J5Ym9vay90ZXN0aW5nLWxpYnJhcnkvbm9kZV9tb2R1bGVzL0B0ZXN0aW5nLWxpYnJhcnkvdXNlci1ldmVudC9kaXN0L2VzbS9jb252ZW5pZW5jZS9ob3Zlci5qcz9hMDAzIiwid2VicGFjazovL2xlYWZ5Z3JlZW4tdWkvLi9ub2RlX21vZHVsZXMvQHN0b3J5Ym9vay90ZXN0aW5nLWxpYnJhcnkvbm9kZV9tb2R1bGVzL0B0ZXN0aW5nLWxpYnJhcnkvdXNlci1ldmVudC9kaXN0L2VzbS9jb252ZW5pZW5jZS90YWIuanM/ZmM3MiIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20va2V5Ym9hcmQvcGFyc2VLZXlEZWYuanM/M2Y5OCIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20va2V5Ym9hcmQvaW5kZXguanM/ZWQ5NCIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vZG9jdW1lbnQvY29weVNlbGVjdGlvbi5qcz9kMjk3Iiwid2VicGFjazovL2xlYWZ5Z3JlZW4tdWkvLi9ub2RlX21vZHVsZXMvQHN0b3J5Ym9vay90ZXN0aW5nLWxpYnJhcnkvbm9kZV9tb2R1bGVzL0B0ZXN0aW5nLWxpYnJhcnkvdXNlci1ldmVudC9kaXN0L2VzbS9jbGlwYm9hcmQvY29weS5qcz85MDU2Iiwid2VicGFjazovL2xlYWZ5Z3JlZW4tdWkvLi9ub2RlX21vZHVsZXMvQHN0b3J5Ym9vay90ZXN0aW5nLWxpYnJhcnkvbm9kZV9tb2R1bGVzL0B0ZXN0aW5nLWxpYnJhcnkvdXNlci1ldmVudC9kaXN0L2VzbS9jbGlwYm9hcmQvY3V0LmpzP2Q4NDEiLCJ3ZWJwYWNrOi8vbGVhZnlncmVlbi11aS8uL25vZGVfbW9kdWxlcy9Ac3Rvcnlib29rL3Rlc3RpbmctbGlicmFyeS9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50L2Rpc3QvZXNtL2NsaXBib2FyZC9wYXN0ZS5qcz8xYWRlIiwid2VicGFjazovL2xlYWZ5Z3JlZW4tdWkvLi9ub2RlX21vZHVsZXMvQHN0b3J5Ym9vay90ZXN0aW5nLWxpYnJhcnkvbm9kZV9tb2R1bGVzL0B0ZXN0aW5nLWxpYnJhcnkvdXNlci1ldmVudC9kaXN0L2VzbS9wb2ludGVyL3BhcnNlS2V5RGVmLmpzP2I4OTAiLCJ3ZWJwYWNrOi8vbGVhZnlncmVlbi11aS8uL25vZGVfbW9kdWxlcy9Ac3Rvcnlib29rL3Rlc3RpbmctbGlicmFyeS9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50L2Rpc3QvZXNtL3BvaW50ZXIvaW5kZXguanM/NDhhZiIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vdXRpbGl0eS9jbGVhci5qcz85MjZjIiwid2VicGFjazovL2xlYWZ5Z3JlZW4tdWkvLi9ub2RlX21vZHVsZXMvQHN0b3J5Ym9vay90ZXN0aW5nLWxpYnJhcnkvbm9kZV9tb2R1bGVzL0B0ZXN0aW5nLWxpYnJhcnkvdXNlci1ldmVudC9kaXN0L2VzbS91dGlsaXR5L3NlbGVjdE9wdGlvbnMuanM/YTVmZiIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vdXRpbGl0eS90eXBlLmpzPzM5MjAiLCJ3ZWJwYWNrOi8vbGVhZnlncmVlbi11aS8uL25vZGVfbW9kdWxlcy9Ac3Rvcnlib29rL3Rlc3RpbmctbGlicmFyeS9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50L2Rpc3QvZXNtL3V0aWxzL2VkaXQvc2V0RmlsZXMuanM/NDcwMiIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vdXRpbGl0eS91cGxvYWQuanM/ZjNmMiIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vc2V0dXAvYXBpLmpzPzhjOWIiLCJ3ZWJwYWNrOi8vbGVhZnlncmVlbi11aS8uL25vZGVfbW9kdWxlcy9Ac3Rvcnlib29rL3Rlc3RpbmctbGlicmFyeS9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50L2Rpc3QvZXNtL3NldHVwL3dyYXBBc3luYy5qcz9jYTE3Iiwid2VicGFjazovL2xlYWZ5Z3JlZW4tdWkvLi9ub2RlX21vZHVsZXMvQHN0b3J5Ym9vay90ZXN0aW5nLWxpYnJhcnkvbm9kZV9tb2R1bGVzL0B0ZXN0aW5nLWxpYnJhcnkvdXNlci1ldmVudC9kaXN0L2VzbS9zZXR1cC9zZXR1cC5qcz82N2RjIiwid2VicGFjazovL2xlYWZ5Z3JlZW4tdWkvLi9ub2RlX21vZHVsZXMvQHN0b3J5Ym9vay90ZXN0aW5nLWxpYnJhcnkvbm9kZV9tb2R1bGVzL0B0ZXN0aW5nLWxpYnJhcnkvdXNlci1ldmVudC9kaXN0L2VzbS9zZXR1cC9kaXJlY3RBcGkuanM/OWNjMCIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vc2V0dXAvaW5kZXguanM/ZDQyNyIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQvZGlzdC9lc20vaW5kZXguanM/YTFlMSIsIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svdGVzdGluZy1saWJyYXJ5L2Rpc3QvaW5kZXgubWpzPzhhZTQiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gaXNFbGVtZW50VHlwZShlbGVtZW50LCB0YWcsIHByb3BzKSB7XG4gICAgaWYgKGVsZW1lbnQubmFtZXNwYWNlVVJJICYmIGVsZW1lbnQubmFtZXNwYWNlVVJJICE9PSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0YWcgPSBBcnJheS5pc0FycmF5KHRhZykgPyB0YWcgOiBbXG4gICAgICAgIHRhZ1xuICAgIF07XG4gICAgLy8gdGFnTmFtZSBpcyB1cHBlcmNhc2UgaW4gSFRNTERvY3VtZW50IGFuZCBsb3dlcmNhc2UgaW4gWE1MRG9jdW1lbnRcbiAgICBpZiAoIXRhZy5pbmNsdWRlcyhlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHByb3BzKS5ldmVyeSgoW2ssIHZdKT0+ZWxlbWVudFtrXSA9PT0gdik7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgeyBpc0VsZW1lbnRUeXBlIH07XG4iLCJpbXBvcnQgeyBpc0VsZW1lbnRUeXBlIH0gZnJvbSAnLi4vbWlzYy9pc0VsZW1lbnRUeXBlLmpzJztcblxudmFyIGNsaWNrYWJsZUlucHV0VHlwZXM7XG4oZnVuY3Rpb24oY2xpY2thYmxlSW5wdXRUeXBlcykge1xuICAgIGNsaWNrYWJsZUlucHV0VHlwZXNbJ2J1dHRvbiddID0gJ2J1dHRvbic7XG4gICAgY2xpY2thYmxlSW5wdXRUeXBlc1snY29sb3InXSA9ICdjb2xvcic7XG4gICAgY2xpY2thYmxlSW5wdXRUeXBlc1snZmlsZSddID0gJ2ZpbGUnO1xuICAgIGNsaWNrYWJsZUlucHV0VHlwZXNbJ2ltYWdlJ10gPSAnaW1hZ2UnO1xuICAgIGNsaWNrYWJsZUlucHV0VHlwZXNbJ3Jlc2V0J10gPSAncmVzZXQnO1xuICAgIGNsaWNrYWJsZUlucHV0VHlwZXNbJ3N1Ym1pdCddID0gJ3N1Ym1pdCc7XG4gICAgY2xpY2thYmxlSW5wdXRUeXBlc1snY2hlY2tib3gnXSA9ICdjaGVja2JveCc7XG4gICAgY2xpY2thYmxlSW5wdXRUeXBlc1sncmFkaW8nXSA9ICdyYWRpbyc7XG59KShjbGlja2FibGVJbnB1dFR5cGVzIHx8IChjbGlja2FibGVJbnB1dFR5cGVzID0ge30pKTtcbmZ1bmN0aW9uIGlzQ2xpY2thYmxlSW5wdXQoZWxlbWVudCkge1xuICAgIHJldHVybiBpc0VsZW1lbnRUeXBlKGVsZW1lbnQsICdidXR0b24nKSB8fCBpc0VsZW1lbnRUeXBlKGVsZW1lbnQsICdpbnB1dCcpICYmIGVsZW1lbnQudHlwZSBpbiBjbGlja2FibGVJbnB1dFR5cGVzO1xufVxuXG5leHBvcnQgeyBpc0NsaWNrYWJsZUlucHV0IH07XG4iLCJpbXBvcnQgeyBnZXRXaW5kb3dGcm9tTm9kZSB9IGZyb20gJ0B0ZXN0aW5nLWxpYnJhcnkvZG9tL2Rpc3QvaGVscGVycy5qcyc7XG5cbmZ1bmN0aW9uIGdldFdpbmRvdyhub2RlKSB7XG4gICAgcmV0dXJuIGdldFdpbmRvd0Zyb21Ob2RlKG5vZGUpO1xufVxuXG5leHBvcnQgeyBnZXRXaW5kb3cgfTtcbiIsIi8vIGpzZG9tIGRvZXMgbm90IGltcGxlbWVudCBCbG9iLnRleHQoKVxuZnVuY3Rpb24gcmVhZEJsb2JUZXh0KGJsb2IsIEZpbGVSZWFkZXIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKT0+e1xuICAgICAgICBjb25zdCBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIGZyLm9uZXJyb3IgPSByZWo7XG4gICAgICAgIGZyLm9uYWJvcnQgPSByZWo7XG4gICAgICAgIGZyLm9ubG9hZCA9ICgpPT57XG4gICAgICAgICAgICByZXMoU3RyaW5nKGZyLnJlc3VsdCkpO1xuICAgICAgICB9O1xuICAgICAgICBmci5yZWFkQXNUZXh0KGJsb2IpO1xuICAgIH0pO1xufVxuXG5leHBvcnQgeyByZWFkQmxvYlRleHQgfTtcbiIsIi8vIEZpbGVMaXN0IGNhbiBub3QgYmUgY3JlYXRlZCBwZXIgY29uc3RydWN0b3IuXG5mdW5jdGlvbiBjcmVhdGVGaWxlTGlzdCh3aW5kb3csIGZpbGVzKSB7XG4gICAgY29uc3QgbGlzdCA9IHtcbiAgICAgICAgLi4uZmlsZXMsXG4gICAgICAgIGxlbmd0aDogZmlsZXMubGVuZ3RoLFxuICAgICAgICBpdGVtOiAoaW5kZXgpPT5saXN0W2luZGV4XSxcbiAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl06IGZ1bmN0aW9uKiBuZXh0RmlsZSgpIHtcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICB5aWVsZCBsaXN0W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBsaXN0LmNvbnN0cnVjdG9yID0gd2luZG93LkZpbGVMaXN0O1xuICAgIC8vIGd1YXJkIGZvciBlbnZpcm9ubWVudHMgd2l0aG91dCBGaWxlTGlzdFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovIGlmICh3aW5kb3cuRmlsZUxpc3QpIHtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGxpc3QsIHdpbmRvdy5GaWxlTGlzdC5wcm90b3R5cGUpO1xuICAgIH1cbiAgICBPYmplY3QuZnJlZXplKGxpc3QpO1xuICAgIHJldHVybiBsaXN0O1xufVxuXG5leHBvcnQgeyBjcmVhdGVGaWxlTGlzdCB9O1xuIiwiaW1wb3J0IHsgY3JlYXRlRmlsZUxpc3QgfSBmcm9tICcuL0ZpbGVMaXN0LmpzJztcblxuLy8gRGF0YVRyYW5zZmVyIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiBqc2RvbS5cbi8vIERhdGFUcmFuc2ZlciB3aXRoIEZpbGVMaXN0IGlzIGJlaW5nIGNyZWF0ZWQgYnkgdGhlIGJyb3dzZXIgb24gY2VydGFpbiBldmVudHMuXG5jbGFzcyBEYXRhVHJhbnNmZXJJdGVtU3R1YiB7XG4gICAgZ2V0QXNGaWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWxlO1xuICAgIH1cbiAgICBnZXRBc1N0cmluZyhjYWxsYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMuZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gd2Via2l0R2V0QXNFbnRyeSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZGF0YU9yRmlsZSwgdHlwZSl7XG4gICAgICAgIHRoaXMuZmlsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhT3JGaWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5raW5kID0gJ3N0cmluZyc7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTdHJpbmcodHlwZSk7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhT3JGaWxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5raW5kID0gJ2ZpbGUnO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gZGF0YU9yRmlsZS50eXBlO1xuICAgICAgICAgICAgdGhpcy5maWxlID0gZGF0YU9yRmlsZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIERhdGFUcmFuc2Zlckl0ZW1MaXN0U3R1YiBleHRlbmRzIEFycmF5IHtcbiAgICBhZGQoLi4uYXJncykge1xuICAgICAgICBjb25zdCBpdGVtID0gbmV3IERhdGFUcmFuc2Zlckl0ZW1TdHViKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICB0aGlzLnB1c2goaXRlbSk7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5zcGxpY2UoMCwgdGhpcy5sZW5ndGgpO1xuICAgIH1cbiAgICByZW1vdmUoaW5kZXgpIHtcbiAgICAgICAgdGhpcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFR5cGVNYXRjaGVyKHR5cGUsIGV4YWN0KSB7XG4gICAgY29uc3QgW2dyb3VwLCBzdWJdID0gdHlwZS5zcGxpdCgnLycpO1xuICAgIGNvbnN0IGlzR3JvdXAgPSAhc3ViIHx8IHN1YiA9PT0gJyonO1xuICAgIHJldHVybiAoaXRlbSk9PntcbiAgICAgICAgcmV0dXJuIGV4YWN0ID8gaXRlbS50eXBlID09PSAoaXNHcm91cCA/IGdyb3VwIDogdHlwZSkgOiBpc0dyb3VwID8gaXRlbS50eXBlLnN0YXJ0c1dpdGgoYCR7Z3JvdXB9L2ApIDogaXRlbS50eXBlID09PSBncm91cDtcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlRGF0YVRyYW5zZmVyU3R1Yih3aW5kb3cpIHtcbiAgICByZXR1cm4gbmV3IGNsYXNzIERhdGFUcmFuc2ZlclN0dWIge1xuICAgICAgICBnZXREYXRhKGZvcm1hdCkge1xuICAgICAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gKHJlZiA9IHRoaXMuaXRlbXMuZmluZChnZXRUeXBlTWF0Y2hlcihmb3JtYXQsIHRydWUpKSkgIT09IG51bGwgJiYgcmVmICE9PSB2b2lkIDAgPyByZWYgOiB0aGlzLml0ZW1zLmZpbmQoZ2V0VHlwZU1hdGNoZXIoZm9ybWF0LCBmYWxzZSkpO1xuICAgICAgICAgICAgbGV0IHRleHQgPSAnJztcbiAgICAgICAgICAgIG1hdGNoID09PSBudWxsIHx8IG1hdGNoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXRjaC5nZXRBc1N0cmluZygodCk9PntcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgc2V0RGF0YShmb3JtYXQsIGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoSW5kZXggPSB0aGlzLml0ZW1zLmZpbmRJbmRleChnZXRUeXBlTWF0Y2hlcihmb3JtYXQsIHRydWUpKTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBuZXcgRGF0YVRyYW5zZmVySXRlbVN0dWIoZGF0YSwgZm9ybWF0KTtcbiAgICAgICAgICAgIGlmIChtYXRjaEluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW1zLnNwbGljZShtYXRjaEluZGV4LCAxLCBpdGVtKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNsZWFyRGF0YShmb3JtYXQpIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaEluZGV4ID0gdGhpcy5pdGVtcy5maW5kSW5kZXgoZ2V0VHlwZU1hdGNoZXIoZm9ybWF0LCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZW1zLnJlbW92ZShtYXRjaEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXMuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnZXQgdHlwZXMoKSB7XG4gICAgICAgICAgICBjb25zdCB0ID0gW107XG4gICAgICAgICAgICBpZiAodGhpcy5maWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0LnB1c2goJ0ZpbGVzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goKGkpPT50LnB1c2goaS50eXBlKSk7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKHQpO1xuICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gc2V0RHJhZ0ltYWdlKCkge31cbiAgICAgICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgICAgIHRoaXMuZHJvcEVmZmVjdCA9ICdub25lJztcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0QWxsb3dlZCA9ICd1bmluaXRpYWxpemVkJztcbiAgICAgICAgICAgIHRoaXMuaXRlbXMgPSBuZXcgRGF0YVRyYW5zZmVySXRlbUxpc3RTdHViKCk7XG4gICAgICAgICAgICB0aGlzLmZpbGVzID0gY3JlYXRlRmlsZUxpc3Qod2luZG93LCBbXSk7XG4gICAgICAgIH1cbiAgICB9KCk7XG59XG5mdW5jdGlvbiBjcmVhdGVEYXRhVHJhbnNmZXIod2luZG93LCBmaWxlcyA9IFtdKSB7XG4gICAgLy8gVXNlIHJlYWwgRGF0YVRyYW5zZmVyIGlmIGF2YWlsYWJsZVxuICAgIGNvbnN0IGR0ID0gdHlwZW9mIHdpbmRvdy5EYXRhVHJhbnNmZXIgPT09ICd1bmRlZmluZWQnID8gY3JlYXRlRGF0YVRyYW5zZmVyU3R1Yih3aW5kb3cpIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gbmV3IHdpbmRvdy5EYXRhVHJhbnNmZXIoKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZHQsICdmaWxlcycsIHtcbiAgICAgICAgZ2V0OiAoKT0+Y3JlYXRlRmlsZUxpc3Qod2luZG93LCBmaWxlcylcbiAgICB9KTtcbiAgICByZXR1cm4gZHQ7XG59XG5mdW5jdGlvbiBnZXRCbG9iRnJvbURhdGFUcmFuc2Zlckl0ZW0od2luZG93LCBpdGVtKSB7XG4gICAgaWYgKGl0ZW0ua2luZCA9PT0gJ2ZpbGUnKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmdldEFzRmlsZSgpO1xuICAgIH1cbiAgICBsZXQgZGF0YSA9ICcnO1xuICAgIGl0ZW0uZ2V0QXNTdHJpbmcoKHMpPT57XG4gICAgICAgIGRhdGEgPSBzO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgd2luZG93LkJsb2IoW1xuICAgICAgICBkYXRhXG4gICAgXSwge1xuICAgICAgICB0eXBlOiBpdGVtLnR5cGVcbiAgICB9KTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlRGF0YVRyYW5zZmVyLCBnZXRCbG9iRnJvbURhdGFUcmFuc2Zlckl0ZW0gfTtcbiIsImltcG9ydCB7IGdldFdpbmRvdyB9IGZyb20gJy4uL21pc2MvZ2V0V2luZG93LmpzJztcbmltcG9ydCB7IHJlYWRCbG9iVGV4dCB9IGZyb20gJy4vQmxvYi5qcyc7XG5pbXBvcnQgeyBjcmVhdGVEYXRhVHJhbnNmZXIsIGdldEJsb2JGcm9tRGF0YVRyYW5zZmVySXRlbSB9IGZyb20gJy4vRGF0YVRyYW5zZmVyLmpzJztcblxuLy8gQ2xpcGJvYXJkIGlzIG5vdCBhdmFpbGFibGUgaW4ganNkb21cbi8vIE1ETiBsaXN0cyBzdHJpbmd8QmxvYnxQcm9taXNlPEJsb2J8c3RyaW5nPiBhcyBwb3NzaWJsZSB0eXBlcyBpbiBDbGlwYm9hcmRJdGVtRGF0YVxuLy8gbGliLmRvbS5kLnRzIGxpc3RzIG9ubHkgUHJvbWlzZTxCbG9ifHN0cmluZz5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DbGlwYm9hcmRJdGVtL0NsaXBib2FyZEl0ZW0jc3ludGF4XG5mdW5jdGlvbiBjcmVhdGVDbGlwYm9hcmRJdGVtKHdpbmRvdywgLi4uYmxvYnMpIHtcbiAgICBjb25zdCBkYXRhTWFwID0gT2JqZWN0LmZyb21FbnRyaWVzKGJsb2JzLm1hcCgoYik9PltcbiAgICAgICAgICAgIHR5cGVvZiBiID09PSAnc3RyaW5nJyA/ICd0ZXh0L3BsYWluJyA6IGIudHlwZSxcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShiKSwgXG4gICAgICAgIF0pKTtcbiAgICAvLyB1c2UgcmVhbCBDbGlwYm9hcmRJdGVtIGlmIGF2YWlsYWJsZVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqLyBpZiAodHlwZW9mIHdpbmRvdy5DbGlwYm9hcmRJdGVtICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5DbGlwYm9hcmRJdGVtKGRhdGFNYXApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IGNsYXNzIENsaXBib2FyZEl0ZW0ge1xuICAgICAgICBnZXQgdHlwZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShPYmplY3Qua2V5cyh0aGlzLmRhdGEpKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBnZXRUeXBlKHR5cGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGhpcy5kYXRhW3R5cGVdO1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0eXBlfSBpcyBub3Qgb25lIG9mIHRoZSBhdmFpbGFibGUgTUlNRSB0eXBlcyBvbiB0aGlzIGl0ZW0uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiB3aW5kb3cuQmxvYiA/IHZhbHVlIDogbmV3IHdpbmRvdy5CbG9iKFtcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgXSwge1xuICAgICAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0cnVjdG9yKGQpe1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gZDtcbiAgICAgICAgfVxuICAgIH0oZGF0YU1hcCk7XG59XG5jb25zdCBDbGlwYm9hcmRTdHViQ29udHJvbCA9IFN5bWJvbCgnTWFuYWdlIENsaXBib2FyZFN1YicpO1xuZnVuY3Rpb24gY3JlYXRlQ2xpcGJvYXJkU3R1Yih3aW5kb3csIGNvbnRyb2wpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgY2xhc3MgQ2xpcGJvYXJkIGV4dGVuZHMgd2luZG93LkV2ZW50VGFyZ2V0IHtcbiAgICAgICAgYXN5bmMgcmVhZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuaXRlbXMpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIHJlYWRUZXh0KCkge1xuICAgICAgICAgICAgbGV0IHRleHQgPSAnJztcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLml0ZW1zKXtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gaXRlbS50eXBlcy5pbmNsdWRlcygndGV4dC9wbGFpbicpID8gJ3RleHQvcGxhaW4nIDogaXRlbS50eXBlcy5maW5kKCh0KT0+dC5zdGFydHNXaXRoKCd0ZXh0LycpKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IGF3YWl0IGl0ZW0uZ2V0VHlwZSh0eXBlKS50aGVuKChiKT0+cmVhZEJsb2JUZXh0KGIsIHdpbmRvdy5GaWxlUmVhZGVyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgd3JpdGUoZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5pdGVtcyA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgd3JpdGVUZXh0KHRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXMgPSBbXG4gICAgICAgICAgICAgICAgY3JlYXRlQ2xpcGJvYXJkSXRlbSh3aW5kb3csIHRleHQpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgICAgICB0aGlzLml0ZW1zID0gW107XG4gICAgICAgIH1cbiAgICB9KCksIHtcbiAgICAgICAgW0NsaXBib2FyZFN0dWJDb250cm9sXTogY29udHJvbFxuICAgIH0pO1xufVxuZnVuY3Rpb24gaXNDbGlwYm9hcmRTdHViKGNsaXBib2FyZCkge1xuICAgIHZhciByZWY7XG4gICAgcmV0dXJuICEhKChyZWYgPSBjbGlwYm9hcmQpID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmW0NsaXBib2FyZFN0dWJDb250cm9sXSk7XG59XG5mdW5jdGlvbiBhdHRhY2hDbGlwYm9hcmRTdHViVG9WaWV3KHdpbmRvdykge1xuICAgIGlmIChpc0NsaXBib2FyZFN0dWIod2luZG93Lm5hdmlnYXRvci5jbGlwYm9hcmQpKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLmNsaXBib2FyZFtDbGlwYm9hcmRTdHViQ29udHJvbF07XG4gICAgfVxuICAgIGNvbnN0IHJlYWxDbGlwYm9hcmQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHdpbmRvdy5uYXZpZ2F0b3IsICdjbGlwYm9hcmQnKTtcbiAgICBsZXQgc3R1YjtcbiAgICBjb25zdCBjb250cm9sID0ge1xuICAgICAgICByZXNldENsaXBib2FyZFN0dWI6ICgpPT57XG4gICAgICAgICAgICBzdHViID0gY3JlYXRlQ2xpcGJvYXJkU3R1Yih3aW5kb3csIGNvbnRyb2wpO1xuICAgICAgICB9LFxuICAgICAgICBkZXRhY2hDbGlwYm9hcmRTdHViOiAoKT0+e1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovIGlmIChyZWFsQ2xpcGJvYXJkKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5uYXZpZ2F0b3IsICdjbGlwYm9hcmQnLCByZWFsQ2xpcGJvYXJkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5uYXZpZ2F0b3IsICdjbGlwYm9hcmQnLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBzdHViID0gY3JlYXRlQ2xpcGJvYXJkU3R1Yih3aW5kb3csIGNvbnRyb2wpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cubmF2aWdhdG9yLCAnY2xpcGJvYXJkJywge1xuICAgICAgICBnZXQ6ICgpPT5zdHViLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gc3R1YltDbGlwYm9hcmRTdHViQ29udHJvbF07XG59XG5mdW5jdGlvbiByZXNldENsaXBib2FyZFN0dWJPblZpZXcod2luZG93KSB7XG4gICAgaWYgKGlzQ2xpcGJvYXJkU3R1Yih3aW5kb3cubmF2aWdhdG9yLmNsaXBib2FyZCkpIHtcbiAgICAgICAgd2luZG93Lm5hdmlnYXRvci5jbGlwYm9hcmRbQ2xpcGJvYXJkU3R1YkNvbnRyb2xdLnJlc2V0Q2xpcGJvYXJkU3R1YigpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRldGFjaENsaXBib2FyZFN0dWJGcm9tVmlldyh3aW5kb3cpIHtcbiAgICBpZiAoaXNDbGlwYm9hcmRTdHViKHdpbmRvdy5uYXZpZ2F0b3IuY2xpcGJvYXJkKSkge1xuICAgICAgICB3aW5kb3cubmF2aWdhdG9yLmNsaXBib2FyZFtDbGlwYm9hcmRTdHViQ29udHJvbF0uZGV0YWNoQ2xpcGJvYXJkU3R1YigpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHJlYWREYXRhVHJhbnNmZXJGcm9tQ2xpcGJvYXJkKGRvY3VtZW50KSB7XG4gICAgY29uc3Qgd2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgY29uc3QgY2xpcGJvYXJkID0gd2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93Lm5hdmlnYXRvci5jbGlwYm9hcmQ7XG4gICAgY29uc3QgaXRlbXMgPSBjbGlwYm9hcmQgJiYgYXdhaXQgY2xpcGJvYXJkLnJlYWQoKTtcbiAgICBpZiAoIWl0ZW1zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIENsaXBib2FyZCBBUEkgaXMgdW5hdmFpbGFibGUuJyk7XG4gICAgfVxuICAgIGNvbnN0IGR0ID0gY3JlYXRlRGF0YVRyYW5zZmVyKHdpbmRvdyk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKXtcbiAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIGl0ZW0udHlwZXMpe1xuICAgICAgICAgICAgZHQuc2V0RGF0YSh0eXBlLCBhd2FpdCBpdGVtLmdldFR5cGUodHlwZSkudGhlbigoYik9PnJlYWRCbG9iVGV4dChiLCB3aW5kb3cuRmlsZVJlYWRlcikpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZHQ7XG59XG5hc3luYyBmdW5jdGlvbiB3cml0ZURhdGFUcmFuc2ZlclRvQ2xpcGJvYXJkKGRvY3VtZW50LCBjbGlwYm9hcmREYXRhKSB7XG4gICAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KGRvY3VtZW50KTtcbiAgICBjb25zdCBjbGlwYm9hcmQgPSB3aW5kb3cubmF2aWdhdG9yLmNsaXBib2FyZDtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBjbGlwYm9hcmREYXRhLml0ZW1zLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgY29uc3QgZHRJdGVtID0gY2xpcGJvYXJkRGF0YS5pdGVtc1tpXTtcbiAgICAgICAgY29uc3QgYmxvYiA9IGdldEJsb2JGcm9tRGF0YVRyYW5zZmVySXRlbSh3aW5kb3csIGR0SXRlbSk7XG4gICAgICAgIGl0ZW1zLnB1c2goY3JlYXRlQ2xpcGJvYXJkSXRlbSh3aW5kb3csIGJsb2IpKTtcbiAgICB9XG4gICAgY29uc3Qgd3JpdHRlbiA9IGNsaXBib2FyZCAmJiBhd2FpdCBjbGlwYm9hcmQud3JpdGUoaXRlbXMpLnRoZW4oKCk9PnRydWUsIC8vIENhbiBoYXBwZW4gd2l0aCBvdGhlciBpbXBsZW1lbnRhdGlvbnMgdGhhdCBlLmcuIHJlcXVpcmUgcGVybWlzc2lvbnNcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyAoKT0+ZmFsc2UpO1xuICAgIGlmICghd3JpdHRlbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBDbGlwYm9hcmQgQVBJIGlzIHVuYXZhaWxhYmxlLicpO1xuICAgIH1cbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovIGlmICh0eXBlb2YgZ2xvYmFsVGhpcy5hZnRlckVhY2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICBnbG9iYWxUaGlzLmFmdGVyRWFjaCgoKT0+cmVzZXRDbGlwYm9hcmRTdHViT25WaWV3KGdsb2JhbFRoaXMud2luZG93KSk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqLyBpZiAodHlwZW9mIGdsb2JhbFRoaXMuYWZ0ZXJBbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICBnbG9iYWxUaGlzLmFmdGVyQWxsKCgpPT5kZXRhY2hDbGlwYm9hcmRTdHViRnJvbVZpZXcoZ2xvYmFsVGhpcy53aW5kb3cpKTtcbn1cblxuZXhwb3J0IHsgYXR0YWNoQ2xpcGJvYXJkU3R1YlRvVmlldywgY3JlYXRlQ2xpcGJvYXJkSXRlbSwgZGV0YWNoQ2xpcGJvYXJkU3R1YkZyb21WaWV3LCByZWFkRGF0YVRyYW5zZmVyRnJvbUNsaXBib2FyZCwgcmVzZXRDbGlwYm9hcmRTdHViT25WaWV3LCB3cml0ZURhdGFUcmFuc2ZlclRvQ2xpcGJvYXJkIH07XG4iLCIvL2pzZG9tIGlzIG5vdCBzdXBwb3J0aW5nIGlzQ29udGVudEVkaXRhYmxlXG5mdW5jdGlvbiBpc0NvbnRlbnRFZGl0YWJsZShlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSAmJiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpID09ICd0cnVlJyB8fCBlbGVtZW50LmdldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykgPT0gJycpO1xufVxuLyoqXG4gKiBJZiBhIG5vZGUgaXMgYSBjb250ZW50ZWRpdGFibGUgb3IgaW5zaWRlIG9uZSwgcmV0dXJuIHRoYXQgZWxlbWVudC5cbiAqLyBmdW5jdGlvbiBnZXRDb250ZW50RWRpdGFibGUobm9kZSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KG5vZGUpO1xuICAgIHJldHVybiBlbGVtZW50ICYmIChlbGVtZW50LmNsb3Nlc3QoJ1tjb250ZW50ZWRpdGFibGU9XCJcIl0nKSB8fCBlbGVtZW50LmNsb3Nlc3QoJ1tjb250ZW50ZWRpdGFibGU9XCJ0cnVlXCJdJykpO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IDEgPyBub2RlIDogbm9kZS5wYXJlbnRFbGVtZW50O1xufVxuXG5leHBvcnQgeyBnZXRDb250ZW50RWRpdGFibGUsIGlzQ29udGVudEVkaXRhYmxlIH07XG4iLCJpbXBvcnQgeyBpc0VsZW1lbnRUeXBlIH0gZnJvbSAnLi4vbWlzYy9pc0VsZW1lbnRUeXBlLmpzJztcbmltcG9ydCB7IGlzQ29udGVudEVkaXRhYmxlIH0gZnJvbSAnLi9pc0NvbnRlbnRFZGl0YWJsZS5qcyc7XG5cbmZ1bmN0aW9uIGlzRWRpdGFibGUoZWxlbWVudCkge1xuICAgIHJldHVybiBpc0VkaXRhYmxlSW5wdXRPclRleHRBcmVhKGVsZW1lbnQpICYmICFlbGVtZW50LnJlYWRPbmx5IHx8IGlzQ29udGVudEVkaXRhYmxlKGVsZW1lbnQpO1xufVxudmFyIGVkaXRhYmxlSW5wdXRUeXBlcztcbihmdW5jdGlvbihlZGl0YWJsZUlucHV0VHlwZXMpIHtcbiAgICBlZGl0YWJsZUlucHV0VHlwZXNbJ3RleHQnXSA9ICd0ZXh0JztcbiAgICBlZGl0YWJsZUlucHV0VHlwZXNbJ2RhdGUnXSA9ICdkYXRlJztcbiAgICBlZGl0YWJsZUlucHV0VHlwZXNbJ2RhdGV0aW1lLWxvY2FsJ10gPSAnZGF0ZXRpbWUtbG9jYWwnO1xuICAgIGVkaXRhYmxlSW5wdXRUeXBlc1snZW1haWwnXSA9ICdlbWFpbCc7XG4gICAgZWRpdGFibGVJbnB1dFR5cGVzWydtb250aCddID0gJ21vbnRoJztcbiAgICBlZGl0YWJsZUlucHV0VHlwZXNbJ251bWJlciddID0gJ251bWJlcic7XG4gICAgZWRpdGFibGVJbnB1dFR5cGVzWydwYXNzd29yZCddID0gJ3Bhc3N3b3JkJztcbiAgICBlZGl0YWJsZUlucHV0VHlwZXNbJ3NlYXJjaCddID0gJ3NlYXJjaCc7XG4gICAgZWRpdGFibGVJbnB1dFR5cGVzWyd0ZWwnXSA9ICd0ZWwnO1xuICAgIGVkaXRhYmxlSW5wdXRUeXBlc1sndGltZSddID0gJ3RpbWUnO1xuICAgIGVkaXRhYmxlSW5wdXRUeXBlc1sndXJsJ10gPSAndXJsJztcbiAgICBlZGl0YWJsZUlucHV0VHlwZXNbJ3dlZWsnXSA9ICd3ZWVrJztcbn0pKGVkaXRhYmxlSW5wdXRUeXBlcyB8fCAoZWRpdGFibGVJbnB1dFR5cGVzID0ge30pKTtcbmZ1bmN0aW9uIGlzRWRpdGFibGVJbnB1dE9yVGV4dEFyZWEoZWxlbWVudCkge1xuICAgIHJldHVybiBpc0VsZW1lbnRUeXBlKGVsZW1lbnQsICd0ZXh0YXJlYScpIHx8IGlzRWxlbWVudFR5cGUoZWxlbWVudCwgJ2lucHV0JykgJiYgZWxlbWVudC50eXBlIGluIGVkaXRhYmxlSW5wdXRUeXBlcztcbn1cblxuZXhwb3J0IHsgaXNFZGl0YWJsZSwgaXNFZGl0YWJsZUlucHV0T3JUZXh0QXJlYSB9O1xuIiwiaW1wb3J0IHsgaXNFbGVtZW50VHlwZSB9IGZyb20gJy4uL21pc2MvaXNFbGVtZW50VHlwZS5qcyc7XG5cbnZhciBtYXhMZW5ndGhTdXBwb3J0ZWRUeXBlcztcbihmdW5jdGlvbihtYXhMZW5ndGhTdXBwb3J0ZWRUeXBlcykge1xuICAgIG1heExlbmd0aFN1cHBvcnRlZFR5cGVzWydlbWFpbCddID0gJ2VtYWlsJztcbiAgICBtYXhMZW5ndGhTdXBwb3J0ZWRUeXBlc1sncGFzc3dvcmQnXSA9ICdwYXNzd29yZCc7XG4gICAgbWF4TGVuZ3RoU3VwcG9ydGVkVHlwZXNbJ3NlYXJjaCddID0gJ3NlYXJjaCc7XG4gICAgbWF4TGVuZ3RoU3VwcG9ydGVkVHlwZXNbJ3RlbGVwaG9uZSddID0gJ3RlbGVwaG9uZSc7XG4gICAgbWF4TGVuZ3RoU3VwcG9ydGVkVHlwZXNbJ3RleHQnXSA9ICd0ZXh0JztcbiAgICBtYXhMZW5ndGhTdXBwb3J0ZWRUeXBlc1sndXJsJ10gPSAndXJsJztcbn0pKG1heExlbmd0aFN1cHBvcnRlZFR5cGVzIHx8IChtYXhMZW5ndGhTdXBwb3J0ZWRUeXBlcyA9IHt9KSk7XG4vLyBjYW4ndCB1c2UgLm1heExlbmd0aCBwcm9wZXJ0eSBiZWNhdXNlIG9mIGEganNkb20gYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pzZG9tL2pzZG9tL2lzc3Vlcy8yOTI3XG5mdW5jdGlvbiBnZXRNYXhMZW5ndGgoZWxlbWVudCkge1xuICAgIHZhciByZWY7XG4gICAgY29uc3QgYXR0ciA9IChyZWYgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnbWF4bGVuZ3RoJykpICE9PSBudWxsICYmIHJlZiAhPT0gdm9pZCAwID8gcmVmIDogJyc7XG4gICAgcmV0dXJuIC9eXFxkKyQvLnRlc3QoYXR0cikgJiYgTnVtYmVyKGF0dHIpID49IDAgPyBOdW1iZXIoYXR0cikgOiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBzdXBwb3J0c01heExlbmd0aChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGlzRWxlbWVudFR5cGUoZWxlbWVudCwgJ3RleHRhcmVhJykgfHwgaXNFbGVtZW50VHlwZShlbGVtZW50LCAnaW5wdXQnKSAmJiBlbGVtZW50LnR5cGUgaW4gbWF4TGVuZ3RoU3VwcG9ydGVkVHlwZXM7XG59XG5cbmV4cG9ydCB7IGdldE1heExlbmd0aCwgc3VwcG9ydHNNYXhMZW5ndGggfTtcbiIsImNvbnN0IEZPQ1VTQUJMRV9TRUxFQ1RPUiA9IFtcbiAgICAnaW5wdXQ6bm90KFt0eXBlPWhpZGRlbl0pOm5vdChbZGlzYWJsZWRdKScsXG4gICAgJ2J1dHRvbjpub3QoW2Rpc2FibGVkXSknLFxuICAgICdzZWxlY3Q6bm90KFtkaXNhYmxlZF0pJyxcbiAgICAndGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pJyxcbiAgICAnW2NvbnRlbnRlZGl0YWJsZT1cIlwiXScsXG4gICAgJ1tjb250ZW50ZWRpdGFibGU9XCJ0cnVlXCJdJyxcbiAgICAnYVtocmVmXScsXG4gICAgJ1t0YWJpbmRleF06bm90KFtkaXNhYmxlZF0pJywgXG5dLmpvaW4oJywgJyk7XG5cbmV4cG9ydCB7IEZPQ1VTQUJMRV9TRUxFQ1RPUiB9O1xuIiwiaW1wb3J0IHsgRk9DVVNBQkxFX1NFTEVDVE9SIH0gZnJvbSAnLi9zZWxlY3Rvci5qcyc7XG5cbmZ1bmN0aW9uIGlzRm9jdXNhYmxlKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5tYXRjaGVzKEZPQ1VTQUJMRV9TRUxFQ1RPUik7XG59XG5cbmV4cG9ydCB7IGlzRm9jdXNhYmxlIH07XG4iLCJ2YXIgYnJhY2tldERpY3Q7XG4oZnVuY3Rpb24oYnJhY2tldERpY3QpIHtcbiAgICBicmFja2V0RGljdFsneyddID0gJ30nO1xuICAgIGJyYWNrZXREaWN0WydbJ10gPSAnXSc7XG59KShicmFja2V0RGljdCB8fCAoYnJhY2tldERpY3QgPSB7fSkpO1xuLyoqXG4gKiBSZWFkIHRoZSBuZXh0IGtleSBkZWZpbml0aW9uIGZyb20gdXNlciBpbnB1dFxuICpcbiAqIERlc2NyaWJlIGtleSBwZXIgYHtkZXNjcmlwdG9yfWAgb3IgYFtkZXNjcmlwdG9yXWAuXG4gKiBFdmVyeXRoaW5nIGVsc2Ugd2lsbCBiZSBpbnRlcnByZXRlZCBhcyBhIHNpbmdsZSBjaGFyYWN0ZXIgYXMgZGVzY3JpcHRvciAtIGUuZy4gYGFgLlxuICogQnJhY2tldHMgYHtgIGFuZCBgW2AgY2FuIGJlIGVzY2FwZWQgYnkgZG91YmxpbmcgLSBlLmcuIGBmb29bW2JhcmAgdHJhbnNsYXRlcyB0byBgZm9vW2JhcmAuXG4gKiBBIHByZXZpb3VzbHkgcHJlc3NlZCBrZXkgY2FuIGJlIHJlbGVhc2VkIHBlciBgey9kZXNjcmlwdG9yfWAuXG4gKiBLZWVwaW5nIHRoZSBrZXkgcHJlc3NlZCBjYW4gYmUgd3JpdHRlbiBhcyBge2Rlc2NyaXB0b3I+fWAuXG4gKiBXaGVuIGtlZXBpbmcgdGhlIGtleSBwcmVzc2VkIHlvdSBjYW4gY2hvb3NlIGhvdyBsb25nIHRoZSBrZXkgaXMgcHJlc3NlZCBge2Rlc2NyaXB0b3I+M31gLlxuICogWW91IGNhbiB0aGVuIHJlbGVhc2UgdGhlIGtleSBwZXIgYHtkZXNjcmlwdG9yPjMvfWAgb3Iga2VlcCBpdCBwcmVzc2VkIGFuZCBjb250aW51ZSB3aXRoIHRoZSBuZXh0IGtleS5cbiAqLyBmdW5jdGlvbiByZWFkTmV4dERlc2NyaXB0b3IodGV4dCwgY29udGV4dCkge1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGNvbnN0IHN0YXJ0QnJhY2tldCA9IHRleHRbcG9zXSBpbiBicmFja2V0RGljdCA/IHRleHRbcG9zXSA6ICcnO1xuICAgIHBvcyArPSBzdGFydEJyYWNrZXQubGVuZ3RoO1xuICAgIGNvbnN0IGlzRXNjYXBlZENoYXIgPSBuZXcgUmVnRXhwKGBeXFxcXCR7c3RhcnRCcmFja2V0fXsyfWApLnRlc3QodGV4dCk7XG4gICAgY29uc3QgdHlwZSA9IGlzRXNjYXBlZENoYXIgPyAnJyA6IHN0YXJ0QnJhY2tldDtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlLFxuICAgICAgICAuLi50eXBlID09PSAnJyA/IHJlYWRQcmludGFibGVDaGFyKHRleHQsIHBvcywgY29udGV4dCkgOiByZWFkVGFnKHRleHQsIHBvcywgdHlwZSwgY29udGV4dClcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVhZFByaW50YWJsZUNoYXIodGV4dCwgcG9zLCBjb250ZXh0KSB7XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IHRleHRbcG9zXTtcbiAgICBhc3NlcnREZXNjcmlwdG9yKGRlc2NyaXB0b3IsIHRleHQsIHBvcywgY29udGV4dCk7XG4gICAgcG9zICs9IGRlc2NyaXB0b3IubGVuZ3RoO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnN1bWVkTGVuZ3RoOiBwb3MsXG4gICAgICAgIGRlc2NyaXB0b3IsXG4gICAgICAgIHJlbGVhc2VQcmV2aW91czogZmFsc2UsXG4gICAgICAgIHJlbGVhc2VTZWxmOiB0cnVlLFxuICAgICAgICByZXBlYXQ6IDFcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVhZFRhZyh0ZXh0LCBwb3MsIHN0YXJ0QnJhY2tldCwgY29udGV4dCkge1xuICAgIHZhciByZWYsIHJlZjE7XG4gICAgY29uc3QgcmVsZWFzZVByZXZpb3VzTW9kaWZpZXIgPSB0ZXh0W3Bvc10gPT09ICcvJyA/ICcvJyA6ICcnO1xuICAgIHBvcyArPSByZWxlYXNlUHJldmlvdXNNb2RpZmllci5sZW5ndGg7XG4gICAgY29uc3QgZXNjYXBlZERlc2NyaXB0b3IgPSBzdGFydEJyYWNrZXQgPT09ICd7JyAmJiB0ZXh0W3Bvc10gPT09ICdcXFxcJztcbiAgICBwb3MgKz0gTnVtYmVyKGVzY2FwZWREZXNjcmlwdG9yKTtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gZXNjYXBlZERlc2NyaXB0b3IgPyB0ZXh0W3Bvc10gOiAocmVmID0gdGV4dC5zbGljZShwb3MpLm1hdGNoKHN0YXJ0QnJhY2tldCA9PT0gJ3snID8gL15cXHcrfF5bXn0+L10vIDogL15cXHcrLykpID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmWzBdO1xuICAgIGFzc2VydERlc2NyaXB0b3IoZGVzY3JpcHRvciwgdGV4dCwgcG9zLCBjb250ZXh0KTtcbiAgICBwb3MgKz0gZGVzY3JpcHRvci5sZW5ndGg7XG4gICAgdmFyIHJlZjI7XG4gICAgY29uc3QgcmVwZWF0TW9kaWZpZXIgPSAocmVmMiA9IChyZWYxID0gdGV4dC5zbGljZShwb3MpLm1hdGNoKC9ePlxcZCsvKSkgPT09IG51bGwgfHwgcmVmMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmMVswXSkgIT09IG51bGwgJiYgcmVmMiAhPT0gdm9pZCAwID8gcmVmMiA6ICcnO1xuICAgIHBvcyArPSByZXBlYXRNb2RpZmllci5sZW5ndGg7XG4gICAgY29uc3QgcmVsZWFzZVNlbGZNb2RpZmllciA9IHRleHRbcG9zXSA9PT0gJy8nIHx8ICFyZXBlYXRNb2RpZmllciAmJiB0ZXh0W3Bvc10gPT09ICc+JyA/IHRleHRbcG9zXSA6ICcnO1xuICAgIHBvcyArPSByZWxlYXNlU2VsZk1vZGlmaWVyLmxlbmd0aDtcbiAgICBjb25zdCBleHBlY3RlZEVuZEJyYWNrZXQgPSBicmFja2V0RGljdFtzdGFydEJyYWNrZXRdO1xuICAgIGNvbnN0IGVuZEJyYWNrZXQgPSB0ZXh0W3Bvc10gPT09IGV4cGVjdGVkRW5kQnJhY2tldCA/IGV4cGVjdGVkRW5kQnJhY2tldCA6ICcnO1xuICAgIGlmICghZW5kQnJhY2tldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0RXJyb3JNZXNzYWdlKFtcbiAgICAgICAgICAgICFyZXBlYXRNb2RpZmllciAmJiAncmVwZWF0IG1vZGlmaWVyJyxcbiAgICAgICAgICAgICFyZWxlYXNlU2VsZk1vZGlmaWVyICYmICdyZWxlYXNlIG1vZGlmaWVyJyxcbiAgICAgICAgICAgIGBcIiR7ZXhwZWN0ZWRFbmRCcmFja2V0fVwiYCwgXG4gICAgICAgIF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJyBvciAnKSwgdGV4dFtwb3NdLCB0ZXh0LCBjb250ZXh0KSk7XG4gICAgfVxuICAgIHBvcyArPSBlbmRCcmFja2V0Lmxlbmd0aDtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb25zdW1lZExlbmd0aDogcG9zLFxuICAgICAgICBkZXNjcmlwdG9yLFxuICAgICAgICByZWxlYXNlUHJldmlvdXM6ICEhcmVsZWFzZVByZXZpb3VzTW9kaWZpZXIsXG4gICAgICAgIHJlcGVhdDogcmVwZWF0TW9kaWZpZXIgPyBNYXRoLm1heChOdW1iZXIocmVwZWF0TW9kaWZpZXIuc3Vic3RyKDEpKSwgMSkgOiAxLFxuICAgICAgICByZWxlYXNlU2VsZjogaGFzUmVsZWFzZVNlbGYocmVsZWFzZVNlbGZNb2RpZmllciwgcmVwZWF0TW9kaWZpZXIpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFzc2VydERlc2NyaXB0b3IoZGVzY3JpcHRvciwgdGV4dCwgcG9zLCBjb250ZXh0KSB7XG4gICAgaWYgKCFkZXNjcmlwdG9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihnZXRFcnJvck1lc3NhZ2UoJ2tleSBkZXNjcmlwdG9yJywgdGV4dFtwb3NdLCB0ZXh0LCBjb250ZXh0KSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzUmVsZWFzZVNlbGYocmVsZWFzZVNlbGZNb2RpZmllciwgcmVwZWF0TW9kaWZpZXIpIHtcbiAgICBpZiAocmVsZWFzZVNlbGZNb2RpZmllcikge1xuICAgICAgICByZXR1cm4gcmVsZWFzZVNlbGZNb2RpZmllciA9PT0gJy8nO1xuICAgIH1cbiAgICBpZiAocmVwZWF0TW9kaWZpZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShleHBlY3RlZCwgZm91bmQsIHRleHQsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gYEV4cGVjdGVkICR7ZXhwZWN0ZWR9IGJ1dCBmb3VuZCBcIiR7Zm91bmQgIT09IG51bGwgJiYgZm91bmQgIT09IHZvaWQgMCA/IGZvdW5kIDogJyd9XCIgaW4gXCIke3RleHR9XCJcbiAgICBTZWUgJHtjb250ZXh0ID09PSAncG9pbnRlcicgPyBgaHR0cHM6Ly90ZXN0aW5nLWxpYnJhcnkuY29tL2RvY3MvdXNlci1ldmVudC9wb2ludGVyI3ByZXNzaW5nLWEtYnV0dG9uLW9yLXRvdWNoaW5nLXRoZS1zY3JlZW5gIDogYGh0dHBzOi8vdGVzdGluZy1saWJyYXJ5LmNvbS9kb2NzL3VzZXItZXZlbnQva2V5Ym9hcmRgfVxuICAgIGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGhvdyB1c2VyRXZlbnQgcGFyc2VzIHlvdXIgaW5wdXQuYDtcbn1cblxuZXhwb3J0IHsgcmVhZE5leHREZXNjcmlwdG9yIH07XG4iLCJmdW5jdGlvbiBjbG9uZUV2ZW50KGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBldmVudC5jb25zdHJ1Y3RvcihldmVudC50eXBlLCBldmVudCk7XG59XG5cbmV4cG9ydCB7IGNsb25lRXZlbnQgfTtcbiIsInZhciBBcGlMZXZlbDtcbihmdW5jdGlvbihBcGlMZXZlbCkge1xuICAgIEFwaUxldmVsW0FwaUxldmVsW1wiVHJpZ2dlclwiXSA9IDJdID0gXCJUcmlnZ2VyXCI7XG4gICAgQXBpTGV2ZWxbQXBpTGV2ZWxbXCJDYWxsXCJdID0gMV0gPSBcIkNhbGxcIjtcbn0pKEFwaUxldmVsIHx8IChBcGlMZXZlbCA9IHt9KSk7XG5mdW5jdGlvbiBzZXRMZXZlbFJlZihpbnN0YW5jZSwgbGV2ZWwpIHtcbiAgICBpbnN0YW5jZS5sZXZlbFJlZnNbbGV2ZWxdID0ge307XG59XG5mdW5jdGlvbiBnZXRMZXZlbFJlZihpbnN0YW5jZSwgbGV2ZWwpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UubGV2ZWxSZWZzW2xldmVsXTtcbn1cblxuZXhwb3J0IHsgQXBpTGV2ZWwsIGdldExldmVsUmVmLCBzZXRMZXZlbFJlZiB9O1xuIiwidmFyIFBvaW50ZXJFdmVudHNDaGVja0xldmVsO1xuKGZ1bmN0aW9uKFBvaW50ZXJFdmVudHNDaGVja0xldmVsKSB7XG4gICAgUG9pbnRlckV2ZW50c0NoZWNrTGV2ZWxbUG9pbnRlckV2ZW50c0NoZWNrTGV2ZWxbLyoqXG4gICAqIENoZWNrIHBvaW50ZXIgZXZlbnRzIG9uIGV2ZXJ5IHVzZXIgaW50ZXJhY3Rpb24gdGhhdCB0cmlnZ2VycyBhIGJ1bmNoIG9mIGV2ZW50cy5cbiAgICogRS5nLiBvbmNlIGZvciByZWxlYXNpbmcgYSBtb3VzZSBidXR0b24gZXZlbiB0aG91Z2ggdGhpcyB0cmlnZ2VycyBgcG9pbnRlcnVwYCwgYG1vdXNldXBgLCBgY2xpY2tgLCBldGMuLi5cbiAgICovIFwiRWFjaFRyaWdnZXJcIl0gPSA0XSA9IFwiRWFjaFRyaWdnZXJcIjtcbiAgICBQb2ludGVyRXZlbnRzQ2hlY2tMZXZlbFtQb2ludGVyRXZlbnRzQ2hlY2tMZXZlbFsvKiogQ2hlY2sgZWFjaCB0YXJnZXQgb25jZSBwZXIgY2FsbCB0byBwb2ludGVyIChyZWxhdGVkKSBBUEkgKi8gXCJFYWNoQXBpQ2FsbFwiXSA9IDJdID0gXCJFYWNoQXBpQ2FsbFwiO1xuICAgIFBvaW50ZXJFdmVudHNDaGVja0xldmVsW1BvaW50ZXJFdmVudHNDaGVja0xldmVsWy8qKiBDaGVjayBlYWNoIGV2ZW50IHRhcmdldCBvbmNlICovIFwiRWFjaFRhcmdldFwiXSA9IDFdID0gXCJFYWNoVGFyZ2V0XCI7XG4gICAgUG9pbnRlckV2ZW50c0NoZWNrTGV2ZWxbUG9pbnRlckV2ZW50c0NoZWNrTGV2ZWxbLyoqIE5vIHBvaW50ZXIgZXZlbnRzIGNoZWNrICovIFwiTmV2ZXJcIl0gPSAwXSA9IFwiTmV2ZXJcIjtcbn0pKFBvaW50ZXJFdmVudHNDaGVja0xldmVsIHx8IChQb2ludGVyRXZlbnRzQ2hlY2tMZXZlbCA9IHt9KSk7XG5cbmV4cG9ydCB7IFBvaW50ZXJFdmVudHNDaGVja0xldmVsIH07XG4iLCJpbXBvcnQgeyBpc0VsZW1lbnRUeXBlIH0gZnJvbSAnLi9pc0VsZW1lbnRUeXBlLmpzJztcblxuLy8gVGhpcyBzaG91bGQgcHJvYmFibHkganVzdCByZWx5IG9uIHRoZSA6ZGlzYWJsZWQgcHNldWRvLWNsYXNzLCBidXQgSlNET00gZG9lc24ndCBpbXBsZW1lbnQgaXQgcHJvcGVybHkuXG5mdW5jdGlvbiBpc0Rpc2FibGVkKGVsZW1lbnQpIHtcbiAgICBmb3IobGV0IGVsID0gZWxlbWVudDsgZWw7IGVsID0gZWwucGFyZW50RWxlbWVudCl7XG4gICAgICAgIGlmIChpc0VsZW1lbnRUeXBlKGVsLCBbXG4gICAgICAgICAgICAnYnV0dG9uJyxcbiAgICAgICAgICAgICdpbnB1dCcsXG4gICAgICAgICAgICAnc2VsZWN0JyxcbiAgICAgICAgICAgICd0ZXh0YXJlYScsXG4gICAgICAgICAgICAnb3B0Z3JvdXAnLFxuICAgICAgICAgICAgJ29wdGlvbicsIFxuICAgICAgICBdKSkge1xuICAgICAgICAgICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlzRWxlbWVudFR5cGUoZWwsICdmaWVsZHNldCcpKSB7XG4gICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSAmJiAhKChyZWYgPSBlbC5xdWVyeVNlbGVjdG9yKCc6c2NvcGUgPiBsZWdlbmQnKSkgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYuY29udGFpbnMoZWxlbWVudCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZWwudGFnTmFtZS5pbmNsdWRlcygnLScpKSB7XG4gICAgICAgICAgICBpZiAoZWwuY29uc3RydWN0b3IuZm9ybUFzc29jaWF0ZWQgJiYgZWwuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgeyBpc0Rpc2FibGVkIH07XG4iLCJpbXBvcnQgeyBpc0Rpc2FibGVkIH0gZnJvbSAnLi4vbWlzYy9pc0Rpc2FibGVkLmpzJztcblxuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudChkb2N1bWVudCkge1xuICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChhY3RpdmVFbGVtZW50ID09PSBudWxsIHx8IGFjdGl2ZUVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdCkge1xuICAgICAgICByZXR1cm4gZ2V0QWN0aXZlRWxlbWVudChhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZG9lcyBub3QgeWllbGQgZGlzYWJsZWQgZWxlbWVudHMgYXMgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAtIGpzZG9tIGRvZXNcbiAgICAgICAgaWYgKGlzRGlzYWJsZWQoYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5vd25lckRvY3VtZW50ID8gLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZG9jdW1lbnQub3duZXJEb2N1bWVudC5ib2R5IDogZG9jdW1lbnQuYm9keTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWN0aXZlRWxlbWVudDtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRBY3RpdmVFbGVtZW50T3JCb2R5KGRvY3VtZW50KSB7XG4gICAgdmFyIHJlZjtcbiAgICByZXR1cm4gKHJlZiA9IGdldEFjdGl2ZUVsZW1lbnQoZG9jdW1lbnQpKSAhPT0gbnVsbCAmJiByZWYgIT09IHZvaWQgMCA/IHJlZiA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGRvY3VtZW50LmJvZHk7XG59XG5cbmV4cG9ydCB7IGdldEFjdGl2ZUVsZW1lbnQsIGdldEFjdGl2ZUVsZW1lbnRPckJvZHkgfTtcbiIsImZ1bmN0aW9uIGZpbmRDbG9zZXN0KGVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgbGV0IGVsID0gZWxlbWVudDtcbiAgICBkbyB7XG4gICAgICAgIGlmIChjYWxsYmFjayhlbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfVxuICAgICAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gICAgfXdoaWxlIChlbCAmJiBlbCAhPT0gZWxlbWVudC5vd25lckRvY3VtZW50LmJvZHkpXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IHsgZmluZENsb3Nlc3QgfTtcbiIsImltcG9ydCB7IGlzQ2xpY2thYmxlSW5wdXQgfSBmcm9tICcuLi9jbGljay9pc0NsaWNrYWJsZUlucHV0LmpzJztcbmltcG9ydCB7IGlzRWRpdGFibGVJbnB1dE9yVGV4dEFyZWEgfSBmcm9tICcuLi9lZGl0L2lzRWRpdGFibGUuanMnO1xuXG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgZWxlbWVudCBoYXMgaXRzIG93biBzZWxlY3Rpb24gaW1wbGVtZW50YXRpb25cbiAqIGFuZCBkb2VzIG5vdCBpbnRlcmFjdCB3aXRoIHRoZSBEb2N1bWVudCBTZWxlY3Rpb24gQVBJLlxuICovIGZ1bmN0aW9uIGhhc093blNlbGVjdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIGlzRWxlbWVudChub2RlKSAmJiBpc0VkaXRhYmxlSW5wdXRPclRleHRBcmVhKG5vZGUpO1xufVxuZnVuY3Rpb24gaGFzTm9TZWxlY3Rpb24obm9kZSkge1xuICAgIHJldHVybiBpc0VsZW1lbnQobm9kZSkgJiYgaXNDbGlja2FibGVJbnB1dChub2RlKTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IDE7XG59XG5cbmV4cG9ydCB7IGhhc05vU2VsZWN0aW9uLCBoYXNPd25TZWxlY3Rpb24gfTtcbiIsImltcG9ydCAnLi4vLi4vdXRpbHMvY2xpY2svaXNDbGlja2FibGVJbnB1dC5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2RhdGFUcmFuc2Zlci9DbGlwYm9hcmQuanMnO1xuaW1wb3J0IHsgZ2V0Q29udGVudEVkaXRhYmxlIH0gZnJvbSAnLi4vLi4vdXRpbHMvZWRpdC9pc0NvbnRlbnRFZGl0YWJsZS5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2VkaXQvaXNFZGl0YWJsZS5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2VkaXQvbWF4TGVuZ3RoLmpzJztcbmltcG9ydCAnQHRlc3RpbmctbGlicmFyeS9kb20vZGlzdC9oZWxwZXJzLmpzJztcbmltcG9ydCB7IGhhc093blNlbGVjdGlvbiB9IGZyb20gJy4uLy4uL3V0aWxzL2ZvY3VzL3NlbGVjdGlvbi5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2tleURlZi9yZWFkTmV4dERlc2NyaXB0b3IuanMnO1xuaW1wb3J0ICcuLi8uLi91dGlscy9taXNjL2xldmVsLmpzJztcbmltcG9ydCAnLi4vLi4vb3B0aW9ucy5qcyc7XG5cbi8qKlxuICogUmVzZXQgdGhlIERvY3VtZW50IFNlbGVjdGlvbiB3aGVuIG1vdmluZyBmb2N1cyBpbnRvIGFuIGVsZW1lbnRcbiAqIHdpdGggb3duIHNlbGVjdGlvbiBpbXBsZW1lbnRhdGlvbi5cbiAqLyBmdW5jdGlvbiB1cGRhdGVTZWxlY3Rpb25PbkZvY3VzKGVsZW1lbnQpIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovIGlmICghKHNlbGVjdGlvbiA9PT0gbnVsbCB8fCBzZWxlY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbGVjdGlvbi5mb2N1c05vZGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgdGhlIGZvY3VzIG1vdmVzIGluc2lkZSBhbiBlbGVtZW50IHdpdGggb3duIHNlbGVjdGlvbiBpbXBsZW1lbnRhdGlvbixcbiAgICAvLyB0aGUgZG9jdW1lbnQgc2VsZWN0aW9uIHdpbGwgYmUgdGhpcyBlbGVtZW50LlxuICAgIC8vIEJ1dCBpZiB0aGUgZm9jdXNlZCBlbGVtZW50IGlzIGluc2lkZSBhIGNvbnRlbnRlZGl0YWJsZSxcbiAgICAvLyAxKSBhIGNvbGxhcHNlZCBzZWxlY3Rpb24gd2lsbCBiZSByZXRhaW5lZC5cbiAgICAvLyAyKSBvdGhlciBzZWxlY3Rpb25zIHdpbGwgYmUgcmVwbGFjZWQgYnkgYSBjdXJzb3JcbiAgICAvLyAgMi5hKSBhdCB0aGUgc3RhcnQgb2YgdGhlIGZpcnN0IGNoaWxkIGlmIGl0IGlzIGEgdGV4dCBub2RlXG4gICAgLy8gIDIuYikgYXQgdGhlIHN0YXJ0IG9mIHRoZSBjb250ZW50ZWRpdGFibGUuXG4gICAgaWYgKGhhc093blNlbGVjdGlvbihlbGVtZW50KSkge1xuICAgICAgICBjb25zdCBjb250ZW50ZWRpdGFibGUgPSBnZXRDb250ZW50RWRpdGFibGUoc2VsZWN0aW9uLmZvY3VzTm9kZSk7XG4gICAgICAgIGlmIChjb250ZW50ZWRpdGFibGUpIHtcbiAgICAgICAgICAgIGlmICghc2VsZWN0aW9uLmlzQ29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgICAgICAgICBjb25zdCBmb2N1c05vZGUgPSAoKHJlZiA9IGNvbnRlbnRlZGl0YWJsZS5maXJzdENoaWxkKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5ub2RlVHlwZSkgPT09IDMgPyBjb250ZW50ZWRpdGFibGUuZmlyc3RDaGlsZCA6IGNvbnRlbnRlZGl0YWJsZTtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uc2V0QmFzZUFuZEV4dGVudChmb2N1c05vZGUsIDAsIGZvY3VzTm9kZSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxlY3Rpb24uc2V0QmFzZUFuZEV4dGVudChlbGVtZW50LCAwLCBlbGVtZW50LCAwKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHsgdXBkYXRlU2VsZWN0aW9uT25Gb2N1cyB9O1xuIiwiaW1wb3J0IHsgZ2V0Q29uZmlnIH0gZnJvbSAnQHRlc3RpbmctbGlicmFyeS9kb20nO1xuXG5mdW5jdGlvbiB3cmFwRXZlbnQoY2IsIF9lbGVtZW50KSB7XG4gICAgcmV0dXJuIGdldENvbmZpZygpLmV2ZW50V3JhcHBlcihjYik7XG59XG5cbmV4cG9ydCB7IHdyYXBFdmVudCB9O1xuIiwiaW1wb3J0ICcuLi91dGlscy9jbGljay9pc0NsaWNrYWJsZUlucHV0LmpzJztcbmltcG9ydCAnLi4vdXRpbHMvZGF0YVRyYW5zZmVyL0NsaXBib2FyZC5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2VkaXQvaXNFZGl0YWJsZS5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2VkaXQvbWF4TGVuZ3RoLmpzJztcbmltcG9ydCB7IGdldEFjdGl2ZUVsZW1lbnQgfSBmcm9tICcuLi91dGlscy9mb2N1cy9nZXRBY3RpdmVFbGVtZW50LmpzJztcbmltcG9ydCAnQHRlc3RpbmctbGlicmFyeS9kb20vZGlzdC9oZWxwZXJzLmpzJztcbmltcG9ydCB7IGlzRm9jdXNhYmxlIH0gZnJvbSAnLi4vdXRpbHMvZm9jdXMvaXNGb2N1c2FibGUuanMnO1xuaW1wb3J0ICcuLi91dGlscy9rZXlEZWYvcmVhZE5leHREZXNjcmlwdG9yLmpzJztcbmltcG9ydCB7IGZpbmRDbG9zZXN0IH0gZnJvbSAnLi4vdXRpbHMvbWlzYy9maW5kQ2xvc2VzdC5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL21pc2MvbGV2ZWwuanMnO1xuaW1wb3J0ICcuLi9vcHRpb25zLmpzJztcbmltcG9ydCB7IHVwZGF0ZVNlbGVjdGlvbk9uRm9jdXMgfSBmcm9tICcuL3NlbGVjdGlvbi91cGRhdGVTZWxlY3Rpb25PbkZvY3VzLmpzJztcbmltcG9ydCB7IHdyYXBFdmVudCB9IGZyb20gJy4vd3JhcEV2ZW50LmpzJztcblxuLyoqXG4gKiBGb2N1cyBjbG9zZXN0IGZvY3VzYWJsZSBlbGVtZW50LlxuICovIGZ1bmN0aW9uIGZvY3VzRWxlbWVudChlbGVtZW50KSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZmluZENsb3Nlc3QoZWxlbWVudCwgaXNGb2N1c2FibGUpO1xuICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBnZXRBY3RpdmVFbGVtZW50KGVsZW1lbnQub3duZXJEb2N1bWVudCk7XG4gICAgaWYgKCh0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keSkgPT09IGFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0KSB7XG4gICAgICAgIHdyYXBFdmVudCgoKT0+dGFyZ2V0LmZvY3VzKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdyYXBFdmVudCgoKT0+e1xuICAgICAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgICAgIHJldHVybiAocmVmID0gYWN0aXZlRWxlbWVudCkgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYuYmx1cigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlU2VsZWN0aW9uT25Gb2N1cyh0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keSk7XG59XG5mdW5jdGlvbiBibHVyRWxlbWVudChlbGVtZW50KSB7XG4gICAgaWYgKCFpc0ZvY3VzYWJsZShlbGVtZW50KSkgcmV0dXJuO1xuICAgIGNvbnN0IHdhc0FjdGl2ZSA9IGdldEFjdGl2ZUVsZW1lbnQoZWxlbWVudC5vd25lckRvY3VtZW50KSA9PT0gZWxlbWVudDtcbiAgICBpZiAoIXdhc0FjdGl2ZSkgcmV0dXJuO1xuICAgIHdyYXBFdmVudCgoKT0+ZWxlbWVudC5ibHVyKCkpO1xufVxuXG5leHBvcnQgeyBibHVyRWxlbWVudCwgZm9jdXNFbGVtZW50IH07XG4iLCJjb25zdCBiZWhhdmlvciA9IHt9O1xuXG5leHBvcnQgeyBiZWhhdmlvciB9O1xuIiwiaW1wb3J0ICcuLi8uLi91dGlscy9jbGljay9pc0NsaWNrYWJsZUlucHV0LmpzJztcbmltcG9ydCAnLi4vLi4vdXRpbHMvZGF0YVRyYW5zZmVyL0NsaXBib2FyZC5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2VkaXQvaXNFZGl0YWJsZS5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2VkaXQvbWF4TGVuZ3RoLmpzJztcbmltcG9ydCB7IGlzRWxlbWVudFR5cGUgfSBmcm9tICcuLi8uLi91dGlscy9taXNjL2lzRWxlbWVudFR5cGUuanMnO1xuaW1wb3J0IHsgZ2V0V2luZG93IH0gZnJvbSAnLi4vLi4vdXRpbHMvbWlzYy9nZXRXaW5kb3cuanMnO1xuaW1wb3J0IHsgaXNGb2N1c2FibGUgfSBmcm9tICcuLi8uLi91dGlscy9mb2N1cy9pc0ZvY3VzYWJsZS5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2tleURlZi9yZWFkTmV4dERlc2NyaXB0b3IuanMnO1xuaW1wb3J0IHsgY2xvbmVFdmVudCB9IGZyb20gJy4uLy4uL3V0aWxzL21pc2MvY2xvbmVFdmVudC5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL21pc2MvbGV2ZWwuanMnO1xuaW1wb3J0ICcuLi8uLi9vcHRpb25zLmpzJztcbmltcG9ydCB7IGZvY3VzRWxlbWVudCwgYmx1ckVsZW1lbnQgfSBmcm9tICcuLi9mb2N1cy5qcyc7XG5pbXBvcnQgeyBiZWhhdmlvciB9IGZyb20gJy4vcmVnaXN0cnkuanMnO1xuXG5iZWhhdmlvci5jbGljayA9IChldmVudCwgdGFyZ2V0LCBpbnN0YW5jZSk9PntcbiAgICBjb25zdCBjb250ZXh0ID0gdGFyZ2V0LmNsb3Nlc3QoJ2J1dHRvbixpbnB1dCxsYWJlbCxzZWxlY3QsdGV4dGFyZWEnKTtcbiAgICBjb25zdCBjb250cm9sID0gY29udGV4dCAmJiBpc0VsZW1lbnRUeXBlKGNvbnRleHQsICdsYWJlbCcpICYmIGNvbnRleHQuY29udHJvbDtcbiAgICBpZiAoY29udHJvbCkge1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIGlmIChpc0ZvY3VzYWJsZShjb250cm9sKSkge1xuICAgICAgICAgICAgICAgIGZvY3VzRWxlbWVudChjb250cm9sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluc3RhbmNlLmRpc3BhdGNoRXZlbnQoY29udHJvbCwgY2xvbmVFdmVudChldmVudCkpO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoaXNFbGVtZW50VHlwZSh0YXJnZXQsICdpbnB1dCcsIHtcbiAgICAgICAgdHlwZTogJ2ZpbGUnXG4gICAgfSkpIHtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICAvLyBibHVyIGZpcmVzIHdoZW4gdGhlIGZpbGUgc2VsZWN0b3IgcG9wcyB1cFxuICAgICAgICAgICAgYmx1ckVsZW1lbnQodGFyZ2V0KTtcbiAgICAgICAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyAoZ2V0V2luZG93KHRhcmdldCkpLkV2ZW50KCdmaWxlRGlhbG9nJykpO1xuICAgICAgICAgICAgLy8gZm9jdXMgZmlyZXMgYWZ0ZXIgdGhlIGZpbGUgc2VsZWN0b3IgaGFzIGJlZW4gY2xvc2VkXG4gICAgICAgICAgICBmb2N1c0VsZW1lbnQodGFyZ2V0KTtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuIiwiY29uc3QgVUlWYWx1ZSA9IFN5bWJvbCgnRGlzcGxheWVkIHZhbHVlIGluIFVJJyk7XG5jb25zdCBVSVNlbGVjdGlvbiA9IFN5bWJvbCgnRGlzcGxheWVkIHNlbGVjdGlvbiBpbiBVSScpO1xuY29uc3QgSW5pdGlhbFZhbHVlID0gU3ltYm9sKCdJbml0aWFsIHZhbHVlIHRvIGNvbXBhcmUgb24gYmx1cicpO1xuZnVuY3Rpb24gaXNVSVZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgVUlWYWx1ZSBpbiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGlzVUlTZWxlY3Rpb25TdGFydChzdGFydCkge1xuICAgIHJldHVybiAhIXN0YXJ0ICYmIHR5cGVvZiBzdGFydCA9PT0gJ29iamVjdCcgJiYgVUlTZWxlY3Rpb24gaW4gc3RhcnQ7XG59XG5mdW5jdGlvbiBzZXRVSVZhbHVlKGVsZW1lbnQsIHZhbHVlKSB7XG4gICAgaWYgKGVsZW1lbnRbSW5pdGlhbFZhbHVlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVsZW1lbnRbSW5pdGlhbFZhbHVlXSA9IGVsZW1lbnQudmFsdWU7XG4gICAgfVxuICAgIGVsZW1lbnRbVUlWYWx1ZV0gPSB2YWx1ZTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LXdyYXBwZXJzXG4gICAgZWxlbWVudC52YWx1ZSA9IE9iamVjdC5hc3NpZ24obmV3IFN0cmluZyh2YWx1ZSksIHtcbiAgICAgICAgW1VJVmFsdWVdOiB0cnVlXG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRVSVZhbHVlKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudFtVSVZhbHVlXSA9PT0gdW5kZWZpbmVkID8gZWxlbWVudC52YWx1ZSA6IFN0cmluZyhlbGVtZW50W1VJVmFsdWVdKTtcbn1cbi8qKiBGbGFnIHRoZSBJREwgdmFsdWUgYXMgY2xlYW4uIFRoaXMgZG9lcyBub3QgY2hhbmdlIHRoZSB2YWx1ZS4qLyBmdW5jdGlvbiBzZXRVSVZhbHVlQ2xlYW4oZWxlbWVudCkge1xuICAgIGVsZW1lbnRbVUlWYWx1ZV0gPSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBjbGVhckluaXRpYWxWYWx1ZShlbGVtZW50KSB7XG4gICAgZWxlbWVudFtJbml0aWFsVmFsdWVdID0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ2V0SW5pdGlhbFZhbHVlKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudFtJbml0aWFsVmFsdWVdO1xufVxuZnVuY3Rpb24gc2V0VUlTZWxlY3Rpb25SYXcoZWxlbWVudCwgc2VsZWN0aW9uKSB7XG4gICAgZWxlbWVudFtVSVNlbGVjdGlvbl0gPSBzZWxlY3Rpb247XG59XG5mdW5jdGlvbiBzZXRVSVNlbGVjdGlvbihlbGVtZW50LCB7IGZvY3VzT2Zmc2V0OiBmb2N1c09mZnNldFBhcmFtICwgYW5jaG9yT2Zmc2V0OiBhbmNob3JPZmZzZXRQYXJhbSA9IGZvY3VzT2Zmc2V0UGFyYW0gIH0sIG1vZGUgPSAncmVwbGFjZScpIHtcbiAgICBjb25zdCB2YWx1ZUxlbmd0aCA9IGdldFVJVmFsdWUoZWxlbWVudCkubGVuZ3RoO1xuICAgIGNvbnN0IHNhbml0aXplT2Zmc2V0ID0gKG8pPT5NYXRoLm1heCgwLCBNYXRoLm1pbih2YWx1ZUxlbmd0aCwgbykpO1xuICAgIGNvbnN0IGFuY2hvck9mZnNldCA9IG1vZGUgPT09ICdyZXBsYWNlJyB8fCBlbGVtZW50W1VJU2VsZWN0aW9uXSA9PT0gdW5kZWZpbmVkID8gc2FuaXRpemVPZmZzZXQoYW5jaG9yT2Zmc2V0UGFyYW0pIDogZWxlbWVudFtVSVNlbGVjdGlvbl0uYW5jaG9yT2Zmc2V0O1xuICAgIGNvbnN0IGZvY3VzT2Zmc2V0ID0gc2FuaXRpemVPZmZzZXQoZm9jdXNPZmZzZXRQYXJhbSk7XG4gICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBNYXRoLm1pbihhbmNob3JPZmZzZXQsIGZvY3VzT2Zmc2V0KTtcbiAgICBjb25zdCBlbmRPZmZzZXQgPSBNYXRoLm1heChhbmNob3JPZmZzZXQsIGZvY3VzT2Zmc2V0KTtcbiAgICBlbGVtZW50W1VJU2VsZWN0aW9uXSA9IHtcbiAgICAgICAgYW5jaG9yT2Zmc2V0LFxuICAgICAgICBmb2N1c09mZnNldFxuICAgIH07XG4gICAgaWYgKGVsZW1lbnQuc2VsZWN0aW9uU3RhcnQgPT09IHN0YXJ0T2Zmc2V0ICYmIGVsZW1lbnQuc2VsZWN0aW9uRW5kID09PSBlbmRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LXdyYXBwZXJzXG4gICAgY29uc3Qgc3RhcnRPYmogPSBPYmplY3QuYXNzaWduKG5ldyBOdW1iZXIoc3RhcnRPZmZzZXQpLCB7XG4gICAgICAgIFtVSVNlbGVjdGlvbl06IHRydWVcbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgICBlbGVtZW50LnNldFNlbGVjdGlvblJhbmdlKHN0YXJ0T2JqLCBlbmRPZmZzZXQpO1xuICAgIH0gY2F0Y2ggIHtcbiAgICAvLyBET01FeGNlcHRpb24gZm9yIGludmFsaWQgc3RhdGUgaXMgZXhwZWN0ZWQgd2hlbiBjYWxsaW5nIHRoaXNcbiAgICAvLyBvbiBhbiBlbGVtZW50IHdpdGhvdXQgc3VwcG9ydCBmb3Igc2V0U2VsZWN0aW9uUmFuZ2VcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRVSVNlbGVjdGlvbihlbGVtZW50KSB7XG4gICAgdmFyIF9zZWxlY3Rpb25TdGFydCwgX3NlbGVjdGlvbkVuZCwgX1VJU2VsZWN0aW9uO1xuICAgIGNvbnN0IHNlbCA9IChfVUlTZWxlY3Rpb24gPSBlbGVtZW50W1VJU2VsZWN0aW9uXSkgIT09IG51bGwgJiYgX1VJU2VsZWN0aW9uICE9PSB2b2lkIDAgPyBfVUlTZWxlY3Rpb24gOiB7XG4gICAgICAgIGFuY2hvck9mZnNldDogKF9zZWxlY3Rpb25TdGFydCA9IGVsZW1lbnQuc2VsZWN0aW9uU3RhcnQpICE9PSBudWxsICYmIF9zZWxlY3Rpb25TdGFydCAhPT0gdm9pZCAwID8gX3NlbGVjdGlvblN0YXJ0IDogMCxcbiAgICAgICAgZm9jdXNPZmZzZXQ6IChfc2VsZWN0aW9uRW5kID0gZWxlbWVudC5zZWxlY3Rpb25FbmQpICE9PSBudWxsICYmIF9zZWxlY3Rpb25FbmQgIT09IHZvaWQgMCA/IF9zZWxlY3Rpb25FbmQgOiAwXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5zZWwsXG4gICAgICAgIHN0YXJ0T2Zmc2V0OiBNYXRoLm1pbihzZWwuYW5jaG9yT2Zmc2V0LCBzZWwuZm9jdXNPZmZzZXQpLFxuICAgICAgICBlbmRPZmZzZXQ6IE1hdGgubWF4KHNlbC5hbmNob3JPZmZzZXQsIHNlbC5mb2N1c09mZnNldClcbiAgICB9O1xufVxuZnVuY3Rpb24gaGFzVUlTZWxlY3Rpb24oZWxlbWVudCkge1xuICAgIHJldHVybiAhIWVsZW1lbnRbVUlTZWxlY3Rpb25dO1xufVxuLyoqIEZsYWcgdGhlIElETCBzZWxlY3Rpb24gYXMgY2xlYW4uIFRoaXMgZG9lcyBub3QgY2hhbmdlIHRoZSBzZWxlY3Rpb24uICovIGZ1bmN0aW9uIHNldFVJU2VsZWN0aW9uQ2xlYW4oZWxlbWVudCkge1xuICAgIGVsZW1lbnRbVUlTZWxlY3Rpb25dID0gdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgeyBjbGVhckluaXRpYWxWYWx1ZSwgZ2V0SW5pdGlhbFZhbHVlLCBnZXRVSVNlbGVjdGlvbiwgZ2V0VUlWYWx1ZSwgaGFzVUlTZWxlY3Rpb24sIGlzVUlTZWxlY3Rpb25TdGFydCwgaXNVSVZhbHVlLCBzZXRVSVNlbGVjdGlvbiwgc2V0VUlTZWxlY3Rpb25DbGVhbiwgc2V0VUlTZWxlY3Rpb25SYXcsIHNldFVJVmFsdWUsIHNldFVJVmFsdWVDbGVhbiB9O1xuIiwiY29uc3QgcGFyc2VJbnQgPSBnbG9iYWxUaGlzLnBhcnNlSW50O1xuZnVuY3Rpb24gYnVpbGRUaW1lVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBvbmx5RGlnaXRzVmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXEQvZywgJycpO1xuICAgIGlmIChvbmx5RGlnaXRzVmFsdWUubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0RGlnaXQgPSBwYXJzZUludChvbmx5RGlnaXRzVmFsdWVbMF0sIDEwKTtcbiAgICBjb25zdCBzZWNvbmREaWdpdCA9IHBhcnNlSW50KG9ubHlEaWdpdHNWYWx1ZVsxXSwgMTApO1xuICAgIGlmIChmaXJzdERpZ2l0ID49IDMgfHwgZmlyc3REaWdpdCA9PT0gMiAmJiBzZWNvbmREaWdpdCA+PSA0KSB7XG4gICAgICAgIGxldCBpbmRleDtcbiAgICAgICAgaWYgKGZpcnN0RGlnaXQgPj0gMykge1xuICAgICAgICAgICAgaW5kZXggPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5kZXggPSAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWlsZChvbmx5RGlnaXRzVmFsdWUsIGluZGV4KTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBidWlsZChvbmx5RGlnaXRzVmFsdWUsIDIpO1xufVxuZnVuY3Rpb24gYnVpbGQob25seURpZ2l0c1ZhbHVlLCBpbmRleCkge1xuICAgIGNvbnN0IGhvdXJzID0gb25seURpZ2l0c1ZhbHVlLnNsaWNlKDAsIGluZGV4KTtcbiAgICBjb25zdCB2YWxpZEhvdXJzID0gTWF0aC5taW4ocGFyc2VJbnQoaG91cnMsIDEwKSwgMjMpO1xuICAgIGNvbnN0IG1pbnV0ZUNoYXJhY3RlcnMgPSBvbmx5RGlnaXRzVmFsdWUuc2xpY2UoaW5kZXgpO1xuICAgIGNvbnN0IHBhcnNlZE1pbnV0ZXMgPSBwYXJzZUludChtaW51dGVDaGFyYWN0ZXJzLCAxMCk7XG4gICAgY29uc3QgdmFsaWRNaW51dGVzID0gTWF0aC5taW4ocGFyc2VkTWludXRlcywgNTkpO1xuICAgIHJldHVybiBgJHt2YWxpZEhvdXJzLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX06JHt2YWxpZE1pbnV0ZXMudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfWA7XG59XG5mdW5jdGlvbiBpc1ZhbGlkRGF0ZU9yVGltZVZhbHVlKGVsZW1lbnQsIHZhbHVlKSB7XG4gICAgY29uc3QgY2xvbmUgPSBlbGVtZW50LmNsb25lTm9kZSgpO1xuICAgIGNsb25lLnZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIGNsb25lLnZhbHVlID09PSB2YWx1ZTtcbn1cblxuZXhwb3J0IHsgYnVpbGRUaW1lVmFsdWUsIGlzVmFsaWREYXRlT3JUaW1lVmFsdWUgfTtcbiIsImltcG9ydCB7IGlzQ29udGVudEVkaXRhYmxlIH0gZnJvbSAnLi4vZWRpdC9pc0NvbnRlbnRFZGl0YWJsZS5qcyc7XG5pbXBvcnQgeyBpc0VsZW1lbnRUeXBlIH0gZnJvbSAnLi4vbWlzYy9pc0VsZW1lbnRUeXBlLmpzJztcblxuZnVuY3Rpb24gZ2V0TmV4dEN1cnNvclBvc2l0aW9uKG5vZGUsIG9mZnNldCwgZGlyZWN0aW9uLCBpbnB1dFR5cGUpIHtcbiAgICAvLyBUaGUgYmVoYXZpb3IgYXQgdGV4dCBub2RlIHplcm8gb2Zmc2V0IGlzIGluY29uc2lzdGVudC5cbiAgICAvLyBXaGVuIHdhbGtpbmcgYmFja3dhcmRzOlxuICAgIC8vIEZpcmVmb3ggYWx3YXlzIG1vdmVzIHRvIHplcm8gb2Zmc2V0IGFuZCBqdW1wcyBvdmVyIGxhc3Qgb2Zmc2V0LlxuICAgIC8vIENocm9tZSBqdW1wcyBvdmVyIHplcm8gb2Zmc2V0IHBlciBkZWZhdWx0IGJ1dCBvdmVyIGxhc3Qgb2Zmc2V0IHdoZW4gU2hpZnQgaXMgcHJlc3NlZC5cbiAgICAvLyBUaGUgY3Vyc29yIGFsd2F5cyBtb3ZlcyB0byB6ZXJvIG9mZnNldCBpZiB0aGUgZm9jdXMgYXJlYSAoY29udGVudGVkaXRhYmxlIG9yIGJvZHkpIGVuZHMgdGhlcmUuXG4gICAgLy8gV2hlbiB3YWxraW5nIGZvd2FyZCBib3RoIGlnbm9yZSB6ZXJvIG9mZnNldC5cbiAgICAvLyBXaGVuIHdhbGtpbmcgb3ZlciBpbnB1dCBlbGVtZW50cyB0aGUgY3Vyc29yIG1vdmVzIGJlZm9yZSBvciBhZnRlciB0aGF0IGVsZW1lbnQuXG4gICAgLy8gV2hlbiB3YWxraW5nIG92ZXIgbGluZSBicmVha3MgdGhlIGN1cnNvciBtb3ZlcyBpbnNpZGUgYW55IGZvbGxvd2luZyB0ZXh0IG5vZGUuXG4gICAgaWYgKGlzVGV4dE5vZGUobm9kZSkgJiYgb2Zmc2V0ICsgZGlyZWN0aW9uID49IDAgJiYgb2Zmc2V0ICsgZGlyZWN0aW9uIDw9IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0ICsgZGlyZWN0aW9uXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IG5leHROb2RlID0gZ2V0TmV4dENoYXJhY3RlckNvbnRlbnROb2RlKG5vZGUsIG9mZnNldCwgZGlyZWN0aW9uKTtcbiAgICBpZiAobmV4dE5vZGUpIHtcbiAgICAgICAgaWYgKGlzVGV4dE5vZGUobmV4dE5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5vZGU6IG5leHROb2RlLFxuICAgICAgICAgICAgICAgIG9mZnNldDogZGlyZWN0aW9uID4gMCA/IE1hdGgubWluKDEsIG5leHROb2RlLm5vZGVWYWx1ZS5sZW5ndGgpIDogTWF0aC5tYXgobmV4dE5vZGUubm9kZVZhbHVlLmxlbmd0aCAtIDEsIDApXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGlzRWxlbWVudFR5cGUobmV4dE5vZGUsICdicicpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0UGx1c09uZSA9IGdldE5leHRDaGFyYWN0ZXJDb250ZW50Tm9kZShuZXh0Tm9kZSwgdW5kZWZpbmVkLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgaWYgKCFuZXh0UGx1c09uZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBiZWhhdmlvciB3aGVuIHRoZXJlIGlzIG5vIHBvc3NpYmxlIGN1cnNvciBwb3NpdGlvbiBiZXlvbmQgdGhlIGxpbmUgYnJlYWsgaXMgaW5jb25zaXN0ZW50LlxuICAgICAgICAgICAgICAgIC8vIEluIENocm9tZSBvdXRzaWRlIG9mIGNvbnRlbnRlZGl0YWJsZSBtb3ZpbmcgYmVmb3JlIGEgbGVhZGluZyBsaW5lIGJyZWFrIGlzIHBvc3NpYmxlLlxuICAgICAgICAgICAgICAgIC8vIEEgbGVhZGluZyBsaW5lIGJyZWFrIGNhbiBzdGlsbCBiZSByZW1vdmVkIHBlciBkZWxldGVDb250ZW50QmFja3dhcmQuXG4gICAgICAgICAgICAgICAgLy8gQSB0cmFpbGluZyBsaW5lIGJyZWFrIG9uIHRoZSBvdGhlciBoYW5kIGlzIG5vdCByZW1vdmVkIGJ5IGRlbGV0ZUNvbnRlbnRGb3J3YXJkLlxuICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPCAwICYmIGlucHV0VHlwZSA9PT0gJ2RlbGV0ZUNvbnRlbnRCYWNrd2FyZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IG5leHROb2RlLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IGdldE9mZnNldChuZXh0Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShuZXh0UGx1c09uZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBub2RlOiBuZXh0UGx1c09uZSxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBkaXJlY3Rpb24gPiAwID8gMCA6IG5leHRQbHVzT25lLm5vZGVWYWx1ZS5sZW5ndGhcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPCAwICYmIGlzRWxlbWVudFR5cGUobmV4dFBsdXNPbmUsICdicicpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogbmV4dE5vZGUucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBnZXRPZmZzZXQobmV4dE5vZGUpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogbmV4dFBsdXNPbmUucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBnZXRPZmZzZXQobmV4dFBsdXNPbmUpICsgKGRpcmVjdGlvbiA+IDAgPyAwIDogMSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBub2RlOiBuZXh0Tm9kZS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgIG9mZnNldDogZ2V0T2Zmc2V0KG5leHROb2RlKSArIChkaXJlY3Rpb24gPiAwID8gMSA6IDApXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0TmV4dENoYXJhY3RlckNvbnRlbnROb2RlKG5vZGUsIG9mZnNldCwgZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgbmV4dE9mZnNldCA9IE51bWJlcihvZmZzZXQpICsgKGRpcmVjdGlvbiA8IDAgPyAtMSA6IDApO1xuICAgIGlmIChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBpc0VsZW1lbnQobm9kZSkgJiYgbmV4dE9mZnNldCA+PSAwICYmIG5leHRPZmZzZXQgPCBub2RlLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZHJlbltuZXh0T2Zmc2V0XTtcbiAgICB9XG4gICAgcmV0dXJuIHdhbGtOb2Rlcyhub2RlLCBkaXJlY3Rpb24gPT09IDEgPyAnbmV4dCcgOiAncHJldmlvdXMnLCBpc1RyZWF0ZWRBc0NoYXJhY3RlckNvbnRlbnQpO1xufVxuZnVuY3Rpb24gaXNUcmVhdGVkQXNDaGFyYWN0ZXJDb250ZW50KG5vZGUpIHtcbiAgICBpZiAoaXNUZXh0Tm9kZShub2RlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzRWxlbWVudChub2RlKSkge1xuICAgICAgICBpZiAoaXNFbGVtZW50VHlwZShub2RlLCBbXG4gICAgICAgICAgICAnaW5wdXQnLFxuICAgICAgICAgICAgJ3RleHRhcmVhJ1xuICAgICAgICBdKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUudHlwZSAhPT0gJ2hpZGRlbic7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNFbGVtZW50VHlwZShub2RlLCAnYnInKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0T2Zmc2V0KG5vZGUpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUobm9kZS5wcmV2aW91c1NpYmxpbmcpe1xuICAgICAgICBpKys7XG4gICAgICAgIG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAxO1xufVxuZnVuY3Rpb24gaXNUZXh0Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IDM7XG59XG5mdW5jdGlvbiB3YWxrTm9kZXMobm9kZSwgZGlyZWN0aW9uLCBjYWxsYmFjaykge1xuICAgIGZvcig7Oyl7XG4gICAgICAgIHZhciByZWY7XG4gICAgICAgIGNvbnN0IHNpYmxpbmcgPSBub2RlW2Ake2RpcmVjdGlvbn1TaWJsaW5nYF07XG4gICAgICAgIGlmIChzaWJsaW5nKSB7XG4gICAgICAgICAgICBub2RlID0gZ2V0RGVzY2VuZGFudChzaWJsaW5nLCBkaXJlY3Rpb24gPT09ICduZXh0JyA/ICdmaXJzdCcgOiAnbGFzdCcpO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlICYmICghaXNFbGVtZW50KG5vZGUucGFyZW50Tm9kZSkgfHwgIWlzQ29udGVudEVkaXRhYmxlKG5vZGUucGFyZW50Tm9kZSkgJiYgbm9kZS5wYXJlbnROb2RlICE9PSAoKHJlZiA9IG5vZGUub3duZXJEb2N1bWVudCkgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYuYm9keSkpKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXREZXNjZW5kYW50KG5vZGUsIGRpcmVjdGlvbikge1xuICAgIHdoaWxlKG5vZGUuaGFzQ2hpbGROb2RlcygpKXtcbiAgICAgICAgbm9kZSA9IG5vZGVbYCR7ZGlyZWN0aW9ufUNoaWxkYF07XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuXG5leHBvcnQgeyBnZXROZXh0Q3Vyc29yUG9zaXRpb24gfTtcbiIsImltcG9ydCAnLi4vdXRpbHMvY2xpY2svaXNDbGlja2FibGVJbnB1dC5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2RhdGFUcmFuc2Zlci9DbGlwYm9hcmQuanMnO1xuaW1wb3J0ICcuLi91dGlscy9lZGl0L2lzRWRpdGFibGUuanMnO1xuaW1wb3J0ICcuLi91dGlscy9lZGl0L21heExlbmd0aC5qcyc7XG5pbXBvcnQgeyBnZXRXaW5kb3cgfSBmcm9tICcuLi91dGlscy9taXNjL2dldFdpbmRvdy5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2tleURlZi9yZWFkTmV4dERlc2NyaXB0b3IuanMnO1xuaW1wb3J0ICcuLi91dGlscy9taXNjL2xldmVsLmpzJztcbmltcG9ydCAnLi4vb3B0aW9ucy5qcyc7XG5pbXBvcnQgeyBzZXRVSVZhbHVlQ2xlYW4sIHNldFVJU2VsZWN0aW9uLCBoYXNVSVNlbGVjdGlvbiB9IGZyb20gJy4vVUkuanMnO1xuXG5jb25zdCBUcmFja0NoYW5nZXMgPSBTeW1ib2woJ1RyYWNrIHByb2dyYW1tYXRpYyBjaGFuZ2VzIGZvciBSZWFjdCB3b3JrYXJvdW5kJyk7XG4vLyBXaGVuIHRoZSBpbnB1dCBldmVudCBoYXBwZW5zIGluIHRoZSBicm93c2VyLCBSZWFjdCBleGVjdXRlcyBhbGwgZXZlbnQgaGFuZGxlcnNcbi8vIGFuZCBpZiB0aGV5IGNoYW5nZSBzdGF0ZSBvZiBhIGNvbnRyb2xsZWQgdmFsdWUsIG5vdGhpbmcgaGFwcGVucy5cbi8vIEJ1dCB3aGVuIHdlIHRyaWdnZXIgdGhlIGV2ZW50IGhhbmRsZXJzIGluIHRlc3QgZW52aXJvbm1lbnQgd2l0aCBSZWFjdEAxNyxcbi8vIHRoZSBjaGFuZ2VzIGFyZSByb2xsZWQgYmFjayBiZWZvcmUgdGhlIHN0YXRlIHVwZGF0ZSBpcyBhcHBsaWVkLlxuLy8gVGhpcyByZXN1bHRzIGluIGEgcmVzZXQgY3Vyc29yLlxuLy8gVGhlcmUgbWlnaHQgYmUgYSBiZXR0ZXIgd2F5IHRvIHdvcmsgYXJvdW5kIGlmIHdlIGZpZ3VyZSBvdXRcbi8vIHdoeSB0aGUgYmF0Y2hlZCB1cGRhdGUgaXMgZXhlY3V0ZWQgZGlmZmVyZW50bHkgaW4gb3VyIHRlc3QgZW52aXJvbm1lbnQuXG5mdW5jdGlvbiBpc1JlYWN0MTdFbGVtZW50KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZWxlbWVudCkuc29tZSgoayk9Pmsuc3RhcnRzV2l0aCgnX19yZWFjdCcpKSAmJiBnZXRXaW5kb3coZWxlbWVudCkuUkVBQ1RfVkVSU0lPTiA9PT0gMTc7XG59XG5mdW5jdGlvbiBzdGFydFRyYWNrVmFsdWUoZWxlbWVudCkge1xuICAgIGlmICghaXNSZWFjdDE3RWxlbWVudChlbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsZW1lbnRbVHJhY2tDaGFuZ2VzXSA9IHtcbiAgICAgICAgcHJldmlvdXNWYWx1ZTogU3RyaW5nKGVsZW1lbnQudmFsdWUpLFxuICAgICAgICB0cmFja2VkOiBbXVxuICAgIH07XG59XG5mdW5jdGlvbiB0cmFja09yU2V0VmFsdWUoZWxlbWVudCwgdikge1xuICAgIHZhciByZWYsIHJlZjE7XG4gICAgKHJlZiA9IGVsZW1lbnRbVHJhY2tDaGFuZ2VzXSkgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiAocmVmMSA9IHJlZi50cmFja2VkKSA9PT0gbnVsbCB8fCByZWYxID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYxLnB1c2godik7XG4gICAgaWYgKCFlbGVtZW50W1RyYWNrQ2hhbmdlc10pIHtcbiAgICAgICAgc2V0VUlWYWx1ZUNsZWFuKGVsZW1lbnQpO1xuICAgICAgICBzZXRVSVNlbGVjdGlvbihlbGVtZW50LCB7XG4gICAgICAgICAgICBmb2N1c09mZnNldDogdi5sZW5ndGhcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29tbWl0VmFsdWVBZnRlcklucHV0KGVsZW1lbnQsIGN1cnNvck9mZnNldCkge1xuICAgIHZhciByZWY7XG4gICAgY29uc3QgY2hhbmdlcyA9IGVsZW1lbnRbVHJhY2tDaGFuZ2VzXTtcbiAgICBlbGVtZW50W1RyYWNrQ2hhbmdlc10gPSB1bmRlZmluZWQ7XG4gICAgaWYgKCEoY2hhbmdlcyA9PT0gbnVsbCB8fCBjaGFuZ2VzID09PSB2b2lkIDAgPyB2b2lkIDAgOiAocmVmID0gY2hhbmdlcy50cmFja2VkKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXNKdXN0UmVhY3RTdGF0ZVVwZGF0ZSA9IGNoYW5nZXMudHJhY2tlZC5sZW5ndGggPT09IDIgJiYgY2hhbmdlcy50cmFja2VkWzBdID09PSBjaGFuZ2VzLnByZXZpb3VzVmFsdWUgJiYgY2hhbmdlcy50cmFja2VkWzFdID09PSBlbGVtZW50LnZhbHVlO1xuICAgIGlmICghaXNKdXN0UmVhY3RTdGF0ZVVwZGF0ZSkge1xuICAgICAgICBzZXRVSVZhbHVlQ2xlYW4oZWxlbWVudCk7XG4gICAgfVxuICAgIGlmIChoYXNVSVNlbGVjdGlvbihlbGVtZW50KSkge1xuICAgICAgICBzZXRVSVNlbGVjdGlvbihlbGVtZW50LCB7XG4gICAgICAgICAgICBmb2N1c09mZnNldDogaXNKdXN0UmVhY3RTdGF0ZVVwZGF0ZSA/IGN1cnNvck9mZnNldCA6IGVsZW1lbnQudmFsdWUubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgY29tbWl0VmFsdWVBZnRlcklucHV0LCBzdGFydFRyYWNrVmFsdWUsIHRyYWNrT3JTZXRWYWx1ZSB9O1xuIiwiaW1wb3J0IHsgZ2V0VUlTZWxlY3Rpb24gfSBmcm9tICcuLi8uLi9kb2N1bWVudC9VSS5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2NsaWNrL2lzQ2xpY2thYmxlSW5wdXQuanMnO1xuaW1wb3J0ICcuLi8uLi91dGlscy9kYXRhVHJhbnNmZXIvQ2xpcGJvYXJkLmpzJztcbmltcG9ydCB7IGdldENvbnRlbnRFZGl0YWJsZSB9IGZyb20gJy4uLy4uL3V0aWxzL2VkaXQvaXNDb250ZW50RWRpdGFibGUuanMnO1xuaW1wb3J0ICcuLi8uLi91dGlscy9lZGl0L2lzRWRpdGFibGUuanMnO1xuaW1wb3J0ICcuLi8uLi91dGlscy9lZGl0L21heExlbmd0aC5qcyc7XG5pbXBvcnQgJ0B0ZXN0aW5nLWxpYnJhcnkvZG9tL2Rpc3QvaGVscGVycy5qcyc7XG5pbXBvcnQgeyBoYXNPd25TZWxlY3Rpb24gfSBmcm9tICcuLi8uLi91dGlscy9mb2N1cy9zZWxlY3Rpb24uanMnO1xuaW1wb3J0ICcuLi8uLi91dGlscy9rZXlEZWYvcmVhZE5leHREZXNjcmlwdG9yLmpzJztcbmltcG9ydCAnLi4vLi4vdXRpbHMvbWlzYy9sZXZlbC5qcyc7XG5pbXBvcnQgJy4uLy4uL29wdGlvbnMuanMnO1xuXG4vKipcbiAqIERldGVybWluZSB3aGljaCBzZWxlY3Rpb24gbG9naWMgYW5kIHNlbGVjdGlvbiByYW5nZXMgdG8gY29uc2lkZXIuXG4gKi8gZnVuY3Rpb24gZ2V0VGFyZ2V0VHlwZUFuZFNlbGVjdGlvbihub2RlKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQobm9kZSk7XG4gICAgaWYgKGVsZW1lbnQgJiYgaGFzT3duU2VsZWN0aW9uKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnaW5wdXQnLFxuICAgICAgICAgICAgc2VsZWN0aW9uOiBnZXRVSVNlbGVjdGlvbihlbGVtZW50KVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSBlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsZW1lbnQub3duZXJEb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICAvLyBJdCBpcyBwb3NzaWJsZSB0byBleHRlbmQgYSBzaW5nbGUtcmFuZ2Ugc2VsZWN0aW9uIGludG8gYSBjb250ZW50ZWRpdGFibGUuXG4gICAgLy8gVGhpcyByZXN1bHRzIGluIHRoZSByYW5nZSBhY3RpbmcgbGlrZSBhIHJhbmdlIG91dHNpZGUgb2YgY29udGVudGVkaXRhYmxlLlxuICAgIGNvbnN0IGlzQ0UgPSBnZXRDb250ZW50RWRpdGFibGUobm9kZSkgJiYgKHNlbGVjdGlvbiA9PT0gbnVsbCB8fCBzZWxlY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbGVjdGlvbi5hbmNob3JOb2RlKSAmJiBnZXRDb250ZW50RWRpdGFibGUoc2VsZWN0aW9uLmFuY2hvck5vZGUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGlzQ0UgPyAnY29udGVudGVkaXRhYmxlJyA6ICdkZWZhdWx0JyxcbiAgICAgICAgc2VsZWN0aW9uXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnQobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAxID8gbm9kZSA6IG5vZGUucGFyZW50RWxlbWVudDtcbn1cblxuZXhwb3J0IHsgZ2V0VGFyZ2V0VHlwZUFuZFNlbGVjdGlvbiB9O1xuIiwiaW1wb3J0IHsgZ2V0VGFyZ2V0VHlwZUFuZFNlbGVjdGlvbiB9IGZyb20gJy4vZ2V0VGFyZ2V0VHlwZUFuZFNlbGVjdGlvbi5qcyc7XG5cbi8qKlxuICogR2V0IHRoZSByYW5nZSB0aGF0IHdvdWxkIGJlIG92ZXJ3cml0dGVuIGJ5IGlucHV0LlxuICovIGZ1bmN0aW9uIGdldElucHV0UmFuZ2UoZm9jdXNOb2RlKSB7XG4gICAgY29uc3QgdHlwZUFuZFNlbGVjdGlvbiA9IGdldFRhcmdldFR5cGVBbmRTZWxlY3Rpb24oZm9jdXNOb2RlKTtcbiAgICBpZiAodHlwZUFuZFNlbGVjdGlvbi50eXBlID09PSAnaW5wdXQnKSB7XG4gICAgICAgIHJldHVybiB0eXBlQW5kU2VsZWN0aW9uLnNlbGVjdGlvbjtcbiAgICB9IGVsc2UgaWYgKHR5cGVBbmRTZWxlY3Rpb24udHlwZSA9PT0gJ2NvbnRlbnRlZGl0YWJsZScpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgLy8gTXVsdGktcmFuZ2Ugb24gY29udGVudGVkaXRhYmxlIGVkaXRzIHRoZSBmaXJzdCBzZWxlY3Rpb24gaW5zdGVhZCBvZiB0aGUgbGFzdFxuICAgICAgICByZXR1cm4gKHJlZiA9IHR5cGVBbmRTZWxlY3Rpb24uc2VsZWN0aW9uKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5nZXRSYW5nZUF0KDApO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgZ2V0SW5wdXRSYW5nZSB9O1xuIiwiaW1wb3J0IHsgc2V0VUlTZWxlY3Rpb24gfSBmcm9tICcuLi8uLi9kb2N1bWVudC9VSS5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2NsaWNrL2lzQ2xpY2thYmxlSW5wdXQuanMnO1xuaW1wb3J0ICcuLi8uLi91dGlscy9kYXRhVHJhbnNmZXIvQ2xpcGJvYXJkLmpzJztcbmltcG9ydCAnLi4vLi4vdXRpbHMvZWRpdC9pc0VkaXRhYmxlLmpzJztcbmltcG9ydCAnLi4vLi4vdXRpbHMvZWRpdC9tYXhMZW5ndGguanMnO1xuaW1wb3J0ICdAdGVzdGluZy1saWJyYXJ5L2RvbS9kaXN0L2hlbHBlcnMuanMnO1xuaW1wb3J0ICcuLi8uLi91dGlscy9rZXlEZWYvcmVhZE5leHREZXNjcmlwdG9yLmpzJztcbmltcG9ydCAnLi4vLi4vdXRpbHMvbWlzYy9sZXZlbC5qcyc7XG5pbXBvcnQgJy4uLy4uL29wdGlvbnMuanMnO1xuaW1wb3J0IHsgZ2V0VGFyZ2V0VHlwZUFuZFNlbGVjdGlvbiB9IGZyb20gJy4vZ2V0VGFyZ2V0VHlwZUFuZFNlbGVjdGlvbi5qcyc7XG5cbi8qKlxuICogU2V0IHRoZSBzZWxlY3Rpb25cbiAqLyBmdW5jdGlvbiBzZXRTZWxlY3Rpb24oeyBmb2N1c05vZGUgLCBmb2N1c09mZnNldCAsIGFuY2hvck5vZGUgPWZvY3VzTm9kZSAsIGFuY2hvck9mZnNldCA9Zm9jdXNPZmZzZXQgIH0pIHtcbiAgICB2YXIgcmVmLCByZWYxO1xuICAgIGNvbnN0IHR5cGVBbmRTZWxlY3Rpb24gPSBnZXRUYXJnZXRUeXBlQW5kU2VsZWN0aW9uKGZvY3VzTm9kZSk7XG4gICAgaWYgKHR5cGVBbmRTZWxlY3Rpb24udHlwZSA9PT0gJ2lucHV0Jykge1xuICAgICAgICByZXR1cm4gc2V0VUlTZWxlY3Rpb24oZm9jdXNOb2RlLCB7XG4gICAgICAgICAgICBhbmNob3JPZmZzZXQsXG4gICAgICAgICAgICBmb2N1c09mZnNldFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgKHJlZjEgPSAocmVmID0gYW5jaG9yTm9kZS5vd25lckRvY3VtZW50KSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5nZXRTZWxlY3Rpb24oKSkgPT09IG51bGwgfHwgcmVmMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmMS5zZXRCYXNlQW5kRXh0ZW50KGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCk7XG59XG5cbmV4cG9ydCB7IHNldFNlbGVjdGlvbiB9O1xuIiwiaW1wb3J0IHsgc2V0VUlWYWx1ZSwgY2xlYXJJbml0aWFsVmFsdWUsIGdldFVJVmFsdWUgfSBmcm9tICcuLi9kb2N1bWVudC9VSS5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2NsaWNrL2lzQ2xpY2thYmxlSW5wdXQuanMnO1xuaW1wb3J0ICcuLi91dGlscy9kYXRhVHJhbnNmZXIvQ2xpcGJvYXJkLmpzJztcbmltcG9ydCB7IGlzVmFsaWREYXRlT3JUaW1lVmFsdWUsIGJ1aWxkVGltZVZhbHVlIH0gZnJvbSAnLi4vdXRpbHMvZWRpdC90aW1lVmFsdWUuanMnO1xuaW1wb3J0ICcuLi91dGlscy9lZGl0L2lzRWRpdGFibGUuanMnO1xuaW1wb3J0IHsgc3VwcG9ydHNNYXhMZW5ndGgsIGdldE1heExlbmd0aCB9IGZyb20gJy4uL3V0aWxzL2VkaXQvbWF4TGVuZ3RoLmpzJztcbmltcG9ydCB7IGdldE5leHRDdXJzb3JQb3NpdGlvbiB9IGZyb20gJy4uL3V0aWxzL2ZvY3VzL2N1cnNvci5qcyc7XG5pbXBvcnQgeyBpc0VsZW1lbnRUeXBlIH0gZnJvbSAnLi4vdXRpbHMvbWlzYy9pc0VsZW1lbnRUeXBlLmpzJztcbmltcG9ydCAnQHRlc3RpbmctbGlicmFyeS9kb20vZGlzdC9oZWxwZXJzLmpzJztcbmltcG9ydCAnLi4vdXRpbHMva2V5RGVmL3JlYWROZXh0RGVzY3JpcHRvci5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL21pc2MvbGV2ZWwuanMnO1xuaW1wb3J0ICcuLi9vcHRpb25zLmpzJztcbmltcG9ydCB7IGNvbW1pdFZhbHVlQWZ0ZXJJbnB1dCB9IGZyb20gJy4uL2RvY3VtZW50L3RyYWNrVmFsdWUuanMnO1xuaW1wb3J0IHsgZ2V0SW5wdXRSYW5nZSB9IGZyb20gJy4vc2VsZWN0aW9uL2dldElucHV0UmFuZ2UuanMnO1xuaW1wb3J0IHsgc2V0U2VsZWN0aW9uIH0gZnJvbSAnLi9zZWxlY3Rpb24vc2V0U2VsZWN0aW9uLmpzJztcblxuZnVuY3Rpb24gaXNEYXRlT3JUaW1lKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gaXNFbGVtZW50VHlwZShlbGVtZW50LCAnaW5wdXQnKSAmJiBbXG4gICAgICAgICdkYXRlJyxcbiAgICAgICAgJ3RpbWUnXG4gICAgXS5pbmNsdWRlcyhlbGVtZW50LnR5cGUpO1xufVxuZnVuY3Rpb24gaW5wdXQoaW5zdGFuY2UsIGVsZW1lbnQsIGRhdGEsIGlucHV0VHlwZSA9ICdpbnNlcnRUZXh0Jykge1xuICAgIGNvbnN0IGlucHV0UmFuZ2UgPSBnZXRJbnB1dFJhbmdlKGVsZW1lbnQpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqLyBpZiAoIWlucHV0UmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBUaGVyZSBpcyBubyBgYmVmb3JlaW5wdXRgIGV2ZW50IG9uIGBkYXRlYCBhbmQgYHRpbWVgIGlucHV0XG4gICAgaWYgKCFpc0RhdGVPclRpbWUoZWxlbWVudCkpIHtcbiAgICAgICAgY29uc3QgdW5wcmV2ZW50ZWQgPSBpbnN0YW5jZS5kaXNwYXRjaFVJRXZlbnQoZWxlbWVudCwgJ2JlZm9yZWlucHV0Jywge1xuICAgICAgICAgICAgaW5wdXRUeXBlLFxuICAgICAgICAgICAgZGF0YVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF1bnByZXZlbnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgnc3RhcnRDb250YWluZXInIGluIGlucHV0UmFuZ2UpIHtcbiAgICAgICAgZWRpdENvbnRlbnRlZGl0YWJsZShpbnN0YW5jZSwgZWxlbWVudCwgaW5wdXRSYW5nZSwgZGF0YSwgaW5wdXRUeXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBlZGl0SW5wdXRFbGVtZW50KGluc3RhbmNlLCBlbGVtZW50LCBpbnB1dFJhbmdlLCBkYXRhLCBpbnB1dFR5cGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVkaXRDb250ZW50ZWRpdGFibGUoaW5zdGFuY2UsIGVsZW1lbnQsIGlucHV0UmFuZ2UsIGRhdGEsIGlucHV0VHlwZSkge1xuICAgIGxldCBkZWwgPSBmYWxzZTtcbiAgICBpZiAoIWlucHV0UmFuZ2UuY29sbGFwc2VkKSB7XG4gICAgICAgIGRlbCA9IHRydWU7XG4gICAgICAgIGlucHV0UmFuZ2UuZGVsZXRlQ29udGVudHMoKTtcbiAgICB9IGVsc2UgaWYgKFtcbiAgICAgICAgJ2RlbGV0ZUNvbnRlbnRCYWNrd2FyZCcsXG4gICAgICAgICdkZWxldGVDb250ZW50Rm9yd2FyZCdcbiAgICBdLmluY2x1ZGVzKGlucHV0VHlwZSkpIHtcbiAgICAgICAgY29uc3QgbmV4dFBvc2l0aW9uID0gZ2V0TmV4dEN1cnNvclBvc2l0aW9uKGlucHV0UmFuZ2Uuc3RhcnRDb250YWluZXIsIGlucHV0UmFuZ2Uuc3RhcnRPZmZzZXQsIGlucHV0VHlwZSA9PT0gJ2RlbGV0ZUNvbnRlbnRCYWNrd2FyZCcgPyAtMSA6IDEsIGlucHV0VHlwZSk7XG4gICAgICAgIGlmIChuZXh0UG9zaXRpb24pIHtcbiAgICAgICAgICAgIGRlbCA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBkZWxSYW5nZSA9IGlucHV0UmFuZ2UuY2xvbmVSYW5nZSgpO1xuICAgICAgICAgICAgaWYgKGRlbFJhbmdlLmNvbXBhcmVQb2ludChuZXh0UG9zaXRpb24ubm9kZSwgbmV4dFBvc2l0aW9uLm9mZnNldCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgZGVsUmFuZ2Uuc2V0U3RhcnQobmV4dFBvc2l0aW9uLm5vZGUsIG5leHRQb3NpdGlvbi5vZmZzZXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxSYW5nZS5zZXRFbmQobmV4dFBvc2l0aW9uLm5vZGUsIG5leHRQb3NpdGlvbi5vZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsUmFuZ2UuZGVsZXRlQ29udGVudHMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGF0YSkge1xuICAgICAgICBpZiAoaW5wdXRSYW5nZS5lbmRDb250YWluZXIubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGlucHV0UmFuZ2UuZW5kT2Zmc2V0O1xuICAgICAgICAgICAgaW5wdXRSYW5nZS5lbmRDb250YWluZXIuaW5zZXJ0RGF0YShvZmZzZXQsIGRhdGEpO1xuICAgICAgICAgICAgaW5wdXRSYW5nZS5zZXRTdGFydChpbnB1dFJhbmdlLmVuZENvbnRhaW5lciwgb2Zmc2V0ICsgZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgaW5wdXRSYW5nZS5zZXRFbmQoaW5wdXRSYW5nZS5lbmRDb250YWluZXIsIG9mZnNldCArIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGF0YSk7XG4gICAgICAgICAgICBpbnB1dFJhbmdlLmluc2VydE5vZGUodGV4dCk7XG4gICAgICAgICAgICBpbnB1dFJhbmdlLnNldFN0YXJ0KHRleHQsIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIGlucHV0UmFuZ2Uuc2V0RW5kKHRleHQsIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVsIHx8IGRhdGEpIHtcbiAgICAgICAgaW5zdGFuY2UuZGlzcGF0Y2hVSUV2ZW50KGVsZW1lbnQsICdpbnB1dCcsIHtcbiAgICAgICAgICAgIGlucHV0VHlwZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBlZGl0SW5wdXRFbGVtZW50KGluc3RhbmNlLCBlbGVtZW50LCBpbnB1dFJhbmdlLCBkYXRhLCBpbnB1dFR5cGUpIHtcbiAgICBsZXQgZGF0YVRvSW5zZXJ0ID0gZGF0YTtcbiAgICBpZiAoc3VwcG9ydHNNYXhMZW5ndGgoZWxlbWVudCkpIHtcbiAgICAgICAgY29uc3QgbWF4TGVuZ3RoID0gZ2V0TWF4TGVuZ3RoKGVsZW1lbnQpO1xuICAgICAgICBpZiAobWF4TGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBzcGFjZVVudGlsTWF4TGVuZ3RoID0gbWF4TGVuZ3RoIC0gZWxlbWVudC52YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoc3BhY2VVbnRpbE1heExlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBkYXRhVG9JbnNlcnQgPSBkYXRhLnN1YnN0cmluZygwLCBzcGFjZVVudGlsTWF4TGVuZ3RoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHsgbmV3VmFsdWUgLCBuZXdPZmZzZXQgLCBvbGRWYWx1ZSAgfSA9IGNhbGN1bGF0ZU5ld1ZhbHVlKGRhdGFUb0luc2VydCwgZWxlbWVudCwgaW5wdXRSYW5nZSwgaW5wdXRUeXBlKTtcbiAgICBpZiAobmV3VmFsdWUgPT09IG9sZFZhbHVlICYmIG5ld09mZnNldCA9PT0gaW5wdXRSYW5nZS5zdGFydE9mZnNldCAmJiBuZXdPZmZzZXQgPT09IGlucHV0UmFuZ2UuZW5kT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzRWxlbWVudFR5cGUoZWxlbWVudCwgJ2lucHV0Jywge1xuICAgICAgICB0eXBlOiAnbnVtYmVyJ1xuICAgIH0pICYmICFpc1ZhbGlkTnVtYmVySW5wdXQobmV3VmFsdWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0VUlWYWx1ZShlbGVtZW50LCBuZXdWYWx1ZSk7XG4gICAgc2V0U2VsZWN0aW9uKHtcbiAgICAgICAgZm9jdXNOb2RlOiBlbGVtZW50LFxuICAgICAgICBhbmNob3JPZmZzZXQ6IG5ld09mZnNldCxcbiAgICAgICAgZm9jdXNPZmZzZXQ6IG5ld09mZnNldFxuICAgIH0pO1xuICAgIGlmIChpc0RhdGVPclRpbWUoZWxlbWVudCkpIHtcbiAgICAgICAgaWYgKGlzVmFsaWREYXRlT3JUaW1lVmFsdWUoZWxlbWVudCwgbmV3VmFsdWUpKSB7XG4gICAgICAgICAgICBjb21taXRJbnB1dChpbnN0YW5jZSwgZWxlbWVudCwgbmV3T2Zmc2V0LCB7fSk7XG4gICAgICAgICAgICBpbnN0YW5jZS5kaXNwYXRjaFVJRXZlbnQoZWxlbWVudCwgJ2NoYW5nZScpO1xuICAgICAgICAgICAgY2xlYXJJbml0aWFsVmFsdWUoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBjb21taXRJbnB1dChpbnN0YW5jZSwgZWxlbWVudCwgbmV3T2Zmc2V0LCB7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgaW5wdXRUeXBlXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZU5ld1ZhbHVlKGlucHV0RGF0YSwgbm9kZSwgeyBzdGFydE9mZnNldCAsIGVuZE9mZnNldCAgfSwgaW5wdXRUeXBlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRVSVZhbHVlKG5vZGUpO1xuICAgIGNvbnN0IHByb2xvZ0VuZCA9IE1hdGgubWF4KDAsIHN0YXJ0T2Zmc2V0ID09PSBlbmRPZmZzZXQgJiYgaW5wdXRUeXBlID09PSAnZGVsZXRlQ29udGVudEJhY2t3YXJkJyA/IHN0YXJ0T2Zmc2V0IC0gMSA6IHN0YXJ0T2Zmc2V0KTtcbiAgICBjb25zdCBwcm9sb2cgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgcHJvbG9nRW5kKTtcbiAgICBjb25zdCBlcGlsb2dTdGFydCA9IE1hdGgubWluKHZhbHVlLmxlbmd0aCwgc3RhcnRPZmZzZXQgPT09IGVuZE9mZnNldCAmJiBpbnB1dFR5cGUgPT09ICdkZWxldGVDb250ZW50Rm9yd2FyZCcgPyBzdGFydE9mZnNldCArIDEgOiBlbmRPZmZzZXQpO1xuICAgIGNvbnN0IGVwaWxvZyA9IHZhbHVlLnN1YnN0cmluZyhlcGlsb2dTdGFydCwgdmFsdWUubGVuZ3RoKTtcbiAgICBsZXQgbmV3VmFsdWUgPSBgJHtwcm9sb2d9JHtpbnB1dERhdGF9JHtlcGlsb2d9YDtcbiAgICBsZXQgbmV3T2Zmc2V0ID0gcHJvbG9nRW5kICsgaW5wdXREYXRhLmxlbmd0aDtcbiAgICBpZiAoaXNFbGVtZW50VHlwZShub2RlLCAnaW5wdXQnLCB7XG4gICAgICAgIHR5cGU6ICd0aW1lJ1xuICAgIH0pKSB7XG4gICAgICAgIGNvbnN0IGJ1aWx0VmFsdWUgPSBidWlsZFRpbWVWYWx1ZShuZXdWYWx1ZSk7XG4gICAgICAgIGlmIChidWlsdFZhbHVlICE9PSAnJyAmJiBpc1ZhbGlkRGF0ZU9yVGltZVZhbHVlKG5vZGUsIGJ1aWx0VmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGJ1aWx0VmFsdWU7XG4gICAgICAgICAgICBuZXdPZmZzZXQgPSBidWlsdFZhbHVlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBvbGRWYWx1ZTogdmFsdWUsXG4gICAgICAgIG5ld1ZhbHVlLFxuICAgICAgICBuZXdPZmZzZXRcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tbWl0SW5wdXQoaW5zdGFuY2UsIGVsZW1lbnQsIG5ld09mZnNldCwgaW5wdXRJbml0KSB7XG4gICAgaW5zdGFuY2UuZGlzcGF0Y2hVSUV2ZW50KGVsZW1lbnQsICdpbnB1dCcsIGlucHV0SW5pdCk7XG4gICAgY29tbWl0VmFsdWVBZnRlcklucHV0KGVsZW1lbnQsIG5ld09mZnNldCk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkTnVtYmVySW5wdXQodmFsdWUpIHtcbiAgICB2YXIgcmVmLCByZWYxO1xuICAgIC8vIHRoZSBicm93c2VyIGFsbG93cyBzb21lIGludmFsaWQgaW5wdXQgYnV0IG5vdCBvdGhlcnNcbiAgICAvLyBpdCBhbGxvd3MgdXAgdG8gdHdvICctJyBhdCBhbnkgcGxhY2UgYmVmb3JlIGFueSAnZScgb3Igb25lIGRpcmVjdGx5IGZvbGxvd2luZyAnZSdcbiAgICAvLyBpdCBhbGxvd3Mgb25lICcuJyBhdCBhbnkgcGxhY2UgYmVmb3JlIGVcbiAgICBjb25zdCB2YWx1ZVBhcnRzID0gdmFsdWUuc3BsaXQoJ2UnLCAyKTtcbiAgICByZXR1cm4gISgvW15cXGQuXFwtZV0vLnRlc3QodmFsdWUpIHx8IE51bWJlcigocmVmID0gdmFsdWUubWF0Y2goLy0vZykpID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmLmxlbmd0aCkgPiAyIHx8IE51bWJlcigocmVmMSA9IHZhbHVlLm1hdGNoKC9cXC4vZykpID09PSBudWxsIHx8IHJlZjEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZjEubGVuZ3RoKSA+IDEgfHwgdmFsdWVQYXJ0c1sxXSAmJiAhL14tP1xcZCokLy50ZXN0KHZhbHVlUGFydHNbMV0pKTtcbn1cblxuZXhwb3J0IHsgaW5wdXQgfTtcbiIsImltcG9ydCAnLi4vLi4vdXRpbHMvY2xpY2svaXNDbGlja2FibGVJbnB1dC5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2RhdGFUcmFuc2Zlci9DbGlwYm9hcmQuanMnO1xuaW1wb3J0IHsgaXNFZGl0YWJsZSB9IGZyb20gJy4uLy4uL3V0aWxzL2VkaXQvaXNFZGl0YWJsZS5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2VkaXQvbWF4TGVuZ3RoLmpzJztcbmltcG9ydCAnQHRlc3RpbmctbGlicmFyeS9kb20vZGlzdC9oZWxwZXJzLmpzJztcbmltcG9ydCAnLi4vLi4vdXRpbHMva2V5RGVmL3JlYWROZXh0RGVzY3JpcHRvci5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL21pc2MvbGV2ZWwuanMnO1xuaW1wb3J0ICcuLi8uLi9vcHRpb25zLmpzJztcbmltcG9ydCB7IGlucHV0IH0gZnJvbSAnLi4vaW5wdXQuanMnO1xuaW1wb3J0IHsgYmVoYXZpb3IgfSBmcm9tICcuL3JlZ2lzdHJ5LmpzJztcblxuYmVoYXZpb3IuY3V0ID0gKGV2ZW50LCB0YXJnZXQsIGluc3RhbmNlKT0+e1xuICAgIHJldHVybiAoKT0+e1xuICAgICAgICBpZiAoaXNFZGl0YWJsZSh0YXJnZXQpKSB7XG4gICAgICAgICAgICBpbnB1dChpbnN0YW5jZSwgdGFyZ2V0LCAnJywgJ2RlbGV0ZUJ5Q3V0Jyk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbiIsImltcG9ydCAnLi4vdXRpbHMvY2xpY2svaXNDbGlja2FibGVJbnB1dC5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2RhdGFUcmFuc2Zlci9DbGlwYm9hcmQuanMnO1xuaW1wb3J0IHsgaXNDb250ZW50RWRpdGFibGUgfSBmcm9tICcuLi91dGlscy9lZGl0L2lzQ29udGVudEVkaXRhYmxlLmpzJztcbmltcG9ydCAnLi4vdXRpbHMvZWRpdC9pc0VkaXRhYmxlLmpzJztcbmltcG9ydCAnLi4vdXRpbHMvZWRpdC9tYXhMZW5ndGguanMnO1xuaW1wb3J0ICdAdGVzdGluZy1saWJyYXJ5L2RvbS9kaXN0L2hlbHBlcnMuanMnO1xuaW1wb3J0ICcuLi91dGlscy9rZXlEZWYvcmVhZE5leHREZXNjcmlwdG9yLmpzJztcbmltcG9ydCAnLi4vdXRpbHMvbWlzYy9sZXZlbC5qcyc7XG5pbXBvcnQgJy4uL29wdGlvbnMuanMnO1xuaW1wb3J0IHsgZ2V0VUlWYWx1ZSB9IGZyb20gJy4vVUkuanMnO1xuXG5mdW5jdGlvbiBnZXRWYWx1ZU9yVGV4dENvbnRlbnQoZWxlbWVudCkge1xuICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGlzQ29udGVudEVkaXRhYmxlKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50LnRleHRDb250ZW50O1xuICAgIH1cbiAgICByZXR1cm4gZ2V0VUlWYWx1ZShlbGVtZW50KTtcbn1cblxuZXhwb3J0IHsgZ2V0VmFsdWVPclRleHRDb250ZW50IH07XG4iLCJpbXBvcnQgeyBnZXRXaW5kb3cgfSBmcm9tICcuL2dldFdpbmRvdy5qcyc7XG5cbmZ1bmN0aW9uIGlzVmlzaWJsZShlbGVtZW50KSB7XG4gICAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICAgIGZvcihsZXQgZWwgPSBlbGVtZW50OyBlbCA9PT0gbnVsbCB8fCBlbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWwub3duZXJEb2N1bWVudDsgZWwgPSBlbC5wYXJlbnRFbGVtZW50KXtcbiAgICAgICAgY29uc3QgeyBkaXNwbGF5ICwgdmlzaWJpbGl0eSAgfSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICAgICAgaWYgKGRpc3BsYXkgPT09ICdub25lJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aXNpYmlsaXR5ID09PSAnaGlkZGVuJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgeyBpc1Zpc2libGUgfTtcbiIsImltcG9ydCB7IGlzRGlzYWJsZWQgfSBmcm9tICcuLi9taXNjL2lzRGlzYWJsZWQuanMnO1xuaW1wb3J0IHsgaXNFbGVtZW50VHlwZSB9IGZyb20gJy4uL21pc2MvaXNFbGVtZW50VHlwZS5qcyc7XG5pbXBvcnQgeyBpc1Zpc2libGUgfSBmcm9tICcuLi9taXNjL2lzVmlzaWJsZS5qcyc7XG5pbXBvcnQgeyBGT0NVU0FCTEVfU0VMRUNUT1IgfSBmcm9tICcuL3NlbGVjdG9yLmpzJztcblxuZnVuY3Rpb24gZ2V0VGFiRGVzdGluYXRpb24oYWN0aXZlRWxlbWVudCwgc2hpZnQpIHtcbiAgICBjb25zdCBkb2N1bWVudCA9IGFjdGl2ZUVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgICBjb25zdCBmb2N1c2FibGVFbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoRk9DVVNBQkxFX1NFTEVDVE9SKTtcbiAgICBjb25zdCBlbmFibGVkRWxlbWVudHMgPSBBcnJheS5mcm9tKGZvY3VzYWJsZUVsZW1lbnRzKS5maWx0ZXIoKGVsKT0+ZWwgPT09IGFjdGl2ZUVsZW1lbnQgfHwgIShOdW1iZXIoZWwuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpKSA8IDAgfHwgaXNEaXNhYmxlZChlbCkpKTtcbiAgICAvLyB0YWJpbmRleCBoYXMgbm8gZWZmZWN0IGlmIHRoZSBhY3RpdmUgZWxlbWVudCBoYXMgbmVnYXRpdmUgdGFiaW5kZXhcbiAgICBpZiAoTnVtYmVyKGFjdGl2ZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpKSA+PSAwKSB7XG4gICAgICAgIGVuYWJsZWRFbGVtZW50cy5zb3J0KChhLCBiKT0+e1xuICAgICAgICAgICAgY29uc3QgaSA9IE51bWJlcihhLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSk7XG4gICAgICAgICAgICBjb25zdCBqID0gTnVtYmVyKGIuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpKTtcbiAgICAgICAgICAgIGlmIChpID09PSBqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpIC0gajtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGNoZWNrZWRSYWRpbyA9IHt9O1xuICAgIGxldCBwcnVuZWRFbGVtZW50cyA9IFtcbiAgICAgICAgZG9jdW1lbnQuYm9keVxuICAgIF07XG4gICAgY29uc3QgYWN0aXZlUmFkaW9Hcm91cCA9IGlzRWxlbWVudFR5cGUoYWN0aXZlRWxlbWVudCwgJ2lucHV0Jywge1xuICAgICAgICB0eXBlOiAncmFkaW8nXG4gICAgfSkgPyBhY3RpdmVFbGVtZW50Lm5hbWUgOiB1bmRlZmluZWQ7XG4gICAgZW5hYmxlZEVsZW1lbnRzLmZvckVhY2goKGN1cnJlbnRFbGVtZW50KT0+e1xuICAgICAgICBjb25zdCBlbCA9IGN1cnJlbnRFbGVtZW50O1xuICAgICAgICAvLyBGb3IgcmFkaW8gZ3JvdXBzIGtlZXAgb25seSB0aGUgYWN0aXZlIHJhZGlvXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGFjdGl2ZSByYWRpbywga2VlcCBvbmx5IHRoZSBjaGVja2VkIHJhZGlvXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGNoZWNrZWQgcmFkaW8sIHRyZWF0IGxpa2UgZXZlcnl0aGluZyBlbHNlXG4gICAgICAgIGlmIChpc0VsZW1lbnRUeXBlKGVsLCAnaW5wdXQnLCB7XG4gICAgICAgICAgICB0eXBlOiAncmFkaW8nXG4gICAgICAgIH0pICYmIGVsLm5hbWUpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBhY3RpdmUgZWxlbWVudCBpcyBwYXJ0IG9mIHRoZSBncm91cCwgYWRkIG9ubHkgdGhhdFxuICAgICAgICAgICAgaWYgKGVsID09PSBhY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcHJ1bmVkRWxlbWVudHMucHVzaChlbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlbC5uYW1lID09PSBhY3RpdmVSYWRpb0dyb3VwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2Ugc3R1bWJsZSB1cG9uIGEgY2hlY2tlZCByYWRpbywgcmVtb3ZlIHRoZSBvdGhlcnNcbiAgICAgICAgICAgIGlmIChlbC5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgcHJ1bmVkRWxlbWVudHMgPSBwcnVuZWRFbGVtZW50cy5maWx0ZXIoKGUpPT4haXNFbGVtZW50VHlwZShlLCAnaW5wdXQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncmFkaW8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZWwubmFtZVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgcHJ1bmVkRWxlbWVudHMucHVzaChlbCk7XG4gICAgICAgICAgICAgICAgY2hlY2tlZFJhZGlvW2VsLm5hbWVdID0gZWw7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgYWxyZWFkeSBmb3VuZCB0aGUgY2hlY2tlZCBvbmUsIHNraXBcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hlY2tlZFJhZGlvW2VsLm5hbWVdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcnVuZWRFbGVtZW50cy5wdXNoKGVsKTtcbiAgICB9KTtcbiAgICBmb3IobGV0IGluZGV4ID0gcHJ1bmVkRWxlbWVudHMuZmluZEluZGV4KChlbCk9PmVsID09PSBhY3RpdmVFbGVtZW50KTs7KXtcbiAgICAgICAgaW5kZXggKz0gc2hpZnQgPyAtMSA6IDE7XG4gICAgICAgIC8vIGxvb3AgYXQgb3ZlcmZsb3dcbiAgICAgICAgaWYgKGluZGV4ID09PSBwcnVuZWRFbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGluZGV4ID0gcHJ1bmVkRWxlbWVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJ1bmVkRWxlbWVudHNbaW5kZXhdID09PSBhY3RpdmVFbGVtZW50IHx8IHBydW5lZEVsZW1lbnRzW2luZGV4XSA9PT0gZG9jdW1lbnQuYm9keSB8fCBpc1Zpc2libGUocHJ1bmVkRWxlbWVudHNbaW5kZXhdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBydW5lZEVsZW1lbnRzW2luZGV4XTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHsgZ2V0VGFiRGVzdGluYXRpb24gfTtcbiIsImltcG9ydCB7IGdldFVJU2VsZWN0aW9uIH0gZnJvbSAnLi4vLi4vZG9jdW1lbnQvVUkuanMnO1xuaW1wb3J0ICcuLi8uLi91dGlscy9jbGljay9pc0NsaWNrYWJsZUlucHV0LmpzJztcbmltcG9ydCAnLi4vLi4vdXRpbHMvZGF0YVRyYW5zZmVyL0NsaXBib2FyZC5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2VkaXQvaXNFZGl0YWJsZS5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2VkaXQvbWF4TGVuZ3RoLmpzJztcbmltcG9ydCB7IGdldE5leHRDdXJzb3JQb3NpdGlvbiB9IGZyb20gJy4uLy4uL3V0aWxzL2ZvY3VzL2N1cnNvci5qcyc7XG5pbXBvcnQgJ0B0ZXN0aW5nLWxpYnJhcnkvZG9tL2Rpc3QvaGVscGVycy5qcyc7XG5pbXBvcnQgeyBoYXNPd25TZWxlY3Rpb24gfSBmcm9tICcuLi8uLi91dGlscy9mb2N1cy9zZWxlY3Rpb24uanMnO1xuaW1wb3J0ICcuLi8uLi91dGlscy9rZXlEZWYvcmVhZE5leHREZXNjcmlwdG9yLmpzJztcbmltcG9ydCAnLi4vLi4vdXRpbHMvbWlzYy9sZXZlbC5qcyc7XG5pbXBvcnQgJy4uLy4uL29wdGlvbnMuanMnO1xuaW1wb3J0IHsgc2V0U2VsZWN0aW9uIH0gZnJvbSAnLi9zZXRTZWxlY3Rpb24uanMnO1xuXG4vKipcbiAqIE1vdmUgdGhlIHNlbGVjdGlvblxuICovIGZ1bmN0aW9uIG1vdmVTZWxlY3Rpb24obm9kZSwgZGlyZWN0aW9uKSB7XG4gICAgLy8gVE9ETzogaW1wbGVtZW50IHNoaWZ0XG4gICAgaWYgKGhhc093blNlbGVjdGlvbihub2RlKSkge1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBnZXRVSVNlbGVjdGlvbihub2RlKTtcbiAgICAgICAgc2V0U2VsZWN0aW9uKHtcbiAgICAgICAgICAgIGZvY3VzTm9kZTogbm9kZSxcbiAgICAgICAgICAgIGZvY3VzT2Zmc2V0OiBzZWxlY3Rpb24uc3RhcnRPZmZzZXQgPT09IHNlbGVjdGlvbi5lbmRPZmZzZXQgPyBzZWxlY3Rpb24uZm9jdXNPZmZzZXQgKyBkaXJlY3Rpb24gOiBkaXJlY3Rpb24gPCAwID8gc2VsZWN0aW9uLnN0YXJ0T2Zmc2V0IDogc2VsZWN0aW9uLmVuZE9mZnNldFxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24xID0gbm9kZS5vd25lckRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgICAgICBpZiAoIShzZWxlY3Rpb24xID09PSBudWxsIHx8IHNlbGVjdGlvbjEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbGVjdGlvbjEuZm9jdXNOb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxlY3Rpb24xLmlzQ29sbGFwc2VkKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0UG9zaXRpb24gPSBnZXROZXh0Q3Vyc29yUG9zaXRpb24oc2VsZWN0aW9uMS5mb2N1c05vZGUsIHNlbGVjdGlvbjEuZm9jdXNPZmZzZXQsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICBpZiAobmV4dFBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2V0U2VsZWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNOb2RlOiBuZXh0UG9zaXRpb24ubm9kZSxcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNPZmZzZXQ6IG5leHRQb3NpdGlvbi5vZmZzZXRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbjFbZGlyZWN0aW9uIDwgMCA/ICdjb2xsYXBzZVRvU3RhcnQnIDogJ2NvbGxhcHNlVG9FbmQnXSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBtb3ZlU2VsZWN0aW9uIH07XG4iLCJpbXBvcnQgeyBnZXRVSVZhbHVlLCBnZXRVSVNlbGVjdGlvbiB9IGZyb20gJy4uLy4uL2RvY3VtZW50L1VJLmpzJztcbmltcG9ydCAnLi4vLi4vdXRpbHMvY2xpY2svaXNDbGlja2FibGVJbnB1dC5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2RhdGFUcmFuc2Zlci9DbGlwYm9hcmQuanMnO1xuaW1wb3J0IHsgZ2V0Q29udGVudEVkaXRhYmxlIH0gZnJvbSAnLi4vLi4vdXRpbHMvZWRpdC9pc0NvbnRlbnRFZGl0YWJsZS5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2VkaXQvaXNFZGl0YWJsZS5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2VkaXQvbWF4TGVuZ3RoLmpzJztcbmltcG9ydCAnQHRlc3RpbmctbGlicmFyeS9kb20vZGlzdC9oZWxwZXJzLmpzJztcbmltcG9ydCB7IGhhc093blNlbGVjdGlvbiB9IGZyb20gJy4uLy4uL3V0aWxzL2ZvY3VzL3NlbGVjdGlvbi5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2tleURlZi9yZWFkTmV4dERlc2NyaXB0b3IuanMnO1xuaW1wb3J0ICcuLi8uLi91dGlscy9taXNjL2xldmVsLmpzJztcbmltcG9ydCAnLi4vLi4vb3B0aW9ucy5qcyc7XG5pbXBvcnQgeyBzZXRTZWxlY3Rpb24gfSBmcm9tICcuL3NldFNlbGVjdGlvbi5qcyc7XG5cbi8qKlxuICogRXhwYW5kIGEgc2VsZWN0aW9uIGxpa2UgdGhlIGJyb3dzZXIgZG9lcyB3aGVuIHByZXNzaW5nIEN0cmwrQS5cbiAqLyBmdW5jdGlvbiBzZWxlY3RBbGwodGFyZ2V0KSB7XG4gICAgaWYgKGhhc093blNlbGVjdGlvbih0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiBzZXRTZWxlY3Rpb24oe1xuICAgICAgICAgICAgZm9jdXNOb2RlOiB0YXJnZXQsXG4gICAgICAgICAgICBhbmNob3JPZmZzZXQ6IDAsXG4gICAgICAgICAgICBmb2N1c09mZnNldDogZ2V0VUlWYWx1ZSh0YXJnZXQpLmxlbmd0aFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIHJlZjtcbiAgICBjb25zdCBmb2N1c05vZGUgPSAocmVmID0gZ2V0Q29udGVudEVkaXRhYmxlKHRhcmdldCkpICE9PSBudWxsICYmIHJlZiAhPT0gdm9pZCAwID8gcmVmIDogdGFyZ2V0Lm93bmVyRG9jdW1lbnQuYm9keTtcbiAgICBzZXRTZWxlY3Rpb24oe1xuICAgICAgICBmb2N1c05vZGUsXG4gICAgICAgIGFuY2hvck9mZnNldDogMCxcbiAgICAgICAgZm9jdXNPZmZzZXQ6IGZvY3VzTm9kZS5jaGlsZE5vZGVzLmxlbmd0aFxuICAgIH0pO1xufVxuZnVuY3Rpb24gaXNBbGxTZWxlY3RlZCh0YXJnZXQpIHtcbiAgICBpZiAoaGFzT3duU2VsZWN0aW9uKHRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuIGdldFVJU2VsZWN0aW9uKHRhcmdldCkuc3RhcnRPZmZzZXQgPT09IDAgJiYgZ2V0VUlTZWxlY3Rpb24odGFyZ2V0KS5lbmRPZmZzZXQgPT09IGdldFVJVmFsdWUodGFyZ2V0KS5sZW5ndGg7XG4gICAgfVxuICAgIHZhciByZWY7XG4gICAgY29uc3QgZm9jdXNOb2RlID0gKHJlZiA9IGdldENvbnRlbnRFZGl0YWJsZSh0YXJnZXQpKSAhPT0gbnVsbCAmJiByZWYgIT09IHZvaWQgMCA/IHJlZiA6IHRhcmdldC5vd25lckRvY3VtZW50LmJvZHk7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gdGFyZ2V0Lm93bmVyRG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIChzZWxlY3Rpb24gPT09IG51bGwgfHwgc2VsZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3Rpb24uYW5jaG9yTm9kZSkgPT09IGZvY3VzTm9kZSAmJiBzZWxlY3Rpb24uZm9jdXNOb2RlID09PSBmb2N1c05vZGUgJiYgc2VsZWN0aW9uLmFuY2hvck9mZnNldCA9PT0gMCAmJiBzZWxlY3Rpb24uZm9jdXNPZmZzZXQgPT09IGZvY3VzTm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtcbn1cblxuZXhwb3J0IHsgaXNBbGxTZWxlY3RlZCwgc2VsZWN0QWxsIH07XG4iLCJpbXBvcnQgJy4uLy4uL3V0aWxzL2NsaWNrL2lzQ2xpY2thYmxlSW5wdXQuanMnO1xuaW1wb3J0ICcuLi8uLi91dGlscy9kYXRhVHJhbnNmZXIvQ2xpcGJvYXJkLmpzJztcbmltcG9ydCB7IGlzQ29udGVudEVkaXRhYmxlIH0gZnJvbSAnLi4vLi4vdXRpbHMvZWRpdC9pc0NvbnRlbnRFZGl0YWJsZS5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2VkaXQvaXNFZGl0YWJsZS5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2VkaXQvbWF4TGVuZ3RoLmpzJztcbmltcG9ydCAnQHRlc3RpbmctbGlicmFyeS9kb20vZGlzdC9oZWxwZXJzLmpzJztcbmltcG9ydCB7IGhhc093blNlbGVjdGlvbiB9IGZyb20gJy4uLy4uL3V0aWxzL2ZvY3VzL3NlbGVjdGlvbi5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2tleURlZi9yZWFkTmV4dERlc2NyaXB0b3IuanMnO1xuaW1wb3J0ICcuLi8uLi91dGlscy9taXNjL2xldmVsLmpzJztcbmltcG9ydCAnLi4vLi4vb3B0aW9ucy5qcyc7XG5pbXBvcnQgeyBzZXRTZWxlY3Rpb24gfSBmcm9tICcuL3NldFNlbGVjdGlvbi5qcyc7XG5cbi8qKlxuICogQmFja3dhcmQtY29tcGF0aWJsZSBzZWxlY3Rpb24uXG4gKlxuICogSGFuZGxlcyBpbnB1dCBlbGVtZW50cyBhbmQgY29udGVudGVkaXRhYmxlIGlmIGl0IG9ubHkgY29udGFpbnMgYSBzaW5nbGUgdGV4dCBub2RlLlxuICovIGZ1bmN0aW9uIHNldFNlbGVjdGlvblJhbmdlKGVsZW1lbnQsIGFuY2hvck9mZnNldCwgZm9jdXNPZmZzZXQpIHtcbiAgICB2YXIgcmVmO1xuICAgIGlmIChoYXNPd25TZWxlY3Rpb24oZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIHNldFNlbGVjdGlvbih7XG4gICAgICAgICAgICBmb2N1c05vZGU6IGVsZW1lbnQsXG4gICAgICAgICAgICBhbmNob3JPZmZzZXQsXG4gICAgICAgICAgICBmb2N1c09mZnNldFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi8gaWYgKGlzQ29udGVudEVkaXRhYmxlKGVsZW1lbnQpICYmICgocmVmID0gZWxlbWVudC5maXJzdENoaWxkKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5ub2RlVHlwZSkgPT09IDMpIHtcbiAgICAgICAgcmV0dXJuIHNldFNlbGVjdGlvbih7XG4gICAgICAgICAgICBmb2N1c05vZGU6IGVsZW1lbnQuZmlyc3RDaGlsZCxcbiAgICAgICAgICAgIGFuY2hvck9mZnNldCxcbiAgICAgICAgICAgIGZvY3VzT2Zmc2V0XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZC4gVGhlIHJlc3VsdCBvZiB0aGlzIGludGVyYWN0aW9uIGlzIHVucmVsaWFibGUuJyk7XG59XG5cbmV4cG9ydCB7IHNldFNlbGVjdGlvblJhbmdlIH07XG4iLCJpbXBvcnQgJy4uL3V0aWxzL2NsaWNrL2lzQ2xpY2thYmxlSW5wdXQuanMnO1xuaW1wb3J0ICcuLi91dGlscy9kYXRhVHJhbnNmZXIvQ2xpcGJvYXJkLmpzJztcbmltcG9ydCAnLi4vdXRpbHMvZWRpdC9pc0VkaXRhYmxlLmpzJztcbmltcG9ydCAnLi4vdXRpbHMvZWRpdC9tYXhMZW5ndGguanMnO1xuaW1wb3J0IHsgaXNEaXNhYmxlZCB9IGZyb20gJy4uL3V0aWxzL21pc2MvaXNEaXNhYmxlZC5qcyc7XG5pbXBvcnQgeyBnZXRXaW5kb3cgfSBmcm9tICcuLi91dGlscy9taXNjL2dldFdpbmRvdy5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2tleURlZi9yZWFkTmV4dERlc2NyaXB0b3IuanMnO1xuaW1wb3J0ICcuLi91dGlscy9taXNjL2xldmVsLmpzJztcbmltcG9ydCAnLi4vb3B0aW9ucy5qcyc7XG5pbXBvcnQgeyBmb2N1c0VsZW1lbnQgfSBmcm9tICcuL2ZvY3VzLmpzJztcblxuZnVuY3Rpb24gd2Fsa1JhZGlvKGluc3RhbmNlLCBlbCwgZGlyZWN0aW9uKSB7XG4gICAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KGVsKTtcbiAgICBjb25zdCBncm91cCA9IEFycmF5LmZyb20oZWwub3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGVsLm5hbWUgPyBgaW5wdXRbdHlwZT1cInJhZGlvXCJdW25hbWU9XCIke3dpbmRvdy5DU1MuZXNjYXBlKGVsLm5hbWUpfVwiXWAgOiBgaW5wdXRbdHlwZT1cInJhZGlvXCJdW25hbWU9XCJcIl0sIGlucHV0W3R5cGU9XCJyYWRpb1wiXTpub3QoW25hbWVdKWApKTtcbiAgICBmb3IobGV0IGkgPSBncm91cC5maW5kSW5kZXgoKGUpPT5lID09PSBlbCkgKyBkaXJlY3Rpb247OyBpICs9IGRpcmVjdGlvbil7XG4gICAgICAgIGlmICghZ3JvdXBbaV0pIHtcbiAgICAgICAgICAgIGkgPSBkaXJlY3Rpb24gPiAwID8gMCA6IGdyb3VwLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwW2ldID09PSBlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Rpc2FibGVkKGdyb3VwW2ldKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9jdXNFbGVtZW50KGdyb3VwW2ldKTtcbiAgICAgICAgaW5zdGFuY2UuZGlzcGF0Y2hVSUV2ZW50KGdyb3VwW2ldLCAnY2xpY2snKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IHdhbGtSYWRpbyB9O1xuIiwiaW1wb3J0IHsgZ2V0VUlWYWx1ZSwgc2V0VUlTZWxlY3Rpb24gfSBmcm9tICcuLi8uLi9kb2N1bWVudC9VSS5qcyc7XG5pbXBvcnQgeyBnZXRWYWx1ZU9yVGV4dENvbnRlbnQgfSBmcm9tICcuLi8uLi9kb2N1bWVudC9nZXRWYWx1ZU9yVGV4dENvbnRlbnQuanMnO1xuaW1wb3J0ICcuLi8uLi91dGlscy9jbGljay9pc0NsaWNrYWJsZUlucHV0LmpzJztcbmltcG9ydCAnLi4vLi4vdXRpbHMvZGF0YVRyYW5zZmVyL0NsaXBib2FyZC5qcyc7XG5pbXBvcnQgeyBpc0NvbnRlbnRFZGl0YWJsZSB9IGZyb20gJy4uLy4uL3V0aWxzL2VkaXQvaXNDb250ZW50RWRpdGFibGUuanMnO1xuaW1wb3J0IHsgaXNFZGl0YWJsZSB9IGZyb20gJy4uLy4uL3V0aWxzL2VkaXQvaXNFZGl0YWJsZS5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2VkaXQvbWF4TGVuZ3RoLmpzJztcbmltcG9ydCB7IGlzRWxlbWVudFR5cGUgfSBmcm9tICcuLi8uLi91dGlscy9taXNjL2lzRWxlbWVudFR5cGUuanMnO1xuaW1wb3J0IHsgZ2V0VGFiRGVzdGluYXRpb24gfSBmcm9tICcuLi8uLi91dGlscy9mb2N1cy9nZXRUYWJEZXN0aW5hdGlvbi5qcyc7XG5pbXBvcnQgeyBoYXNPd25TZWxlY3Rpb24gfSBmcm9tICcuLi8uLi91dGlscy9mb2N1cy9zZWxlY3Rpb24uanMnO1xuaW1wb3J0ICcuLi8uLi91dGlscy9rZXlEZWYvcmVhZE5leHREZXNjcmlwdG9yLmpzJztcbmltcG9ydCAnQHRlc3RpbmctbGlicmFyeS9kb20vZGlzdC9oZWxwZXJzLmpzJztcbmltcG9ydCAnLi4vLi4vdXRpbHMvbWlzYy9sZXZlbC5qcyc7XG5pbXBvcnQgJy4uLy4uL29wdGlvbnMuanMnO1xuaW1wb3J0IHsgZm9jdXNFbGVtZW50IH0gZnJvbSAnLi4vZm9jdXMuanMnO1xuaW1wb3J0IHsgaW5wdXQgfSBmcm9tICcuLi9pbnB1dC5qcyc7XG5pbXBvcnQgeyBtb3ZlU2VsZWN0aW9uIH0gZnJvbSAnLi4vc2VsZWN0aW9uL21vdmVTZWxlY3Rpb24uanMnO1xuaW1wb3J0IHsgc2VsZWN0QWxsIH0gZnJvbSAnLi4vc2VsZWN0aW9uL3NlbGVjdEFsbC5qcyc7XG5pbXBvcnQgeyBzZXRTZWxlY3Rpb25SYW5nZSB9IGZyb20gJy4uL3NlbGVjdGlvbi9zZXRTZWxlY3Rpb25SYW5nZS5qcyc7XG5pbXBvcnQgeyB3YWxrUmFkaW8gfSBmcm9tICcuLi9yYWRpby5qcyc7XG5pbXBvcnQgeyBiZWhhdmlvciB9IGZyb20gJy4vcmVnaXN0cnkuanMnO1xuXG5iZWhhdmlvci5rZXlkb3duID0gKGV2ZW50LCB0YXJnZXQsIGluc3RhbmNlKT0+e1xuICAgIHZhciByZWY7XG4gICAgdmFyIHJlZjE7XG4gICAgcmV0dXJuIChyZWYxID0gKHJlZiA9IGtleWRvd25CZWhhdmlvcltldmVudC5rZXldKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5jYWxsKGtleWRvd25CZWhhdmlvciwgZXZlbnQsIHRhcmdldCwgaW5zdGFuY2UpKSAhPT0gbnVsbCAmJiByZWYxICE9PSB2b2lkIDAgPyByZWYxIDogY29tYmluYXRpb25CZWhhdmlvcihldmVudCwgdGFyZ2V0LCBpbnN0YW5jZSk7XG59O1xuY29uc3Qga2V5ZG93bkJlaGF2aW9yID0ge1xuICAgIEFycm93RG93bjogKGV2ZW50LCB0YXJnZXQsIGluc3RhbmNlKT0+e1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqLyBpZiAoaXNFbGVtZW50VHlwZSh0YXJnZXQsICdpbnB1dCcsIHtcbiAgICAgICAgICAgIHR5cGU6ICdyYWRpbydcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHJldHVybiAoKT0+d2Fsa1JhZGlvKGluc3RhbmNlLCB0YXJnZXQsIC0xKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgQXJyb3dMZWZ0OiAoZXZlbnQsIHRhcmdldCwgaW5zdGFuY2UpPT57XG4gICAgICAgIGlmIChpc0VsZW1lbnRUeXBlKHRhcmdldCwgJ2lucHV0Jywge1xuICAgICAgICAgICAgdHlwZTogJ3JhZGlvJ1xuICAgICAgICB9KSkge1xuICAgICAgICAgICAgcmV0dXJuICgpPT53YWxrUmFkaW8oaW5zdGFuY2UsIHRhcmdldCwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKT0+bW92ZVNlbGVjdGlvbih0YXJnZXQsIC0xKTtcbiAgICB9LFxuICAgIEFycm93UmlnaHQ6IChldmVudCwgdGFyZ2V0LCBpbnN0YW5jZSk9PntcbiAgICAgICAgaWYgKGlzRWxlbWVudFR5cGUodGFyZ2V0LCAnaW5wdXQnLCB7XG4gICAgICAgICAgICB0eXBlOiAncmFkaW8nXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXR1cm4gKCk9PndhbGtSYWRpbyhpbnN0YW5jZSwgdGFyZ2V0LCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCk9Pm1vdmVTZWxlY3Rpb24odGFyZ2V0LCAxKTtcbiAgICB9LFxuICAgIEFycm93VXA6IChldmVudCwgdGFyZ2V0LCBpbnN0YW5jZSk9PntcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi8gaWYgKGlzRWxlbWVudFR5cGUodGFyZ2V0LCAnaW5wdXQnLCB7XG4gICAgICAgICAgICB0eXBlOiAncmFkaW8nXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXR1cm4gKCk9PndhbGtSYWRpbyhpbnN0YW5jZSwgdGFyZ2V0LCAxKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgQmFja3NwYWNlOiAoZXZlbnQsIHRhcmdldCwgaW5zdGFuY2UpPT57XG4gICAgICAgIGlmIChpc0VkaXRhYmxlKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgICAgIGlucHV0KGluc3RhbmNlLCB0YXJnZXQsICcnLCAnZGVsZXRlQ29udGVudEJhY2t3YXJkJyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcbiAgICBEZWxldGU6IChldmVudCwgdGFyZ2V0LCBpbnN0YW5jZSk9PntcbiAgICAgICAgaWYgKGlzRWRpdGFibGUodGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICAgICAgaW5wdXQoaW5zdGFuY2UsIHRhcmdldCwgJycsICdkZWxldGVDb250ZW50Rm9yd2FyZCcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgRW5kOiAoZXZlbnQsIHRhcmdldCk9PntcbiAgICAgICAgaWYgKGlzRWxlbWVudFR5cGUodGFyZ2V0LCBbXG4gICAgICAgICAgICAnaW5wdXQnLFxuICAgICAgICAgICAgJ3RleHRhcmVhJ1xuICAgICAgICBdKSB8fCBpc0NvbnRlbnRFZGl0YWJsZSh0YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgICAgIHZhciByZWYxO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1BvcyA9IChyZWYxID0gKHJlZiA9IGdldFZhbHVlT3JUZXh0Q29udGVudCh0YXJnZXQpKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5sZW5ndGgpICE9PSBudWxsICYmIHJlZjEgIT09IHZvaWQgMCA/IHJlZjEgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyAwO1xuICAgICAgICAgICAgICAgIHNldFNlbGVjdGlvblJhbmdlKHRhcmdldCwgbmV3UG9zLCBuZXdQb3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgSG9tZTogKGV2ZW50LCB0YXJnZXQpPT57XG4gICAgICAgIGlmIChpc0VsZW1lbnRUeXBlKHRhcmdldCwgW1xuICAgICAgICAgICAgJ2lucHV0JyxcbiAgICAgICAgICAgICd0ZXh0YXJlYSdcbiAgICAgICAgXSkgfHwgaXNDb250ZW50RWRpdGFibGUodGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICAgICAgc2V0U2VsZWN0aW9uUmFuZ2UodGFyZ2V0LCAwLCAwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFBhZ2VEb3duOiAoZXZlbnQsIHRhcmdldCk9PntcbiAgICAgICAgaWYgKGlzRWxlbWVudFR5cGUodGFyZ2V0LCBbXG4gICAgICAgICAgICAnaW5wdXQnXG4gICAgICAgIF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdQb3MgPSBnZXRVSVZhbHVlKHRhcmdldCkubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHNldFNlbGVjdGlvblJhbmdlKHRhcmdldCwgbmV3UG9zLCBuZXdQb3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgUGFnZVVwOiAoZXZlbnQsIHRhcmdldCk9PntcbiAgICAgICAgaWYgKGlzRWxlbWVudFR5cGUodGFyZ2V0LCBbXG4gICAgICAgICAgICAnaW5wdXQnXG4gICAgICAgIF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgICAgICBzZXRTZWxlY3Rpb25SYW5nZSh0YXJnZXQsIDAsIDApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgVGFiOiAoZXZlbnQsIHRhcmdldCwgaW5zdGFuY2UpPT57XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgY29uc3QgZGVzdCA9IGdldFRhYkRlc3RpbmF0aW9uKHRhcmdldCwgaW5zdGFuY2Uuc3lzdGVtLmtleWJvYXJkLm1vZGlmaWVycy5TaGlmdCk7XG4gICAgICAgICAgICBmb2N1c0VsZW1lbnQoZGVzdCk7XG4gICAgICAgICAgICBpZiAoaGFzT3duU2VsZWN0aW9uKGRlc3QpKSB7XG4gICAgICAgICAgICAgICAgc2V0VUlTZWxlY3Rpb24oZGVzdCwge1xuICAgICAgICAgICAgICAgICAgICBhbmNob3JPZmZzZXQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzT2Zmc2V0OiBkZXN0LnZhbHVlLmxlbmd0aFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn07XG5jb25zdCBjb21iaW5hdGlvbkJlaGF2aW9yID0gKGV2ZW50LCB0YXJnZXQsIGluc3RhbmNlKT0+e1xuICAgIGlmIChldmVudC5jb2RlID09PSAnS2V5QScgJiYgaW5zdGFuY2Uuc3lzdGVtLmtleWJvYXJkLm1vZGlmaWVycy5Db250cm9sKSB7XG4gICAgICAgIHJldHVybiAoKT0+c2VsZWN0QWxsKHRhcmdldCk7XG4gICAgfVxufTtcbiIsImltcG9ydCAnLi4vLi4vdXRpbHMvY2xpY2svaXNDbGlja2FibGVJbnB1dC5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2RhdGFUcmFuc2Zlci9DbGlwYm9hcmQuanMnO1xuaW1wb3J0IHsgaXNDb250ZW50RWRpdGFibGUgfSBmcm9tICcuLi8uLi91dGlscy9lZGl0L2lzQ29udGVudEVkaXRhYmxlLmpzJztcbmltcG9ydCB7IGlzRWRpdGFibGUgfSBmcm9tICcuLi8uLi91dGlscy9lZGl0L2lzRWRpdGFibGUuanMnO1xuaW1wb3J0ICcuLi8uLi91dGlscy9lZGl0L21heExlbmd0aC5qcyc7XG5pbXBvcnQgeyBpc0VsZW1lbnRUeXBlIH0gZnJvbSAnLi4vLi4vdXRpbHMvbWlzYy9pc0VsZW1lbnRUeXBlLmpzJztcbmltcG9ydCAnQHRlc3RpbmctbGlicmFyeS9kb20vZGlzdC9oZWxwZXJzLmpzJztcbmltcG9ydCAnLi4vLi4vdXRpbHMva2V5RGVmL3JlYWROZXh0RGVzY3JpcHRvci5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL21pc2MvbGV2ZWwuanMnO1xuaW1wb3J0ICcuLi8uLi9vcHRpb25zLmpzJztcbmltcG9ydCB7IGlucHV0IH0gZnJvbSAnLi4vaW5wdXQuanMnO1xuaW1wb3J0IHsgYmVoYXZpb3IgfSBmcm9tICcuL3JlZ2lzdHJ5LmpzJztcblxuYmVoYXZpb3Iua2V5cHJlc3MgPSAoZXZlbnQsIHRhcmdldCwgaW5zdGFuY2UpPT57XG4gICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgICBpZiAoaXNFbGVtZW50VHlwZSh0YXJnZXQsICdidXR0b24nKSB8fCBpc0VsZW1lbnRUeXBlKHRhcmdldCwgJ2lucHV0JykgJiYgQ2xpY2tJbnB1dE9uRW50ZXIuaW5jbHVkZXModGFyZ2V0LnR5cGUpIHx8IGlzRWxlbWVudFR5cGUodGFyZ2V0LCAnYScpICYmIEJvb2xlYW4odGFyZ2V0LmhyZWYpKSB7XG4gICAgICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5kaXNwYXRjaFVJRXZlbnQodGFyZ2V0LCAnY2xpY2snKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoaXNFbGVtZW50VHlwZSh0YXJnZXQsICdpbnB1dCcpKSB7XG4gICAgICAgICAgICBjb25zdCBmb3JtID0gdGFyZ2V0LmZvcm07XG4gICAgICAgICAgICBjb25zdCBzdWJtaXQgPSBmb3JtID09PSBudWxsIHx8IGZvcm0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvcm0ucXVlcnlTZWxlY3RvcignaW5wdXRbdHlwZT1cInN1Ym1pdFwiXSwgYnV0dG9uOm5vdChbdHlwZV0pLCBidXR0b25bdHlwZT1cInN1Ym1pdFwiXScpO1xuICAgICAgICAgICAgaWYgKHN1Ym1pdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoKT0+aW5zdGFuY2UuZGlzcGF0Y2hVSUV2ZW50KHN1Ym1pdCwgJ2NsaWNrJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm0gJiYgU3VibWl0U2luZ2xlSW5wdXRPbkVudGVyLmluY2x1ZGVzKHRhcmdldC50eXBlKSAmJiBmb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0JykubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpPT5pbnN0YW5jZS5kaXNwYXRjaFVJRXZlbnQoZm9ybSwgJ3N1Ym1pdCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRWRpdGFibGUodGFyZ2V0KSkge1xuICAgICAgICBjb25zdCBpbnB1dFR5cGUgPSBldmVudC5rZXkgPT09ICdFbnRlcicgPyBpc0NvbnRlbnRFZGl0YWJsZSh0YXJnZXQpICYmICFpbnN0YW5jZS5zeXN0ZW0ua2V5Ym9hcmQubW9kaWZpZXJzLlNoaWZ0ID8gJ2luc2VydFBhcmFncmFwaCcgOiAnaW5zZXJ0TGluZUJyZWFrJyA6ICdpbnNlcnRUZXh0JztcbiAgICAgICAgY29uc3QgaW5wdXREYXRhID0gZXZlbnQua2V5ID09PSAnRW50ZXInID8gJ1xcbicgOiBldmVudC5rZXk7XG4gICAgICAgIHJldHVybiAoKT0+aW5wdXQoaW5zdGFuY2UsIHRhcmdldCwgaW5wdXREYXRhLCBpbnB1dFR5cGUpO1xuICAgIH1cbn07XG5jb25zdCBDbGlja0lucHV0T25FbnRlciA9IFtcbiAgICAnYnV0dG9uJyxcbiAgICAnY29sb3InLFxuICAgICdmaWxlJyxcbiAgICAnaW1hZ2UnLFxuICAgICdyZXNldCcsXG4gICAgJ3N1Ym1pdCcsIFxuXTtcbmNvbnN0IFN1Ym1pdFNpbmdsZUlucHV0T25FbnRlciA9IFtcbiAgICAnZW1haWwnLFxuICAgICdtb250aCcsXG4gICAgJ3Bhc3N3b3JkJyxcbiAgICAnc2VhcmNoJyxcbiAgICAndGVsJyxcbiAgICAndGV4dCcsXG4gICAgJ3VybCcsXG4gICAgJ3dlZWsnLCBcbl07XG4iLCJpbXBvcnQgeyBpc0NsaWNrYWJsZUlucHV0IH0gZnJvbSAnLi4vLi4vdXRpbHMvY2xpY2svaXNDbGlja2FibGVJbnB1dC5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2RhdGFUcmFuc2Zlci9DbGlwYm9hcmQuanMnO1xuaW1wb3J0ICcuLi8uLi91dGlscy9lZGl0L2lzRWRpdGFibGUuanMnO1xuaW1wb3J0ICcuLi8uLi91dGlscy9lZGl0L21heExlbmd0aC5qcyc7XG5pbXBvcnQgJ0B0ZXN0aW5nLWxpYnJhcnkvZG9tL2Rpc3QvaGVscGVycy5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2tleURlZi9yZWFkTmV4dERlc2NyaXB0b3IuanMnO1xuaW1wb3J0ICcuLi8uLi91dGlscy9taXNjL2xldmVsLmpzJztcbmltcG9ydCAnLi4vLi4vb3B0aW9ucy5qcyc7XG5pbXBvcnQgeyBiZWhhdmlvciB9IGZyb20gJy4vcmVnaXN0cnkuanMnO1xuXG5iZWhhdmlvci5rZXl1cCA9IChldmVudCwgdGFyZ2V0LCBpbnN0YW5jZSk9PntcbiAgICB2YXIgcmVmO1xuICAgIHJldHVybiAocmVmID0ga2V5dXBCZWhhdmlvcltldmVudC5rZXldKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5jYWxsKGtleXVwQmVoYXZpb3IsIGV2ZW50LCB0YXJnZXQsIGluc3RhbmNlKTtcbn07XG5jb25zdCBrZXl1cEJlaGF2aW9yID0ge1xuICAgICcgJzogKGV2ZW50LCB0YXJnZXQsIGluc3RhbmNlKT0+e1xuICAgICAgICBpZiAoaXNDbGlja2FibGVJbnB1dCh0YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gKCk9Pmluc3RhbmNlLmRpc3BhdGNoVUlFdmVudCh0YXJnZXQsICdjbGljaycpO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsImltcG9ydCAnLi4vLi4vdXRpbHMvY2xpY2svaXNDbGlja2FibGVJbnB1dC5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2RhdGFUcmFuc2Zlci9DbGlwYm9hcmQuanMnO1xuaW1wb3J0IHsgaXNFZGl0YWJsZSB9IGZyb20gJy4uLy4uL3V0aWxzL2VkaXQvaXNFZGl0YWJsZS5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2VkaXQvbWF4TGVuZ3RoLmpzJztcbmltcG9ydCAnQHRlc3RpbmctbGlicmFyeS9kb20vZGlzdC9oZWxwZXJzLmpzJztcbmltcG9ydCAnLi4vLi4vdXRpbHMva2V5RGVmL3JlYWROZXh0RGVzY3JpcHRvci5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL21pc2MvbGV2ZWwuanMnO1xuaW1wb3J0ICcuLi8uLi9vcHRpb25zLmpzJztcbmltcG9ydCB7IGlucHV0IH0gZnJvbSAnLi4vaW5wdXQuanMnO1xuaW1wb3J0IHsgYmVoYXZpb3IgfSBmcm9tICcuL3JlZ2lzdHJ5LmpzJztcblxuYmVoYXZpb3IucGFzdGUgPSAoZXZlbnQsIHRhcmdldCwgaW5zdGFuY2UpPT57XG4gICAgaWYgKGlzRWRpdGFibGUodGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIHZhciByZWY7XG4gICAgICAgICAgICBjb25zdCBpbnNlcnREYXRhID0gKHJlZiA9IGV2ZW50LmNsaXBib2FyZERhdGEpID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmLmdldERhdGEoJ3RleHQnKTtcbiAgICAgICAgICAgIGlmIChpbnNlcnREYXRhKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQoaW5zdGFuY2UsIHRhcmdldCwgaW5zZXJ0RGF0YSwgJ2luc2VydEZyb21QYXN0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn07XG4iLCJpbXBvcnQgeyBldmVudE1hcCBhcyBldmVudE1hcCQxIH0gZnJvbSAnQHRlc3RpbmctbGlicmFyeS9kb20vZGlzdC9ldmVudC1tYXAuanMnO1xuXG5jb25zdCBldmVudE1hcCA9IHtcbiAgICAuLi5ldmVudE1hcCQxLFxuICAgIGNsaWNrOiB7XG4gICAgICAgIEV2ZW50VHlwZTogJ1BvaW50ZXJFdmVudCcsXG4gICAgICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGF1eGNsaWNrOiB7XG4gICAgICAgIEV2ZW50VHlwZTogJ1BvaW50ZXJFdmVudCcsXG4gICAgICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvbnRleHRtZW51OiB7XG4gICAgICAgIEV2ZW50VHlwZTogJ1BvaW50ZXJFdmVudCcsXG4gICAgICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGJlZm9yZUlucHV0OiB7XG4gICAgICAgIEV2ZW50VHlwZTogJ0lucHV0RXZlbnQnLFxuICAgICAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb21wb3NlZDogdHJ1ZVxuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGV2ZW50TWFwS2V5cyA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3Qua2V5cyhldmVudE1hcCkubWFwKChrKT0+W1xuICAgICAgICBrLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIGtcbiAgICBdKSk7XG5mdW5jdGlvbiBnZXRFdmVudENsYXNzKHR5cGUpIHtcbiAgICBjb25zdCBrID0gZXZlbnRNYXBLZXlzW3R5cGVdO1xuICAgIHJldHVybiBrICYmIGV2ZW50TWFwW2tdLkV2ZW50VHlwZTtcbn1cbmNvbnN0IG1vdXNlRXZlbnRzID0gW1xuICAgICdNb3VzZUV2ZW50JyxcbiAgICAnUG9pbnRlckV2ZW50J1xuXTtcbmZ1bmN0aW9uIGlzTW91c2VFdmVudCh0eXBlKSB7XG4gICAgcmV0dXJuIG1vdXNlRXZlbnRzLmluY2x1ZGVzKGdldEV2ZW50Q2xhc3ModHlwZSkpO1xufVxuZnVuY3Rpb24gaXNLZXlib2FyZEV2ZW50KHR5cGUpIHtcbiAgICByZXR1cm4gZ2V0RXZlbnRDbGFzcyh0eXBlKSA9PT0gJ0tleWJvYXJkRXZlbnQnO1xufVxuXG5leHBvcnQgeyBldmVudE1hcCwgZXZlbnRNYXBLZXlzLCBpc0tleWJvYXJkRXZlbnQsIGlzTW91c2VFdmVudCB9O1xuIiwiaW1wb3J0ICcuLi91dGlscy9jbGljay9pc0NsaWNrYWJsZUlucHV0LmpzJztcbmltcG9ydCAnLi4vdXRpbHMvZGF0YVRyYW5zZmVyL0NsaXBib2FyZC5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2VkaXQvaXNFZGl0YWJsZS5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2VkaXQvbWF4TGVuZ3RoLmpzJztcbmltcG9ydCB7IGdldFdpbmRvdyB9IGZyb20gJy4uL3V0aWxzL21pc2MvZ2V0V2luZG93LmpzJztcbmltcG9ydCAnLi4vdXRpbHMva2V5RGVmL3JlYWROZXh0RGVzY3JpcHRvci5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL21pc2MvbGV2ZWwuanMnO1xuaW1wb3J0ICcuLi9vcHRpb25zLmpzJztcbmltcG9ydCB7IGV2ZW50TWFwLCBldmVudE1hcEtleXMgfSBmcm9tICcuL2V2ZW50TWFwLmpzJztcblxuY29uc3QgZXZlbnRJbml0aWFsaXplciA9IHtcbiAgICBDbGlwYm9hcmRFdmVudDogW1xuICAgICAgICBpbml0Q2xpcGJvYXJkRXZlbnRcbiAgICBdLFxuICAgIElucHV0RXZlbnQ6IFtcbiAgICAgICAgaW5pdFVJRXZlbnQsXG4gICAgICAgIGluaXRJbnB1dEV2ZW50XG4gICAgXSxcbiAgICBNb3VzZUV2ZW50OiBbXG4gICAgICAgIGluaXRVSUV2ZW50LFxuICAgICAgICBpbml0VUlFdmVudE1vZGlmaWZpZXJzLFxuICAgICAgICBpbml0TW91c2VFdmVudFxuICAgIF0sXG4gICAgUG9pbnRlckV2ZW50OiBbXG4gICAgICAgIGluaXRVSUV2ZW50LFxuICAgICAgICBpbml0VUlFdmVudE1vZGlmaWZpZXJzLFxuICAgICAgICBpbml0TW91c2VFdmVudCxcbiAgICAgICAgaW5pdFBvaW50ZXJFdmVudCwgXG4gICAgXSxcbiAgICBLZXlib2FyZEV2ZW50OiBbXG4gICAgICAgIGluaXRVSUV2ZW50LFxuICAgICAgICBpbml0VUlFdmVudE1vZGlmaWZpZXJzLFxuICAgICAgICBpbml0S2V5Ym9hcmRFdmVudFxuICAgIF1cbn07XG5mdW5jdGlvbiBjcmVhdGVFdmVudCh0eXBlLCB0YXJnZXQsIGluaXQpIHtcbiAgICB2YXIgcmVmO1xuICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdyh0YXJnZXQpO1xuICAgIGNvbnN0IHsgRXZlbnRUeXBlICwgZGVmYXVsdEluaXQgIH0gPSBldmVudE1hcFtldmVudE1hcEtleXNbdHlwZV1dO1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IChnZXRFdmVudENvbnN0cnVjdG9ycyh3aW5kb3cpKVtFdmVudFR5cGVdKHR5cGUsIGRlZmF1bHRJbml0KTtcbiAgICAocmVmID0gZXZlbnRJbml0aWFsaXplcltFdmVudFR5cGVdKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5mb3JFYWNoKChmKT0+ZihldmVudCwgaW5pdCAhPT0gbnVsbCAmJiBpbml0ICE9PSB2b2lkIDAgPyBpbml0IDoge30pKTtcbiAgICByZXR1cm4gZXZlbnQ7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbiBnZXRFdmVudENvbnN0cnVjdG9ycyh3aW5kb3cpIHtcbiAgICB2YXIgX0V2ZW50O1xuICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb24sIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHRyYW5lb3VzLWNsYXNzICovIGNvbnN0IEV2ZW50ID0gKF9FdmVudCA9IHdpbmRvdy5FdmVudCkgIT09IG51bGwgJiYgX0V2ZW50ICE9PSB2b2lkIDAgPyBfRXZlbnQgOiBjbGFzcyBFdmVudCB7XG4gICAgfTtcbiAgICB2YXIgX0FuaW1hdGlvbkV2ZW50O1xuICAgIGNvbnN0IEFuaW1hdGlvbkV2ZW50ID0gKF9BbmltYXRpb25FdmVudCA9IHdpbmRvdy5BbmltYXRpb25FdmVudCkgIT09IG51bGwgJiYgX0FuaW1hdGlvbkV2ZW50ICE9PSB2b2lkIDAgPyBfQW5pbWF0aW9uRXZlbnQgOiBjbGFzcyBBbmltYXRpb25FdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICB9O1xuICAgIHZhciBfQ2xpcGJvYXJkRXZlbnQ7XG4gICAgY29uc3QgQ2xpcGJvYXJkRXZlbnQgPSAoX0NsaXBib2FyZEV2ZW50ID0gd2luZG93LkNsaXBib2FyZEV2ZW50KSAhPT0gbnVsbCAmJiBfQ2xpcGJvYXJkRXZlbnQgIT09IHZvaWQgMCA/IF9DbGlwYm9hcmRFdmVudCA6IGNsYXNzIENsaXBib2FyZEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIH07XG4gICAgdmFyIF9Qb3BTdGF0ZUV2ZW50O1xuICAgIGNvbnN0IFBvcFN0YXRlRXZlbnQgPSAoX1BvcFN0YXRlRXZlbnQgPSB3aW5kb3cuUG9wU3RhdGVFdmVudCkgIT09IG51bGwgJiYgX1BvcFN0YXRlRXZlbnQgIT09IHZvaWQgMCA/IF9Qb3BTdGF0ZUV2ZW50IDogY2xhc3MgUG9wU3RhdGVFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICB9O1xuICAgIHZhciBfUHJvZ3Jlc3NFdmVudDtcbiAgICBjb25zdCBQcm9ncmVzc0V2ZW50ID0gKF9Qcm9ncmVzc0V2ZW50ID0gd2luZG93LlByb2dyZXNzRXZlbnQpICE9PSBudWxsICYmIF9Qcm9ncmVzc0V2ZW50ICE9PSB2b2lkIDAgPyBfUHJvZ3Jlc3NFdmVudCA6IGNsYXNzIFByb2dyZXNzRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgfTtcbiAgICB2YXIgX1RyYW5zaXRpb25FdmVudDtcbiAgICBjb25zdCBUcmFuc2l0aW9uRXZlbnQgPSAoX1RyYW5zaXRpb25FdmVudCA9IHdpbmRvdy5UcmFuc2l0aW9uRXZlbnQpICE9PSBudWxsICYmIF9UcmFuc2l0aW9uRXZlbnQgIT09IHZvaWQgMCA/IF9UcmFuc2l0aW9uRXZlbnQgOiBjbGFzcyBUcmFuc2l0aW9uRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgfTtcbiAgICB2YXIgX1VJRXZlbnQ7XG4gICAgY29uc3QgVUlFdmVudCA9IChfVUlFdmVudCA9IHdpbmRvdy5VSUV2ZW50KSAhPT0gbnVsbCAmJiBfVUlFdmVudCAhPT0gdm9pZCAwID8gX1VJRXZlbnQgOiBjbGFzcyBVSUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIH07XG4gICAgdmFyIF9Db21wb3NpdGlvbkV2ZW50O1xuICAgIGNvbnN0IENvbXBvc2l0aW9uRXZlbnQgPSAoX0NvbXBvc2l0aW9uRXZlbnQgPSB3aW5kb3cuQ29tcG9zaXRpb25FdmVudCkgIT09IG51bGwgJiYgX0NvbXBvc2l0aW9uRXZlbnQgIT09IHZvaWQgMCA/IF9Db21wb3NpdGlvbkV2ZW50IDogY2xhc3MgQ29tcG9zaXRpb25FdmVudCBleHRlbmRzIFVJRXZlbnQge1xuICAgIH07XG4gICAgdmFyIF9Gb2N1c0V2ZW50O1xuICAgIGNvbnN0IEZvY3VzRXZlbnQgPSAoX0ZvY3VzRXZlbnQgPSB3aW5kb3cuRm9jdXNFdmVudCkgIT09IG51bGwgJiYgX0ZvY3VzRXZlbnQgIT09IHZvaWQgMCA/IF9Gb2N1c0V2ZW50IDogY2xhc3MgRm9jdXNFdmVudCBleHRlbmRzIFVJRXZlbnQge1xuICAgIH07XG4gICAgdmFyIF9JbnB1dEV2ZW50O1xuICAgIGNvbnN0IElucHV0RXZlbnQgPSAoX0lucHV0RXZlbnQgPSB3aW5kb3cuSW5wdXRFdmVudCkgIT09IG51bGwgJiYgX0lucHV0RXZlbnQgIT09IHZvaWQgMCA/IF9JbnB1dEV2ZW50IDogY2xhc3MgSW5wdXRFdmVudCBleHRlbmRzIFVJRXZlbnQge1xuICAgIH07XG4gICAgdmFyIF9LZXlib2FyZEV2ZW50O1xuICAgIGNvbnN0IEtleWJvYXJkRXZlbnQgPSAoX0tleWJvYXJkRXZlbnQgPSB3aW5kb3cuS2V5Ym9hcmRFdmVudCkgIT09IG51bGwgJiYgX0tleWJvYXJkRXZlbnQgIT09IHZvaWQgMCA/IF9LZXlib2FyZEV2ZW50IDogY2xhc3MgS2V5Ym9hcmRFdmVudCBleHRlbmRzIFVJRXZlbnQge1xuICAgIH07XG4gICAgdmFyIF9Nb3VzZUV2ZW50O1xuICAgIGNvbnN0IE1vdXNlRXZlbnQgPSAoX01vdXNlRXZlbnQgPSB3aW5kb3cuTW91c2VFdmVudCkgIT09IG51bGwgJiYgX01vdXNlRXZlbnQgIT09IHZvaWQgMCA/IF9Nb3VzZUV2ZW50IDogY2xhc3MgTW91c2VFdmVudCBleHRlbmRzIFVJRXZlbnQge1xuICAgIH07XG4gICAgdmFyIF9EcmFnRXZlbnQ7XG4gICAgY29uc3QgRHJhZ0V2ZW50ID0gKF9EcmFnRXZlbnQgPSB3aW5kb3cuRHJhZ0V2ZW50KSAhPT0gbnVsbCAmJiBfRHJhZ0V2ZW50ICE9PSB2b2lkIDAgPyBfRHJhZ0V2ZW50IDogY2xhc3MgRHJhZ0V2ZW50IGV4dGVuZHMgTW91c2VFdmVudCB7XG4gICAgfTtcbiAgICB2YXIgX1BvaW50ZXJFdmVudDtcbiAgICBjb25zdCBQb2ludGVyRXZlbnQgPSAoX1BvaW50ZXJFdmVudCA9IHdpbmRvdy5Qb2ludGVyRXZlbnQpICE9PSBudWxsICYmIF9Qb2ludGVyRXZlbnQgIT09IHZvaWQgMCA/IF9Qb2ludGVyRXZlbnQgOiBjbGFzcyBQb2ludGVyRXZlbnQgZXh0ZW5kcyBNb3VzZUV2ZW50IHtcbiAgICB9O1xuICAgIHZhciBfVG91Y2hFdmVudDtcbiAgICBjb25zdCBUb3VjaEV2ZW50ID0gKF9Ub3VjaEV2ZW50ID0gd2luZG93LlRvdWNoRXZlbnQpICE9PSBudWxsICYmIF9Ub3VjaEV2ZW50ICE9PSB2b2lkIDAgPyBfVG91Y2hFdmVudCA6IGNsYXNzIFRvdWNoRXZlbnQgZXh0ZW5kcyBVSUV2ZW50IHtcbiAgICB9O1xuICAgIC8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvbiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4dHJhbmVvdXMtY2xhc3MgKi8gcmV0dXJuIHtcbiAgICAgICAgRXZlbnQsXG4gICAgICAgIEFuaW1hdGlvbkV2ZW50LFxuICAgICAgICBDbGlwYm9hcmRFdmVudCxcbiAgICAgICAgUG9wU3RhdGVFdmVudCxcbiAgICAgICAgUHJvZ3Jlc3NFdmVudCxcbiAgICAgICAgVHJhbnNpdGlvbkV2ZW50LFxuICAgICAgICBVSUV2ZW50LFxuICAgICAgICBDb21wb3NpdGlvbkV2ZW50LFxuICAgICAgICBGb2N1c0V2ZW50LFxuICAgICAgICBJbnB1dEV2ZW50LFxuICAgICAgICBLZXlib2FyZEV2ZW50LFxuICAgICAgICBNb3VzZUV2ZW50LFxuICAgICAgICBEcmFnRXZlbnQsXG4gICAgICAgIFBvaW50ZXJFdmVudCxcbiAgICAgICAgVG91Y2hFdmVudFxuICAgIH07XG59XG5mdW5jdGlvbiBhc3NpZ25Qcm9wcyhvYmosIHByb3BzKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcHMpKXtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICBnZXQ6ICgpPT52YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwID8gdmFsdWUgOiBudWxsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhbml0aXplTnVtYmVyKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gIT09IG51bGwgJiYgbiAhPT0gdm9pZCAwID8gbiA6IDApO1xufVxuZnVuY3Rpb24gaW5pdENsaXBib2FyZEV2ZW50KGV2ZW50LCB7IGNsaXBib2FyZERhdGEgIH0pIHtcbiAgICBhc3NpZ25Qcm9wcyhldmVudCwge1xuICAgICAgICBjbGlwYm9hcmREYXRhXG4gICAgfSk7XG59XG5mdW5jdGlvbiBpbml0SW5wdXRFdmVudChldmVudCwgeyBkYXRhICwgaW5wdXRUeXBlICwgaXNDb21wb3NpbmcgIH0pIHtcbiAgICBhc3NpZ25Qcm9wcyhldmVudCwge1xuICAgICAgICBkYXRhLFxuICAgICAgICBpc0NvbXBvc2luZzogQm9vbGVhbihpc0NvbXBvc2luZyksXG4gICAgICAgIGlucHV0VHlwZTogU3RyaW5nKGlucHV0VHlwZSlcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGluaXRVSUV2ZW50KGV2ZW50LCB7IHZpZXcgLCBkZXRhaWwgIH0pIHtcbiAgICBhc3NpZ25Qcm9wcyhldmVudCwge1xuICAgICAgICB2aWV3LFxuICAgICAgICBkZXRhaWw6IHNhbml0aXplTnVtYmVyKGRldGFpbCAhPT0gbnVsbCAmJiBkZXRhaWwgIT09IHZvaWQgMCA/IGRldGFpbCA6IDApXG4gICAgfSk7XG59XG5mdW5jdGlvbiBpbml0VUlFdmVudE1vZGlmaWZpZXJzKGV2ZW50LCB7IGFsdEtleSAsIGN0cmxLZXkgLCBtZXRhS2V5ICwgc2hpZnRLZXkgLCBtb2RpZmllckFsdEdyYXBoICwgbW9kaWZpZXJDYXBzTG9jayAsIG1vZGlmaWVyRm4gLCBtb2RpZmllckZuTG9jayAsIG1vZGlmaWVyTnVtTG9jayAsIG1vZGlmaWVyU2Nyb2xsTG9jayAsIG1vZGlmaWVyU3ltYm9sICwgbW9kaWZpZXJTeW1ib2xMb2NrICB9KSB7XG4gICAgYXNzaWduUHJvcHMoZXZlbnQsIHtcbiAgICAgICAgYWx0S2V5OiBCb29sZWFuKGFsdEtleSksXG4gICAgICAgIGN0cmxLZXk6IEJvb2xlYW4oY3RybEtleSksXG4gICAgICAgIG1ldGFLZXk6IEJvb2xlYW4obWV0YUtleSksXG4gICAgICAgIHNoaWZ0S2V5OiBCb29sZWFuKHNoaWZ0S2V5KSxcbiAgICAgICAgZ2V0TW9kaWZpZXJTdGF0ZSAoaykge1xuICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4oe1xuICAgICAgICAgICAgICAgIEFsdDogYWx0S2V5LFxuICAgICAgICAgICAgICAgIEFsdEdyYXBoOiBtb2RpZmllckFsdEdyYXBoLFxuICAgICAgICAgICAgICAgIENhcHNMb2NrOiBtb2RpZmllckNhcHNMb2NrLFxuICAgICAgICAgICAgICAgIENvbnRyb2w6IGN0cmxLZXksXG4gICAgICAgICAgICAgICAgRm46IG1vZGlmaWVyRm4sXG4gICAgICAgICAgICAgICAgRm5Mb2NrOiBtb2RpZmllckZuTG9jayxcbiAgICAgICAgICAgICAgICBNZXRhOiBtZXRhS2V5LFxuICAgICAgICAgICAgICAgIE51bUxvY2s6IG1vZGlmaWVyTnVtTG9jayxcbiAgICAgICAgICAgICAgICBTY3JvbGxMb2NrOiBtb2RpZmllclNjcm9sbExvY2ssXG4gICAgICAgICAgICAgICAgU2hpZnQ6IHNoaWZ0S2V5LFxuICAgICAgICAgICAgICAgIFN5bWJvbDogbW9kaWZpZXJTeW1ib2wsXG4gICAgICAgICAgICAgICAgU3ltYm9sTG9jazogbW9kaWZpZXJTeW1ib2xMb2NrXG4gICAgICAgICAgICB9W2tdKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gaW5pdEtleWJvYXJkRXZlbnQoZXZlbnQsIHsga2V5ICwgY29kZSAsIGxvY2F0aW9uICwgcmVwZWF0ICwgaXNDb21wb3NpbmcgLCBjaGFyQ29kZSAgfSkge1xuICAgIGFzc2lnblByb3BzKGV2ZW50LCB7XG4gICAgICAgIGtleTogU3RyaW5nKGtleSksXG4gICAgICAgIGNvZGU6IFN0cmluZyhjb2RlKSxcbiAgICAgICAgbG9jYXRpb246IHNhbml0aXplTnVtYmVyKGxvY2F0aW9uKSxcbiAgICAgICAgcmVwZWF0OiBCb29sZWFuKHJlcGVhdCksXG4gICAgICAgIGlzQ29tcG9zaW5nOiBCb29sZWFuKGlzQ29tcG9zaW5nKSxcbiAgICAgICAgY2hhckNvZGVcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGluaXRNb3VzZUV2ZW50KGV2ZW50LCB7IHggLCB5ICwgc2NyZWVuWCAsIHNjcmVlblkgLCBjbGllbnRYID14ICwgY2xpZW50WSA9eSAsIGJ1dHRvbiAsIGJ1dHRvbnMgLCByZWxhdGVkVGFyZ2V0ICB9KSB7XG4gICAgYXNzaWduUHJvcHMoZXZlbnQsIHtcbiAgICAgICAgc2NyZWVuWDogc2FuaXRpemVOdW1iZXIoc2NyZWVuWCksXG4gICAgICAgIHNjcmVlblk6IHNhbml0aXplTnVtYmVyKHNjcmVlblkpLFxuICAgICAgICBjbGllbnRYOiBzYW5pdGl6ZU51bWJlcihjbGllbnRYKSxcbiAgICAgICAgeDogc2FuaXRpemVOdW1iZXIoY2xpZW50WCksXG4gICAgICAgIGNsaWVudFk6IHNhbml0aXplTnVtYmVyKGNsaWVudFkpLFxuICAgICAgICB5OiBzYW5pdGl6ZU51bWJlcihjbGllbnRZKSxcbiAgICAgICAgYnV0dG9uOiBzYW5pdGl6ZU51bWJlcihidXR0b24pLFxuICAgICAgICBidXR0b25zOiBzYW5pdGl6ZU51bWJlcihidXR0b25zKSxcbiAgICAgICAgcmVsYXRlZFRhcmdldFxuICAgIH0pO1xufVxuZnVuY3Rpb24gaW5pdFBvaW50ZXJFdmVudChldmVudCwgeyBwb2ludGVySWQgLCB3aWR0aCAsIGhlaWdodCAsIHByZXNzdXJlICwgdGFuZ2VudGlhbFByZXNzdXJlICwgdGlsdFggLCB0aWx0WSAsIHR3aXN0ICwgcG9pbnRlclR5cGUgLCBpc1ByaW1hcnkgIH0pIHtcbiAgICBhc3NpZ25Qcm9wcyhldmVudCwge1xuICAgICAgICBwb2ludGVySWQ6IHNhbml0aXplTnVtYmVyKHBvaW50ZXJJZCksXG4gICAgICAgIHdpZHRoOiBzYW5pdGl6ZU51bWJlcih3aWR0aCksXG4gICAgICAgIGhlaWdodDogc2FuaXRpemVOdW1iZXIoaGVpZ2h0KSxcbiAgICAgICAgcHJlc3N1cmU6IHNhbml0aXplTnVtYmVyKHByZXNzdXJlKSxcbiAgICAgICAgdGFuZ2VudGlhbFByZXNzdXJlOiBzYW5pdGl6ZU51bWJlcih0YW5nZW50aWFsUHJlc3N1cmUpLFxuICAgICAgICB0aWx0WDogc2FuaXRpemVOdW1iZXIodGlsdFgpLFxuICAgICAgICB0aWx0WTogc2FuaXRpemVOdW1iZXIodGlsdFkpLFxuICAgICAgICB0d2lzdDogc2FuaXRpemVOdW1iZXIodHdpc3QpLFxuICAgICAgICBwb2ludGVyVHlwZTogU3RyaW5nKHBvaW50ZXJUeXBlKSxcbiAgICAgICAgaXNQcmltYXJ5OiBCb29sZWFuKGlzUHJpbWFyeSlcbiAgICB9KTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlRXZlbnQgfTtcbiIsImltcG9ydCAnLi9iZWhhdmlvci9jbGljay5qcyc7XG5pbXBvcnQgJy4vYmVoYXZpb3IvY3V0LmpzJztcbmltcG9ydCAnLi9iZWhhdmlvci9rZXlkb3duLmpzJztcbmltcG9ydCAnLi9iZWhhdmlvci9rZXlwcmVzcy5qcyc7XG5pbXBvcnQgJy4vYmVoYXZpb3Iva2V5dXAuanMnO1xuaW1wb3J0ICcuL2JlaGF2aW9yL3Bhc3RlLmpzJztcbmltcG9ydCB7IGJlaGF2aW9yIH0gZnJvbSAnLi9iZWhhdmlvci9yZWdpc3RyeS5qcyc7XG5pbXBvcnQgeyB3cmFwRXZlbnQgfSBmcm9tICcuL3dyYXBFdmVudC5qcyc7XG5pbXBvcnQgeyBpc01vdXNlRXZlbnQsIGlzS2V5Ym9hcmRFdmVudCB9IGZyb20gJy4vZXZlbnRNYXAuanMnO1xuaW1wb3J0IHsgY3JlYXRlRXZlbnQgfSBmcm9tICcuL2NyZWF0ZUV2ZW50LmpzJztcblxuZnVuY3Rpb24gZGlzcGF0Y2hVSUV2ZW50KHRhcmdldCwgdHlwZSwgaW5pdCwgcHJldmVudERlZmF1bHQgPSBmYWxzZSkge1xuICAgIGlmIChpc01vdXNlRXZlbnQodHlwZSkgfHwgaXNLZXlib2FyZEV2ZW50KHR5cGUpKSB7XG4gICAgICAgIGluaXQgPSB7XG4gICAgICAgICAgICAuLi5pbml0LFxuICAgICAgICAgICAgLi4udGhpcy5zeXN0ZW0uZ2V0VUlFdmVudE1vZGlmaWVycygpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50ID0gY3JlYXRlRXZlbnQodHlwZSwgdGFyZ2V0LCBpbml0KTtcbiAgICByZXR1cm4gZGlzcGF0Y2hFdmVudC5jYWxsKHRoaXMsIHRhcmdldCwgZXZlbnQsIHByZXZlbnREZWZhdWx0KTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQodGFyZ2V0LCBldmVudCwgcHJldmVudERlZmF1bHQgPSBmYWxzZSkge1xuICAgIHZhciByZWY7XG4gICAgY29uc3QgdHlwZSA9IGV2ZW50LnR5cGU7XG4gICAgY29uc3QgYmVoYXZpb3JJbXBsZW1lbnRhdGlvbiA9IHByZXZlbnREZWZhdWx0ID8gKCk9Pnt9IDogKHJlZiA9IGJlaGF2aW9yW3R5cGVdKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZihldmVudCwgdGFyZ2V0LCB0aGlzKTtcbiAgICBpZiAoYmVoYXZpb3JJbXBsZW1lbnRhdGlvbikge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBsZXQgZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXZlbnQsICdkZWZhdWx0UHJldmVudGVkJywge1xuICAgICAgICAgICAgZ2V0OiAoKT0+ZGVmYXVsdFByZXZlbnRlZFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV2ZW50LCAncHJldmVudERlZmF1bHQnLCB7XG4gICAgICAgICAgICB2YWx1ZTogKCk9PntcbiAgICAgICAgICAgICAgICBkZWZhdWx0UHJldmVudGVkID0gZXZlbnQuY2FuY2VsYWJsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHdyYXBFdmVudCgoKT0+dGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZlbnQpKTtcbiAgICAgICAgaWYgKCFkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICBiZWhhdmlvckltcGxlbWVudGF0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFkZWZhdWx0UHJldmVudGVkO1xuICAgIH1cbiAgICByZXR1cm4gd3JhcEV2ZW50KCgpPT50YXJnZXQuZGlzcGF0Y2hFdmVudChldmVudCkpO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hET01FdmVudCh0YXJnZXQsIHR5cGUsIGluaXQpIHtcbiAgICBjb25zdCBldmVudCA9IGNyZWF0ZUV2ZW50KHR5cGUsIHRhcmdldCwgaW5pdCk7XG4gICAgd3JhcEV2ZW50KCgpPT50YXJnZXQuZGlzcGF0Y2hFdmVudChldmVudCkpO1xufVxuXG5leHBvcnQgeyBkaXNwYXRjaERPTUV2ZW50LCBkaXNwYXRjaEV2ZW50LCBkaXNwYXRjaFVJRXZlbnQgfTtcbiIsImltcG9ydCAnLi4vdXRpbHMvY2xpY2svaXNDbGlja2FibGVJbnB1dC5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2RhdGFUcmFuc2Zlci9DbGlwYm9hcmQuanMnO1xuaW1wb3J0ICcuLi91dGlscy9lZGl0L2lzRWRpdGFibGUuanMnO1xuaW1wb3J0ICcuLi91dGlscy9lZGl0L21heExlbmd0aC5qcyc7XG5pbXBvcnQgeyBpc0VsZW1lbnRUeXBlIH0gZnJvbSAnLi4vdXRpbHMvbWlzYy9pc0VsZW1lbnRUeXBlLmpzJztcbmltcG9ydCAnQHRlc3RpbmctbGlicmFyeS9kb20vZGlzdC9oZWxwZXJzLmpzJztcbmltcG9ydCAnLi4vdXRpbHMva2V5RGVmL3JlYWROZXh0RGVzY3JpcHRvci5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL21pc2MvbGV2ZWwuanMnO1xuaW1wb3J0ICcuLi9vcHRpb25zLmpzJztcbmltcG9ydCB7IHN0YXJ0VHJhY2tWYWx1ZSwgdHJhY2tPclNldFZhbHVlIH0gZnJvbSAnLi90cmFja1ZhbHVlLmpzJztcbmltcG9ydCB7IHNldFVJU2VsZWN0aW9uQ2xlYW4sIHNldFVJU2VsZWN0aW9uUmF3LCBnZXRVSVZhbHVlLCBzZXRVSVZhbHVlQ2xlYW4sIGlzVUlWYWx1ZSwgaXNVSVNlbGVjdGlvblN0YXJ0IH0gZnJvbSAnLi9VSS5qcyc7XG5cbmNvbnN0IEludGVyY2VwdG9yID0gU3ltYm9sKCdJbnRlcmNlcHRvciBmb3IgcHJvZ3JhbW1hdGljYWwgY2FsbHMnKTtcbmZ1bmN0aW9uIHByZXBhcmVJbnRlcmNlcHRvcihlbGVtZW50LCBwcm9wTmFtZSwgaW50ZXJjZXB0b3JJbXBsKSB7XG4gICAgY29uc3QgcHJvdG90eXBlRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZWxlbWVudC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3BOYW1lKTtcbiAgICBjb25zdCBvYmplY3REZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlbGVtZW50LCBwcm9wTmFtZSk7XG4gICAgY29uc3QgdGFyZ2V0ID0gKHByb3RvdHlwZURlc2NyaXB0b3IgPT09IG51bGwgfHwgcHJvdG90eXBlRGVzY3JpcHRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvdG90eXBlRGVzY3JpcHRvci5zZXQpID8gJ3NldCcgOiAndmFsdWUnO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqLyBpZiAodHlwZW9mIChwcm90b3R5cGVEZXNjcmlwdG9yID09PSBudWxsIHx8IHByb3RvdHlwZURlc2NyaXB0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3RvdHlwZURlc2NyaXB0b3JbdGFyZ2V0XSkgIT09ICdmdW5jdGlvbicgfHwgcHJvdG90eXBlRGVzY3JpcHRvclt0YXJnZXRdW0ludGVyY2VwdG9yXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVsZW1lbnQgJHtlbGVtZW50LnRhZ05hbWV9IGRvZXMgbm90IGltcGxlbWVudCBcIiR7U3RyaW5nKHByb3BOYW1lKX1cIi5gKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW50ZXJjZXB0KC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgeyBhcHBseU5hdGl2ZSA9ZmFsc2UgLCByZWFsQXJncyAsIHRoZW4gLCAgfSA9IGludGVyY2VwdG9ySW1wbC5jYWxsKHRoaXMsIC4uLmFyZ3MpO1xuICAgICAgICBjb25zdCByZWFsRnVuYyA9ICghYXBwbHlOYXRpdmUgJiYgb2JqZWN0RGVzY3JpcHRvciB8fCBwcm90b3R5cGVEZXNjcmlwdG9yKVt0YXJnZXRdO1xuICAgICAgICBpZiAodGFyZ2V0ID09PSAnc2V0Jykge1xuICAgICAgICAgICAgcmVhbEZ1bmMuY2FsbCh0aGlzLCByZWFsQXJncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWFsRnVuYy5jYWxsKHRoaXMsIC4uLnJlYWxBcmdzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGVuID09PSBudWxsIHx8IHRoZW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRoZW4oKTtcbiAgICB9XG4gICAgaW50ZXJjZXB0W0ludGVyY2VwdG9yXSA9IEludGVyY2VwdG9yO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCBwcm9wTmFtZSwge1xuICAgICAgICAuLi5vYmplY3REZXNjcmlwdG9yICE9PSBudWxsICYmIG9iamVjdERlc2NyaXB0b3IgIT09IHZvaWQgMCA/IG9iamVjdERlc2NyaXB0b3IgOiBwcm90b3R5cGVEZXNjcmlwdG9yLFxuICAgICAgICBbdGFyZ2V0XTogaW50ZXJjZXB0XG4gICAgfSk7XG59XG5mdW5jdGlvbiBwcmVwYXJlVmFsdWVJbnRlcmNlcHRvcihlbGVtZW50KSB7XG4gICAgcHJlcGFyZUludGVyY2VwdG9yKGVsZW1lbnQsICd2YWx1ZScsIGZ1bmN0aW9uIGludGVyY2VwdG9ySW1wbCh2KSB7XG4gICAgICAgIGNvbnN0IGlzVUkgPSBpc1VJVmFsdWUodik7XG4gICAgICAgIGlmIChpc1VJKSB7XG4gICAgICAgICAgICBzdGFydFRyYWNrVmFsdWUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFwcGx5TmF0aXZlOiAhIWlzVUksXG4gICAgICAgICAgICByZWFsQXJnczogc2FuaXRpemVWYWx1ZSh0aGlzLCB2KSxcbiAgICAgICAgICAgIHRoZW46IGlzVUkgPyB1bmRlZmluZWQgOiAoKT0+dHJhY2tPclNldFZhbHVlKHRoaXMsIFN0cmluZyh2KSlcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHNhbml0aXplVmFsdWUoZWxlbWVudCwgdikge1xuICAgIC8vIFdvcmthcm91bmQgZm9yIEpTRE9NXG4gICAgaWYgKGlzRWxlbWVudFR5cGUoZWxlbWVudCwgJ2lucHV0Jywge1xuICAgICAgICB0eXBlOiAnbnVtYmVyJ1xuICAgIH0pICYmIFN0cmluZyh2KSAhPT0gJycgJiYgIU51bWJlci5pc05hTihOdW1iZXIodikpKSB7XG4gICAgICAgIC8vIFNldHRpbmcgdmFsdWUgdG8gXCIxLlwiIHJlc3VsdHMgaW4gYG51bGxgIGluIEpTRE9NXG4gICAgICAgIHJldHVybiBTdHJpbmcoTnVtYmVyKHYpKTtcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZyh2KTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVTZWxlY3Rpb25JbnRlcmNlcHRvcihlbGVtZW50KSB7XG4gICAgcHJlcGFyZUludGVyY2VwdG9yKGVsZW1lbnQsICdzZXRTZWxlY3Rpb25SYW5nZScsIGZ1bmN0aW9uIGludGVyY2VwdG9ySW1wbChzdGFydCwgLi4ub3RoZXJzKSB7XG4gICAgICAgIGNvbnN0IGlzVUkgPSBpc1VJU2VsZWN0aW9uU3RhcnQoc3RhcnQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXBwbHlOYXRpdmU6ICEhaXNVSSxcbiAgICAgICAgICAgIHJlYWxBcmdzOiBbXG4gICAgICAgICAgICAgICAgTnVtYmVyKHN0YXJ0KSxcbiAgICAgICAgICAgICAgICAuLi5vdGhlcnNcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB0aGVuOiAoKT0+aXNVSSA/IHVuZGVmaW5lZCA6IHNldFVJU2VsZWN0aW9uQ2xlYW4oZWxlbWVudClcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBwcmVwYXJlSW50ZXJjZXB0b3IoZWxlbWVudCwgJ3NlbGVjdGlvblN0YXJ0JywgZnVuY3Rpb24gaW50ZXJjZXB0b3JJbXBsKHYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlYWxBcmdzOiB2LFxuICAgICAgICAgICAgdGhlbjogKCk9PnNldFVJU2VsZWN0aW9uQ2xlYW4oZWxlbWVudClcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBwcmVwYXJlSW50ZXJjZXB0b3IoZWxlbWVudCwgJ3NlbGVjdGlvbkVuZCcsIGZ1bmN0aW9uIGludGVyY2VwdG9ySW1wbCh2KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZWFsQXJnczogdixcbiAgICAgICAgICAgIHRoZW46ICgpPT5zZXRVSVNlbGVjdGlvbkNsZWFuKGVsZW1lbnQpXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcHJlcGFyZUludGVyY2VwdG9yKGVsZW1lbnQsICdzZWxlY3QnLCBmdW5jdGlvbiBpbnRlcmNlcHRvckltcGwoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZWFsQXJnczogW10sXG4gICAgICAgICAgICB0aGVuOiAoKT0+c2V0VUlTZWxlY3Rpb25SYXcoZWxlbWVudCwge1xuICAgICAgICAgICAgICAgICAgICBhbmNob3JPZmZzZXQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzT2Zmc2V0OiBnZXRVSVZhbHVlKGVsZW1lbnQpLmxlbmd0aFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfSk7XG59XG5mdW5jdGlvbiBwcmVwYXJlUmFuZ2VUZXh0SW50ZXJjZXB0b3IoZWxlbWVudCkge1xuICAgIHByZXBhcmVJbnRlcmNlcHRvcihlbGVtZW50LCAnc2V0UmFuZ2VUZXh0JywgZnVuY3Rpb24gaW50ZXJjZXB0b3JJbXBsKC4uLnJlYWxBcmdzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZWFsQXJncyxcbiAgICAgICAgICAgIHRoZW46ICgpPT57XG4gICAgICAgICAgICAgICAgc2V0VUlWYWx1ZUNsZWFuKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHNldFVJU2VsZWN0aW9uQ2xlYW4oZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IHByZXBhcmVJbnRlcmNlcHRvciwgcHJlcGFyZVJhbmdlVGV4dEludGVyY2VwdG9yLCBwcmVwYXJlU2VsZWN0aW9uSW50ZXJjZXB0b3IsIHByZXBhcmVWYWx1ZUludGVyY2VwdG9yIH07XG4iLCJpbXBvcnQgeyBkaXNwYXRjaERPTUV2ZW50IH0gZnJvbSAnLi4vZXZlbnQvZGlzcGF0Y2hFdmVudC5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2NsaWNrL2lzQ2xpY2thYmxlSW5wdXQuanMnO1xuaW1wb3J0ICcuLi91dGlscy9kYXRhVHJhbnNmZXIvQ2xpcGJvYXJkLmpzJztcbmltcG9ydCAnLi4vdXRpbHMvZWRpdC9pc0VkaXRhYmxlLmpzJztcbmltcG9ydCAnLi4vdXRpbHMvZWRpdC9tYXhMZW5ndGguanMnO1xuaW1wb3J0IHsgaXNFbGVtZW50VHlwZSB9IGZyb20gJy4uL3V0aWxzL21pc2MvaXNFbGVtZW50VHlwZS5qcyc7XG5pbXBvcnQgJ0B0ZXN0aW5nLWxpYnJhcnkvZG9tL2Rpc3QvaGVscGVycy5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2tleURlZi9yZWFkTmV4dERlc2NyaXB0b3IuanMnO1xuaW1wb3J0ICcuLi91dGlscy9taXNjL2xldmVsLmpzJztcbmltcG9ydCAnLi4vb3B0aW9ucy5qcyc7XG5pbXBvcnQgeyBnZXRJbml0aWFsVmFsdWUsIGNsZWFySW5pdGlhbFZhbHVlIH0gZnJvbSAnLi9VSS5qcyc7XG5pbXBvcnQgJ0B0ZXN0aW5nLWxpYnJhcnkvZG9tJztcbmltcG9ydCB7IHByZXBhcmVWYWx1ZUludGVyY2VwdG9yLCBwcmVwYXJlU2VsZWN0aW9uSW50ZXJjZXB0b3IsIHByZXBhcmVSYW5nZVRleHRJbnRlcmNlcHRvciB9IGZyb20gJy4vaW50ZXJjZXB0b3IuanMnO1xuXG5jb25zdCBpc1ByZXBhcmVkID0gU3ltYm9sKCdOb2RlIHByZXBhcmVkIHdpdGggZG9jdW1lbnQgc3RhdGUgd29ya2Fyb3VuZHMnKTtcbmZ1bmN0aW9uIHByZXBhcmVEb2N1bWVudChkb2N1bWVudCkge1xuICAgIGlmIChkb2N1bWVudFtpc1ByZXBhcmVkXSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgKGUpPT57XG4gICAgICAgIGNvbnN0IGVsID0gZS50YXJnZXQ7XG4gICAgICAgIHByZXBhcmVFbGVtZW50KGVsKTtcbiAgICB9LCB7XG4gICAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICAvLyBPdXIgdGVzdCBlbnZpcm9ubWVudCBkZWZhdWx0cyB0byBgZG9jdW1lbnQuYm9keWAgYXMgYGFjdGl2ZUVsZW1lbnRgLlxuICAgIC8vIEluIG90aGVyIGVudmlyb25tZW50cyB0aGlzIG1pZ2h0IGJlIGBudWxsYCB3aGVuIHByZXBhcmluZy5cbiAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgZWxzZVxuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgIHByZXBhcmVFbGVtZW50KGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xuICAgIH1cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgKGUpPT57XG4gICAgICAgIGNvbnN0IGVsID0gZS50YXJnZXQ7XG4gICAgICAgIGNvbnN0IGluaXRpYWxWYWx1ZSA9IGdldEluaXRpYWxWYWx1ZShlbCk7XG4gICAgICAgIGlmIChpbml0aWFsVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGVsLnZhbHVlICE9PSBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaERPTUV2ZW50KGVsLCAnY2hhbmdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGVhckluaXRpYWxWYWx1ZShlbCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICBkb2N1bWVudFtpc1ByZXBhcmVkXSA9IGlzUHJlcGFyZWQ7XG59XG5mdW5jdGlvbiBwcmVwYXJlRWxlbWVudChlbCkge1xuICAgIGlmIChlbFtpc1ByZXBhcmVkXSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc0VsZW1lbnRUeXBlKGVsLCBbXG4gICAgICAgICdpbnB1dCcsXG4gICAgICAgICd0ZXh0YXJlYSdcbiAgICBdKSkge1xuICAgICAgICBwcmVwYXJlVmFsdWVJbnRlcmNlcHRvcihlbCk7XG4gICAgICAgIHByZXBhcmVTZWxlY3Rpb25JbnRlcmNlcHRvcihlbCk7XG4gICAgICAgIHByZXBhcmVSYW5nZVRleHRJbnRlcmNlcHRvcihlbCk7XG4gICAgfVxuICAgIGVsW2lzUHJlcGFyZWRdID0gaXNQcmVwYXJlZDtcbn1cblxuZXhwb3J0IHsgcHJlcGFyZURvY3VtZW50IH07XG4iLCJmdW5jdGlvbiBnZXREb2N1bWVudEZyb21Ob2RlKGVsKSB7XG4gICAgcmV0dXJuIGlzRG9jdW1lbnQoZWwpID8gZWwgOiBlbC5vd25lckRvY3VtZW50O1xufVxuZnVuY3Rpb24gaXNEb2N1bWVudChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IDk7XG59XG5cbmV4cG9ydCB7IGdldERvY3VtZW50RnJvbU5vZGUgfTtcbiIsImZ1bmN0aW9uIHdhaXQoY29uZmlnKSB7XG4gICAgY29uc3QgZGVsYXkgPSBjb25maWcuZGVsYXk7XG4gICAgaWYgKHR5cGVvZiBkZWxheSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSk9Pmdsb2JhbFRoaXMuc2V0VGltZW91dCgoKT0+cmVzb2x2ZSgpLCBkZWxheSkpLFxuICAgICAgICBjb25maWcuYWR2YW5jZVRpbWVycyhkZWxheSksIFxuICAgIF0pO1xufVxuXG5leHBvcnQgeyB3YWl0IH07XG4iLCJpbXBvcnQgJy4uL3V0aWxzL2NsaWNrL2lzQ2xpY2thYmxlSW5wdXQuanMnO1xuaW1wb3J0ICcuLi91dGlscy9kYXRhVHJhbnNmZXIvQ2xpcGJvYXJkLmpzJztcbmltcG9ydCAnLi4vdXRpbHMvZWRpdC9pc0VkaXRhYmxlLmpzJztcbmltcG9ydCAnLi4vdXRpbHMvZWRpdC9tYXhMZW5ndGguanMnO1xuaW1wb3J0IHsgZ2V0QWN0aXZlRWxlbWVudE9yQm9keSB9IGZyb20gJy4uL3V0aWxzL2ZvY3VzL2dldEFjdGl2ZUVsZW1lbnQuanMnO1xuaW1wb3J0ICdAdGVzdGluZy1saWJyYXJ5L2RvbS9kaXN0L2hlbHBlcnMuanMnO1xuaW1wb3J0ICcuLi91dGlscy9rZXlEZWYvcmVhZE5leHREZXNjcmlwdG9yLmpzJztcbmltcG9ydCAnLi4vdXRpbHMvbWlzYy9sZXZlbC5qcyc7XG5pbXBvcnQgJy4uL29wdGlvbnMuanMnO1xuXG52YXIgX3ByZXNzZWQsIF9jb2RlLCBfY29kZTE7XG52YXIgRE9NX0tFWV9MT0NBVElPTjtcbihmdW5jdGlvbihET01fS0VZX0xPQ0FUSU9OKSB7XG4gICAgRE9NX0tFWV9MT0NBVElPTltET01fS0VZX0xPQ0FUSU9OW1wiU1RBTkRBUkRcIl0gPSAwXSA9IFwiU1RBTkRBUkRcIjtcbiAgICBET01fS0VZX0xPQ0FUSU9OW0RPTV9LRVlfTE9DQVRJT05bXCJMRUZUXCJdID0gMV0gPSBcIkxFRlRcIjtcbiAgICBET01fS0VZX0xPQ0FUSU9OW0RPTV9LRVlfTE9DQVRJT05bXCJSSUdIVFwiXSA9IDJdID0gXCJSSUdIVFwiO1xuICAgIERPTV9LRVlfTE9DQVRJT05bRE9NX0tFWV9MT0NBVElPTltcIk5VTVBBRFwiXSA9IDNdID0gXCJOVU1QQURcIjtcbn0pKERPTV9LRVlfTE9DQVRJT04gfHwgKERPTV9LRVlfTE9DQVRJT04gPSB7fSkpO1xuY29uc3QgbW9kaWZpZXJLZXlzID0gW1xuICAgICdBbHQnLFxuICAgICdBbHRHcmFwaCcsXG4gICAgJ0NvbnRyb2wnLFxuICAgICdGbicsXG4gICAgJ01ldGEnLFxuICAgICdTaGlmdCcsXG4gICAgJ1N5bWJvbCcsIFxuXTtcbmZ1bmN0aW9uIGlzTW9kaWZpZXJLZXkoa2V5KSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyS2V5cy5pbmNsdWRlcyhrZXkpO1xufVxuY29uc3QgbW9kaWZpZXJMb2NrcyA9IFtcbiAgICAnQ2Fwc0xvY2snLFxuICAgICdGbkxvY2snLFxuICAgICdOdW1Mb2NrJyxcbiAgICAnU2Nyb2xsTG9jaycsXG4gICAgJ1N5bWJvbExvY2snLCBcbl07XG5mdW5jdGlvbiBpc01vZGlmaWVyTG9jayhrZXkpIHtcbiAgICByZXR1cm4gbW9kaWZpZXJMb2Nrcy5pbmNsdWRlcyhrZXkpO1xufVxuY2xhc3MgS2V5Ym9hcmRIb3N0IHtcbiAgICBpc0tleVByZXNzZWQoa2V5RGVmKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMucHJlc3NlZFtTdHJpbmcoa2V5RGVmLmNvZGUpXTtcbiAgICB9XG4gICAgZ2V0UHJlc3NlZEtleXMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMucHJlc3NlZCkubWFwKChwKT0+cC5rZXlEZWYpO1xuICAgIH1cbiAgICAvKiogUHJlc3MgYSBrZXkgKi8gYXN5bmMga2V5ZG93bihpbnN0YW5jZSwga2V5RGVmKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IFN0cmluZyhrZXlEZWYua2V5KTtcbiAgICAgICAgY29uc3QgY29kZSA9IFN0cmluZyhrZXlEZWYuY29kZSk7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldEFjdGl2ZUVsZW1lbnRPckJvZHkoaW5zdGFuY2UuY29uZmlnLmRvY3VtZW50KTtcbiAgICAgICAgdGhpcy5zZXRLZXlkb3duVGFyZ2V0KHRhcmdldCk7XG4gICAgICAgIHZhciByZWY7XG4gICAgICAgIChyZWYgPSAoX3ByZXNzZWQgPSB0aGlzLnByZXNzZWQpW19jb2RlID0gY29kZV0pICE9PSBudWxsICYmIHJlZiAhPT0gdm9pZCAwID8gcmVmIDogX3ByZXNzZWRbX2NvZGVdID0ge1xuICAgICAgICAgICAga2V5RGVmLFxuICAgICAgICAgICAgdW5wcmV2ZW50ZWREZWZhdWx0OiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBpZiAoaXNNb2RpZmllcktleShrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmaWVyc1trZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1bnByZXZlbnRlZCA9IGluc3RhbmNlLmRpc3BhdGNoVUlFdmVudCh0YXJnZXQsICdrZXlkb3duJywge1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgY29kZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzTW9kaWZpZXJMb2NrKGtleSkgJiYgIXRoaXMubW9kaWZpZXJzW2tleV0pIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZpZXJzW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tb2RpZmllckxvY2tTdGFydFtrZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAoX2NvZGUxID0gdGhpcy5wcmVzc2VkW2NvZGVdKS51bnByZXZlbnRlZERlZmF1bHQgfHwgKF9jb2RlMS51bnByZXZlbnRlZERlZmF1bHQgPSB1bnByZXZlbnRlZCk7XG4gICAgICAgIGlmICh1bnByZXZlbnRlZCAmJiB0aGlzLmhhc0tleVByZXNzKGtleSkpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLmRpc3BhdGNoVUlFdmVudChnZXRBY3RpdmVFbGVtZW50T3JCb2R5KGluc3RhbmNlLmNvbmZpZy5kb2N1bWVudCksICdrZXlwcmVzcycsIHtcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgICAgICBjaGFyQ29kZToga2V5RGVmLmtleSA9PT0gJ0VudGVyJyA/IDEzIDogU3RyaW5nKGtleURlZi5rZXkpLmNoYXJDb2RlQXQoMClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBSZWxlYXNlIGEga2V5ICovIGFzeW5jIGtleXVwKGluc3RhbmNlLCBrZXlEZWYpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gU3RyaW5nKGtleURlZi5rZXkpO1xuICAgICAgICBjb25zdCBjb2RlID0gU3RyaW5nKGtleURlZi5jb2RlKTtcbiAgICAgICAgY29uc3QgdW5wcmV2ZW50ZWQgPSB0aGlzLnByZXNzZWRbY29kZV0udW5wcmV2ZW50ZWREZWZhdWx0O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWR5bmFtaWMtZGVsZXRlXG4gICAgICAgIGRlbGV0ZSB0aGlzLnByZXNzZWRbY29kZV07XG4gICAgICAgIGlmIChpc01vZGlmaWVyS2V5KGtleSkgJiYgIU9iamVjdC52YWx1ZXModGhpcy5wcmVzc2VkKS5maW5kKChwKT0+cC5rZXlEZWYua2V5ID09PSBrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmaWVyc1trZXldID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UuZGlzcGF0Y2hVSUV2ZW50KGdldEFjdGl2ZUVsZW1lbnRPckJvZHkoaW5zdGFuY2UuY29uZmlnLmRvY3VtZW50KSwgJ2tleXVwJywge1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgY29kZVxuICAgICAgICB9LCAhdW5wcmV2ZW50ZWQpO1xuICAgICAgICBpZiAoaXNNb2RpZmllckxvY2soa2V5KSAmJiB0aGlzLm1vZGlmaWVyc1trZXldKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tb2RpZmllckxvY2tTdGFydFtrZXldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZmllckxvY2tTdGFydFtrZXldID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZpZXJzW2tleV0gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRLZXlkb3duVGFyZ2V0KHRhcmdldCkge1xuICAgICAgICBpZiAodGFyZ2V0ICE9PSB0aGlzLmxhc3RLZXlkb3duVGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLmNhcnJ5Q2hhciA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdEtleWRvd25UYXJnZXQgPSB0YXJnZXQ7XG4gICAgfVxuICAgIGhhc0tleVByZXNzKGtleSkge1xuICAgICAgICByZXR1cm4gKGtleS5sZW5ndGggPT09IDEgfHwga2V5ID09PSAnRW50ZXInKSAmJiAhdGhpcy5tb2RpZmllcnMuQ29udHJvbCAmJiAhdGhpcy5tb2RpZmllcnMuQWx0O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihzeXN0ZW0pe1xuICAgICAgICB0aGlzLm1vZGlmaWVycyA9IHtcbiAgICAgICAgICAgIEFsdDogZmFsc2UsXG4gICAgICAgICAgICBBbHRHcmFwaDogZmFsc2UsXG4gICAgICAgICAgICBDYXBzTG9jazogZmFsc2UsXG4gICAgICAgICAgICBDb250cm9sOiBmYWxzZSxcbiAgICAgICAgICAgIEZuOiBmYWxzZSxcbiAgICAgICAgICAgIEZuTG9jazogZmFsc2UsXG4gICAgICAgICAgICBNZXRhOiBmYWxzZSxcbiAgICAgICAgICAgIE51bUxvY2s6IGZhbHNlLFxuICAgICAgICAgICAgU2Nyb2xsTG9jazogZmFsc2UsXG4gICAgICAgICAgICBTaGlmdDogZmFsc2UsXG4gICAgICAgICAgICBTeW1ib2w6IGZhbHNlLFxuICAgICAgICAgICAgU3ltYm9sTG9jazogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wcmVzc2VkID0ge307XG4gICAgICAgIHRoaXMuY2FycnlDaGFyID0gJyc7XG4gICAgICAgIHRoaXMubGFzdEtleWRvd25UYXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubW9kaWZpZXJMb2NrU3RhcnQgPSB7fTtcbiAgICAgICAgdGhpcy5zeXN0ZW0gPSBzeXN0ZW07XG4gICAgfVxufVxuXG5leHBvcnQgeyBET01fS0VZX0xPQ0FUSU9OLCBLZXlib2FyZEhvc3QgfTtcbiIsImltcG9ydCB7IERPTV9LRVlfTE9DQVRJT04gfSBmcm9tICcuLi9zeXN0ZW0va2V5Ym9hcmQuanMnO1xuXG4vKipcbiAqIE1hcHBpbmcgZm9yIGEgZGVmYXVsdCBVUy0xMDQtUVdFUlRZIGtleWJvYXJkXG4gKi8gY29uc3QgZGVmYXVsdEtleU1hcCA9IFtcbiAgICAvLyBhbHBoYW51bWVyaWMga2V5c1xuICAgIC4uLicwMTIzNDU2Nzg5Jy5zcGxpdCgnJykubWFwKChjKT0+KHtcbiAgICAgICAgICAgIGNvZGU6IGBEaWdpdCR7Y31gLFxuICAgICAgICAgICAga2V5OiBjXG4gICAgICAgIH0pKSxcbiAgICAuLi4nKSFAIyQlXiYqKCcuc3BsaXQoJycpLm1hcCgoYywgaSk9Pih7XG4gICAgICAgICAgICBjb2RlOiBgRGlnaXQke2l9YCxcbiAgICAgICAgICAgIGtleTogYyxcbiAgICAgICAgICAgIHNoaWZ0S2V5OiB0cnVlXG4gICAgICAgIH0pKSxcbiAgICAuLi4nYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonLnNwbGl0KCcnKS5tYXAoKGMpPT4oe1xuICAgICAgICAgICAgY29kZTogYEtleSR7Yy50b1VwcGVyQ2FzZSgpfWAsXG4gICAgICAgICAgICBrZXk6IGNcbiAgICAgICAgfSkpLFxuICAgIC4uLidBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWicuc3BsaXQoJycpLm1hcCgoYyk9Pih7XG4gICAgICAgICAgICBjb2RlOiBgS2V5JHtjfWAsXG4gICAgICAgICAgICBrZXk6IGMsXG4gICAgICAgICAgICBzaGlmdEtleTogdHJ1ZVxuICAgICAgICB9KSksXG4gICAgLy8gYWxwaGFudW1lcmljIGJsb2NrIC0gZnVuY3Rpb25hbFxuICAgIHtcbiAgICAgICAgY29kZTogJ1NwYWNlJyxcbiAgICAgICAga2V5OiAnICdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgY29kZTogJ0FsdExlZnQnLFxuICAgICAgICBrZXk6ICdBbHQnLFxuICAgICAgICBsb2NhdGlvbjogRE9NX0tFWV9MT0NBVElPTi5MRUZUXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGNvZGU6ICdBbHRSaWdodCcsXG4gICAgICAgIGtleTogJ0FsdCcsXG4gICAgICAgIGxvY2F0aW9uOiBET01fS0VZX0xPQ0FUSU9OLlJJR0hUXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGNvZGU6ICdTaGlmdExlZnQnLFxuICAgICAgICBrZXk6ICdTaGlmdCcsXG4gICAgICAgIGxvY2F0aW9uOiBET01fS0VZX0xPQ0FUSU9OLkxFRlRcbiAgICB9LFxuICAgIHtcbiAgICAgICAgY29kZTogJ1NoaWZ0UmlnaHQnLFxuICAgICAgICBrZXk6ICdTaGlmdCcsXG4gICAgICAgIGxvY2F0aW9uOiBET01fS0VZX0xPQ0FUSU9OLlJJR0hUXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGNvZGU6ICdDb250cm9sTGVmdCcsXG4gICAgICAgIGtleTogJ0NvbnRyb2wnLFxuICAgICAgICBsb2NhdGlvbjogRE9NX0tFWV9MT0NBVElPTi5MRUZUXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGNvZGU6ICdDb250cm9sUmlnaHQnLFxuICAgICAgICBrZXk6ICdDb250cm9sJyxcbiAgICAgICAgbG9jYXRpb246IERPTV9LRVlfTE9DQVRJT04uUklHSFRcbiAgICB9LFxuICAgIHtcbiAgICAgICAgY29kZTogJ01ldGFMZWZ0JyxcbiAgICAgICAga2V5OiAnTWV0YScsXG4gICAgICAgIGxvY2F0aW9uOiBET01fS0VZX0xPQ0FUSU9OLkxFRlRcbiAgICB9LFxuICAgIHtcbiAgICAgICAgY29kZTogJ01ldGFSaWdodCcsXG4gICAgICAgIGtleTogJ01ldGEnLFxuICAgICAgICBsb2NhdGlvbjogRE9NX0tFWV9MT0NBVElPTi5SSUdIVFxuICAgIH0sXG4gICAge1xuICAgICAgICBjb2RlOiAnT1NMZWZ0JyxcbiAgICAgICAga2V5OiAnT1MnLFxuICAgICAgICBsb2NhdGlvbjogRE9NX0tFWV9MT0NBVElPTi5MRUZUXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGNvZGU6ICdPU1JpZ2h0JyxcbiAgICAgICAga2V5OiAnT1MnLFxuICAgICAgICBsb2NhdGlvbjogRE9NX0tFWV9MT0NBVElPTi5SSUdIVFxuICAgIH0sXG4gICAge1xuICAgICAgICBjb2RlOiAnVGFiJyxcbiAgICAgICAga2V5OiAnVGFiJ1xuICAgIH0sXG4gICAge1xuICAgICAgICBjb2RlOiAnQ2Fwc0xvY2snLFxuICAgICAgICBrZXk6ICdDYXBzTG9jaydcbiAgICB9LFxuICAgIHtcbiAgICAgICAgY29kZTogJ0JhY2tzcGFjZScsXG4gICAgICAgIGtleTogJ0JhY2tzcGFjZSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgY29kZTogJ0VudGVyJyxcbiAgICAgICAga2V5OiAnRW50ZXInXG4gICAgfSxcbiAgICAvLyBmdW5jdGlvblxuICAgIHtcbiAgICAgICAgY29kZTogJ0VzY2FwZScsXG4gICAgICAgIGtleTogJ0VzY2FwZSdcbiAgICB9LFxuICAgIC8vIGFycm93c1xuICAgIHtcbiAgICAgICAgY29kZTogJ0Fycm93VXAnLFxuICAgICAgICBrZXk6ICdBcnJvd1VwJ1xuICAgIH0sXG4gICAge1xuICAgICAgICBjb2RlOiAnQXJyb3dEb3duJyxcbiAgICAgICAga2V5OiAnQXJyb3dEb3duJ1xuICAgIH0sXG4gICAge1xuICAgICAgICBjb2RlOiAnQXJyb3dMZWZ0JyxcbiAgICAgICAga2V5OiAnQXJyb3dMZWZ0J1xuICAgIH0sXG4gICAge1xuICAgICAgICBjb2RlOiAnQXJyb3dSaWdodCcsXG4gICAgICAgIGtleTogJ0Fycm93UmlnaHQnXG4gICAgfSxcbiAgICAvLyBjb250cm9sIHBhZFxuICAgIHtcbiAgICAgICAgY29kZTogJ0hvbWUnLFxuICAgICAgICBrZXk6ICdIb21lJ1xuICAgIH0sXG4gICAge1xuICAgICAgICBjb2RlOiAnRW5kJyxcbiAgICAgICAga2V5OiAnRW5kJ1xuICAgIH0sXG4gICAge1xuICAgICAgICBjb2RlOiAnRGVsZXRlJyxcbiAgICAgICAga2V5OiAnRGVsZXRlJ1xuICAgIH0sXG4gICAge1xuICAgICAgICBjb2RlOiAnUGFnZVVwJyxcbiAgICAgICAga2V5OiAnUGFnZVVwJ1xuICAgIH0sXG4gICAge1xuICAgICAgICBjb2RlOiAnUGFnZURvd24nLFxuICAgICAgICBrZXk6ICdQYWdlRG93bidcbiAgICB9LFxuICAgIC8vIFNwZWNpYWwga2V5cyB0aGF0IGFyZSBub3QgcGFydCBvZiBhIGRlZmF1bHQgVVMtbGF5b3V0IGJ1dCBpbmNsdWRlZCBmb3Igc3BlY2lmaWMgYmVoYXZpb3JcbiAgICB7XG4gICAgICAgIGNvZGU6ICdGbicsXG4gICAgICAgIGtleTogJ0ZuJ1xuICAgIH0sXG4gICAge1xuICAgICAgICBjb2RlOiAnU3ltYm9sJyxcbiAgICAgICAga2V5OiAnU3ltYm9sJ1xuICAgIH0sXG4gICAge1xuICAgICAgICBjb2RlOiAnQWx0UmlnaHQnLFxuICAgICAgICBrZXk6ICdBbHRHcmFwaCdcbiAgICB9XG5dO1xuXG5leHBvcnQgeyBkZWZhdWx0S2V5TWFwIH07XG4iLCJjb25zdCBkZWZhdWx0S2V5TWFwID0gW1xuICAgIHtcbiAgICAgICAgbmFtZTogJ01vdXNlTGVmdCcsXG4gICAgICAgIHBvaW50ZXJUeXBlOiAnbW91c2UnLFxuICAgICAgICBidXR0b246ICdwcmltYXJ5J1xuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnTW91c2VSaWdodCcsXG4gICAgICAgIHBvaW50ZXJUeXBlOiAnbW91c2UnLFxuICAgICAgICBidXR0b246ICdzZWNvbmRhcnknXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdNb3VzZU1pZGRsZScsXG4gICAgICAgIHBvaW50ZXJUeXBlOiAnbW91c2UnLFxuICAgICAgICBidXR0b246ICdhdXhpbGlhcnknXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdUb3VjaEEnLFxuICAgICAgICBwb2ludGVyVHlwZTogJ3RvdWNoJ1xuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnVG91Y2hCJyxcbiAgICAgICAgcG9pbnRlclR5cGU6ICd0b3VjaCdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ1RvdWNoQycsXG4gICAgICAgIHBvaW50ZXJUeXBlOiAndG91Y2gnXG4gICAgfSwgXG5dO1xuXG5leHBvcnQgeyBkZWZhdWx0S2V5TWFwIH07XG4iLCJjbGFzcyBCdXR0b25zIHtcbiAgICBnZXRCdXR0b25zKCkge1xuICAgICAgICBsZXQgdiA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgYnV0dG9uIG9mIE9iamVjdC5rZXlzKHRoaXMucHJlc3NlZCkpe1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgICAgIHYgfD0gMiAqKiBOdW1iZXIoYnV0dG9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgZG93bihrZXlEZWYpIHtcbiAgICAgICAgY29uc3QgYnV0dG9uID0gZ2V0TW91c2VCdXR0b25JZChrZXlEZWYuYnV0dG9uKTtcbiAgICAgICAgaWYgKGJ1dHRvbiBpbiB0aGlzLnByZXNzZWQpIHtcbiAgICAgICAgICAgIHRoaXMucHJlc3NlZFtidXR0b25dLnB1c2goa2V5RGVmKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVzc2VkW2J1dHRvbl0gPSBbXG4gICAgICAgICAgICBrZXlEZWZcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICB9XG4gICAgdXAoa2V5RGVmKSB7XG4gICAgICAgIGNvbnN0IGJ1dHRvbiA9IGdldE1vdXNlQnV0dG9uSWQoa2V5RGVmLmJ1dHRvbik7XG4gICAgICAgIGlmIChidXR0b24gaW4gdGhpcy5wcmVzc2VkKSB7XG4gICAgICAgICAgICB0aGlzLnByZXNzZWRbYnV0dG9uXSA9IHRoaXMucHJlc3NlZFtidXR0b25dLmZpbHRlcigoayk9PmsubmFtZSAhPT0ga2V5RGVmLm5hbWUpO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJlc3NlZFtidXR0b25dLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZHluYW1pYy1kZWxldGVcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5wcmVzc2VkW2J1dHRvbl07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLnByZXNzZWQgPSB7fTtcbiAgICB9XG59XG5jb25zdCBNb3VzZUJ1dHRvbiA9IHtcbiAgICBwcmltYXJ5OiAwLFxuICAgIHNlY29uZGFyeTogMSxcbiAgICBhdXhpbGlhcnk6IDIsXG4gICAgYmFjazogMyxcbiAgICBYMTogMyxcbiAgICBmb3J3YXJkOiA0LFxuICAgIFgyOiA0XG59O1xuZnVuY3Rpb24gZ2V0TW91c2VCdXR0b25JZChidXR0b24gPSAwKSB7XG4gICAgaWYgKGJ1dHRvbiBpbiBNb3VzZUJ1dHRvbikge1xuICAgICAgICByZXR1cm4gTW91c2VCdXR0b25bYnV0dG9uXTtcbiAgICB9XG4gICAgcmV0dXJuIE51bWJlcihidXR0b24pO1xufVxuLy8gT24gdGhlIGBNb3VzZUV2ZW50LmJ1dHRvbmAgcHJvcGVydHkgYXV4aWxpYXJ5IGFuZCBzZWNvbmRhcnkgYnV0dG9uIGFyZSBmbGlwcGVkIGNvbXBhcmVkIHRvIGBNb3VzZUV2ZW50LmJ1dHRvbnNgLlxuY29uc3QgTW91c2VCdXR0b25GbGlwID0ge1xuICAgIDE6IDIsXG4gICAgMjogMVxufTtcbmZ1bmN0aW9uIGdldE1vdXNlRXZlbnRCdXR0b24oYnV0dG9uKSB7XG4gICAgYnV0dG9uID0gZ2V0TW91c2VCdXR0b25JZChidXR0b24pO1xuICAgIGlmIChidXR0b24gaW4gTW91c2VCdXR0b25GbGlwKSB7XG4gICAgICAgIHJldHVybiBNb3VzZUJ1dHRvbkZsaXBbYnV0dG9uXTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1dHRvbjtcbn1cblxuZXhwb3J0IHsgQnV0dG9ucywgTW91c2VCdXR0b24sIE1vdXNlQnV0dG9uRmxpcCwgZ2V0TW91c2VCdXR0b25JZCwgZ2V0TW91c2VFdmVudEJ1dHRvbiB9O1xuIiwiY2xhc3MgRGV2aWNlIHtcbiAgICBnZXQgY291bnRQcmVzc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmVzc2VkS2V5cy5zaXplO1xuICAgIH1cbiAgICBpc1ByZXNzZWQoa2V5RGVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXNzZWRLZXlzLmhhcyhrZXlEZWYubmFtZSk7XG4gICAgfVxuICAgIGFkZFByZXNzZWQoa2V5RGVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXNzZWRLZXlzLmFkZChrZXlEZWYubmFtZSk7XG4gICAgfVxuICAgIHJlbW92ZVByZXNzZWQoa2V5RGVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXNzZWRLZXlzLmRlbGV0ZShrZXlEZWYubmFtZSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMucHJlc3NlZEtleXMgPSBuZXcgU2V0KCk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBEZXZpY2UgfTtcbiIsImZ1bmN0aW9uIGdldFRyZWVEaWZmKGEsIGIpIHtcbiAgICBjb25zdCB0cmVlQSA9IFtdO1xuICAgIGZvcihsZXQgZWwgPSBhOyBlbDsgZWwgPSBlbC5wYXJlbnRFbGVtZW50KXtcbiAgICAgICAgdHJlZUEucHVzaChlbCk7XG4gICAgfVxuICAgIGNvbnN0IHRyZWVCID0gW107XG4gICAgZm9yKGxldCBlbDEgPSBiOyBlbDE7IGVsMSA9IGVsMS5wYXJlbnRFbGVtZW50KXtcbiAgICAgICAgdHJlZUIucHVzaChlbDEpO1xuICAgIH1cbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yKDs7IGkrKyl7XG4gICAgICAgIGlmIChpID49IHRyZWVBLmxlbmd0aCB8fCBpID49IHRyZWVCLmxlbmd0aCB8fCB0cmVlQVt0cmVlQS5sZW5ndGggLSAxIC0gaV0gIT09IHRyZWVCW3RyZWVCLmxlbmd0aCAtIDEgLSBpXSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgICAgdHJlZUEuc2xpY2UoMCwgdHJlZUEubGVuZ3RoIC0gaSksXG4gICAgICAgIHRyZWVCLnNsaWNlKDAsIHRyZWVCLmxlbmd0aCAtIGkpLFxuICAgICAgICB0cmVlQi5zbGljZSh0cmVlQi5sZW5ndGggLSBpKSwgXG4gICAgXTtcbn1cblxuZXhwb3J0IHsgZ2V0VHJlZURpZmYgfTtcbiIsImltcG9ydCB7IGdldFVJVmFsdWUgfSBmcm9tICcuLi8uLi9kb2N1bWVudC9VSS5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2NsaWNrL2lzQ2xpY2thYmxlSW5wdXQuanMnO1xuaW1wb3J0ICcuLi8uLi91dGlscy9kYXRhVHJhbnNmZXIvQ2xpcGJvYXJkLmpzJztcbmltcG9ydCAnLi4vLi4vdXRpbHMvZWRpdC9pc0VkaXRhYmxlLmpzJztcbmltcG9ydCAnLi4vLi4vdXRpbHMvZWRpdC9tYXhMZW5ndGguanMnO1xuaW1wb3J0ICdAdGVzdGluZy1saWJyYXJ5L2RvbS9kaXN0L2hlbHBlcnMuanMnO1xuaW1wb3J0IHsgaGFzT3duU2VsZWN0aW9uIH0gZnJvbSAnLi4vLi4vdXRpbHMvZm9jdXMvc2VsZWN0aW9uLmpzJztcbmltcG9ydCAnLi4vLi4vdXRpbHMva2V5RGVmL3JlYWROZXh0RGVzY3JpcHRvci5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL21pc2MvbGV2ZWwuanMnO1xuaW1wb3J0ICcuLi8uLi9vcHRpb25zLmpzJztcblxuZnVuY3Rpb24gcmVzb2x2ZUNhcmV0UG9zaXRpb24oeyB0YXJnZXQgLCBub2RlICwgb2Zmc2V0ICB9KSB7XG4gICAgaWYgKGhhc093blNlbGVjdGlvbih0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlOiB0YXJnZXQsXG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCAhPT0gbnVsbCAmJiBvZmZzZXQgIT09IHZvaWQgMCA/IG9mZnNldCA6IGdldFVJVmFsdWUodGFyZ2V0KS5sZW5ndGhcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCAhPT0gbnVsbCAmJiBvZmZzZXQgIT09IHZvaWQgMCA/IG9mZnNldCA6IG5vZGUubm9kZVR5cGUgPT09IDMgPyBub2RlLm5vZGVWYWx1ZS5sZW5ndGggOiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmaW5kTm9kZUF0VGV4dE9mZnNldCh0YXJnZXQsIG9mZnNldCk7XG59XG5mdW5jdGlvbiBmaW5kTm9kZUF0VGV4dE9mZnNldChub2RlLCBvZmZzZXQsIGlzUm9vdCA9IHRydWUpIHtcbiAgICAvLyBXaGVuIGNsaWNraW5nIGFmdGVyIHRoZSBjb250ZW50IHRoZSBicm93c2VyIGJlaGF2aW9yIGNhbiBiZSBjb21wbGljYXRlZDpcbiAgICAvLyAxLiBJZiB0aGVyZSBpcyB0ZXh0Q29udGVudCBhZnRlciB0aGUgbGFzdCBlbGVtZW50IGNoaWxkLFxuICAgIC8vIHRoZSBjdXJzb3IgaXMgbW92ZWQgdGhlcmUuXG4gICAgLy8gMi4gSWYgdGhlcmUgaXMgdGV4dENvbnRlbnQgaW4gdGhlIGxhc3QgZWxlbWVudCBjaGlsZCxcbiAgICAvLyB0aGUgYnJvd3NlciBtb3ZlcyB0aGUgY3Vyc29yIHRvIHRoZSBsYXN0IG5vbi1lbXB0eSB0ZXh0IG5vZGUgaW5zaWRlIHRoaXMgZWxlbWVudC5cbiAgICAvLyAzLiBPdGhlcndpc2UgdGhlIGN1cnNvciBpcyBtb3ZlZCB0byB0aGUgZW5kIG9mIHRoZSB0YXJnZXQuXG4gICAgbGV0IGkgPSBvZmZzZXQgPT09IHVuZGVmaW5lZCA/IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggLSAxIDogMDtcbiAgICBjb25zdCBzdGVwID0gb2Zmc2V0ID09PSB1bmRlZmluZWQgPyAtMSA6ICsxO1xuICAgIHdoaWxlKG9mZnNldCA9PT0gdW5kZWZpbmVkID8gaSA+PSAoaXNSb290ID8gTWF0aC5tYXgobm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDEsIDApIDogMCkgOiBpIDw9IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpe1xuICAgICAgICBpZiAob2Zmc2V0ICYmIGkgPT09IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGdpdmVuIG9mZnNldCBpcyBvdXQgb2YgYm91bmRzLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGMgPSBub2RlLmNoaWxkTm9kZXMuaXRlbShpKTtcbiAgICAgICAgY29uc3QgdGV4dCA9IFN0cmluZyhjLnRleHRDb250ZW50KTtcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgdGV4dC5sZW5ndGggPCBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgLT0gdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGMubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmluZE5vZGVBdFRleHRPZmZzZXQoYywgb2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBwcmUtY29tbWl0IGhvb2tzIGtlZXBzIGNoYW5naW5nIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2tlbnRjZG9kZHMva2NkLXNjcmlwdHMvaXNzdWVzLzIxOFxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lbHktaWZcbiAgICAgICAgICAgICAgICBpZiAoYy5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTogYyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0ICE9PSBudWxsICYmIG9mZnNldCAhPT0gdm9pZCAwID8gb2Zmc2V0IDogYy5ub2RlVmFsdWUubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGkgKz0gc3RlcDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZSxcbiAgICAgICAgb2Zmc2V0OiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoXG4gICAgfTtcbn1cblxuZXhwb3J0IHsgcmVzb2x2ZUNhcmV0UG9zaXRpb24gfTtcbiIsImltcG9ydCB7IGdldFVJVmFsdWUsIHNldFVJU2VsZWN0aW9uIH0gZnJvbSAnLi4vLi4vZG9jdW1lbnQvVUkuanMnO1xuaW1wb3J0ICcuLi8uLi91dGlscy9jbGljay9pc0NsaWNrYWJsZUlucHV0LmpzJztcbmltcG9ydCAnLi4vLi4vdXRpbHMvZGF0YVRyYW5zZmVyL0NsaXBib2FyZC5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2VkaXQvaXNFZGl0YWJsZS5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2VkaXQvbWF4TGVuZ3RoLmpzJztcbmltcG9ydCAnQHRlc3RpbmctbGlicmFyeS9kb20vZGlzdC9oZWxwZXJzLmpzJztcbmltcG9ydCB7IGhhc05vU2VsZWN0aW9uLCBoYXNPd25TZWxlY3Rpb24gfSBmcm9tICcuLi8uLi91dGlscy9mb2N1cy9zZWxlY3Rpb24uanMnO1xuaW1wb3J0ICcuLi8uLi91dGlscy9rZXlEZWYvcmVhZE5leHREZXNjcmlwdG9yLmpzJztcbmltcG9ydCAnLi4vLi4vdXRpbHMvbWlzYy9sZXZlbC5qcyc7XG5pbXBvcnQgJy4uLy4uL29wdGlvbnMuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUNhcmV0UG9zaXRpb24gfSBmcm9tICcuL3Jlc29sdmVDYXJldFBvc2l0aW9uLmpzJztcblxuZnVuY3Rpb24gc2V0U2VsZWN0aW9uUGVyTW91c2VEb3duKHsgZG9jdW1lbnQgLCB0YXJnZXQgLCBjbGlja0NvdW50ICwgbm9kZSAsIG9mZnNldCAgfSkge1xuICAgIGlmIChoYXNOb1NlbGVjdGlvbih0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0SGFzT3duU2VsZWN0aW9uID0gaGFzT3duU2VsZWN0aW9uKHRhcmdldCk7XG4gICAgLy8gT24gbm9uLWlucHV0IGVsZW1lbnRzIHRoZSB0ZXh0IHNlbGVjdGlvbiBwZXIgbXVsdGlwbGUgY2xpY2tcbiAgICAvLyBjYW4gZXh0ZW5kIGJleW9uZCB0aGUgdGFyZ2V0IGJvdW5kYXJpZXMuXG4gICAgLy8gVGhlIGV4YWN0IG1lY2hhbmlzbSB3aGF0IGlzIGNvbnNpZGVyZWQgaW4gdGhlIHNhbWUgbGluZSBpcyB1bmNsZWFyLlxuICAgIC8vIExvb2tzIGl0IG1pZ2h0IGJlIGV2ZXJ5IGlubGluZSBlbGVtZW50LlxuICAgIC8vIFRPRE86IENoZWNrIHdoYXQgbWlnaHQgYmUgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBzYW1lIGxpbmUgb2YgdGV4dC5cbiAgICBjb25zdCB0ZXh0ID0gU3RyaW5nKHRhcmdldEhhc093blNlbGVjdGlvbiA/IGdldFVJVmFsdWUodGFyZ2V0KSA6IHRhcmdldC50ZXh0Q29udGVudCk7XG4gICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gbm9kZSA/IC8vIHdoaWNoIGVsZW1lbnRzIG1pZ2h0IGJlIGNvbnNpZGVyZWQgaW4gdGhlIHNhbWUgbGluZSBvZiB0ZXh0LlxuICAgIC8vIFRPRE86IHN1cHBvcnQgZXhwYW5kaW5nIGluaXRpYWwgcmFuZ2Ugb24gbXVsdGlwbGUgY2xpY2tzIGlmIG5vZGUgaXMgZ2l2ZW5cbiAgICBbXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgb2Zmc2V0XG4gICAgXSA6IGdldFRleHRSYW5nZSh0ZXh0LCBvZmZzZXQsIGNsaWNrQ291bnQpO1xuICAgIC8vIFRPRE86IGltcGxlbWVudCBtb2RpZnlpbmcgc2VsZWN0aW9uIHBlciBzaGlmdC9jdHJsK21vdXNlXG4gICAgaWYgKHRhcmdldEhhc093blNlbGVjdGlvbikge1xuICAgICAgICBzZXRVSVNlbGVjdGlvbih0YXJnZXQsIHtcbiAgICAgICAgICAgIGFuY2hvck9mZnNldDogc3RhcnQgIT09IG51bGwgJiYgc3RhcnQgIT09IHZvaWQgMCA/IHN0YXJ0IDogdGV4dC5sZW5ndGgsXG4gICAgICAgICAgICBmb2N1c09mZnNldDogZW5kICE9PSBudWxsICYmIGVuZCAhPT0gdm9pZCAwID8gZW5kIDogdGV4dC5sZW5ndGhcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlOiB0YXJnZXQsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQgIT09IG51bGwgJiYgc3RhcnQgIT09IHZvaWQgMCA/IHN0YXJ0IDogMCxcbiAgICAgICAgICAgIGVuZDogZW5kICE9PSBudWxsICYmIGVuZCAhPT0gdm9pZCAwID8gZW5kIDogdGV4dC5sZW5ndGhcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7IG5vZGU6IHN0YXJ0Tm9kZSAsIG9mZnNldDogc3RhcnRPZmZzZXQgIH0gPSByZXNvbHZlQ2FyZXRQb3NpdGlvbih7XG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgb2Zmc2V0OiBzdGFydFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyBub2RlOiBlbmROb2RlICwgb2Zmc2V0OiBlbmRPZmZzZXQgIH0gPSByZXNvbHZlQ2FyZXRQb3NpdGlvbih7XG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgb2Zmc2V0OiBlbmRcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gdGFyZ2V0Lm93bmVyRG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KHN0YXJ0Tm9kZSwgc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKGVuZE5vZGUsIGVuZE9mZnNldCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGdpdmVuIG9mZnNldCBpcyBvdXQgb2YgYm91bmRzLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgICAgICBzZWxlY3Rpb24gPT09IG51bGwgfHwgc2VsZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgIHNlbGVjdGlvbiA9PT0gbnVsbCB8fCBzZWxlY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZS5jbG9uZVJhbmdlKCkpO1xuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0VGV4dFJhbmdlKHRleHQsIHBvcywgY2xpY2tDb3VudCkge1xuICAgIGlmIChjbGlja0NvdW50ICUgMyA9PT0gMSB8fCB0ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgcG9zXG4gICAgICAgIF07XG4gICAgfVxuICAgIGNvbnN0IHRleHRQb3MgPSBwb3MgIT09IG51bGwgJiYgcG9zICE9PSB2b2lkIDAgPyBwb3MgOiB0ZXh0Lmxlbmd0aDtcbiAgICBpZiAoY2xpY2tDb3VudCAlIDMgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRleHRQb3MgLSB0ZXh0LnN1YnN0cigwLCBwb3MpLm1hdGNoKC8oXFx3K3xcXHMrfFxcVyk/JC8pWzBdLmxlbmd0aCxcbiAgICAgICAgICAgIHBvcyA9PT0gdW5kZWZpbmVkID8gcG9zIDogcG9zICsgdGV4dC5zdWJzdHIocG9zKS5tYXRjaCgvXihcXHcrfFxccyt8XFxXKT8vKVswXS5sZW5ndGgsIFxuICAgICAgICBdO1xuICAgIH1cbiAgICAvLyB0cmlwbGUgY2xpY2tcbiAgICByZXR1cm4gW1xuICAgICAgICB0ZXh0UG9zIC0gdGV4dC5zdWJzdHIoMCwgcG9zKS5tYXRjaCgvW15cXHJcXG5dKiQvKVswXS5sZW5ndGgsXG4gICAgICAgIHBvcyA9PT0gdW5kZWZpbmVkID8gcG9zIDogcG9zICsgdGV4dC5zdWJzdHIocG9zKS5tYXRjaCgvXlteXFxyXFxuXSovKVswXS5sZW5ndGgsIFxuICAgIF07XG59XG5cbmV4cG9ydCB7IHNldFNlbGVjdGlvblBlck1vdXNlRG93biB9O1xuIiwiaW1wb3J0IHsgc2V0VUlTZWxlY3Rpb24gfSBmcm9tICcuLi8uLi9kb2N1bWVudC9VSS5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2NsaWNrL2lzQ2xpY2thYmxlSW5wdXQuanMnO1xuaW1wb3J0ICcuLi8uLi91dGlscy9kYXRhVHJhbnNmZXIvQ2xpcGJvYXJkLmpzJztcbmltcG9ydCAnLi4vLi4vdXRpbHMvZWRpdC9pc0VkaXRhYmxlLmpzJztcbmltcG9ydCAnLi4vLi4vdXRpbHMvZWRpdC9tYXhMZW5ndGguanMnO1xuaW1wb3J0ICdAdGVzdGluZy1saWJyYXJ5L2RvbS9kaXN0L2hlbHBlcnMuanMnO1xuaW1wb3J0ICcuLi8uLi91dGlscy9rZXlEZWYvcmVhZE5leHREZXNjcmlwdG9yLmpzJztcbmltcG9ydCAnLi4vLi4vdXRpbHMvbWlzYy9sZXZlbC5qcyc7XG5pbXBvcnQgJy4uLy4uL29wdGlvbnMuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUNhcmV0UG9zaXRpb24gfSBmcm9tICcuL3Jlc29sdmVDYXJldFBvc2l0aW9uLmpzJztcblxuZnVuY3Rpb24gbW9kaWZ5U2VsZWN0aW9uUGVyTW91c2VNb3ZlKHNlbGVjdGlvblJhbmdlLCB7IGRvY3VtZW50ICwgdGFyZ2V0ICwgbm9kZSAsIG9mZnNldCAgfSkge1xuICAgIGNvbnN0IHNlbGVjdGlvbkZvY3VzID0gcmVzb2x2ZUNhcmV0UG9zaXRpb24oe1xuICAgICAgICB0YXJnZXQsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIG9mZnNldFxuICAgIH0pO1xuICAgIGlmICgnbm9kZScgaW4gc2VsZWN0aW9uUmFuZ2UpIHtcbiAgICAgICAgLy8gV2hlbiB0aGUgbW91c2UgaXMgZHJhZ2dlZCBvdXRzaWRlIG9mIGFuIGlucHV0L3RleHRhcmVhLFxuICAgICAgICAvLyB0aGUgc2VsZWN0aW9uIGlzIGV4dGVuZGVkIHRvIHRoZSBiZWdpbm5pbmcgb3IgZW5kIG9mIHRoZSBpbnB1dFxuICAgICAgICAvLyBkZXBlbmRpbmcgb24gcG9pbnRlciBwb3NpdGlvbi5cbiAgICAgICAgLy8gVE9ETzogZXh0ZW5kIHNlbGVjdGlvbiBhY2NvcmRpbmcgdG8gcG9pbnRlciBwb3NpdGlvblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqLyBpZiAoc2VsZWN0aW9uRm9jdXMubm9kZSA9PT0gc2VsZWN0aW9uUmFuZ2Uubm9kZSkge1xuICAgICAgICAgICAgY29uc3QgYW5jaG9yT2Zmc2V0ID0gc2VsZWN0aW9uRm9jdXMub2Zmc2V0IDwgc2VsZWN0aW9uUmFuZ2Uuc3RhcnQgPyBzZWxlY3Rpb25SYW5nZS5lbmQgOiBzZWxlY3Rpb25SYW5nZS5zdGFydDtcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzT2Zmc2V0ID0gc2VsZWN0aW9uRm9jdXMub2Zmc2V0ID4gc2VsZWN0aW9uUmFuZ2UuZW5kIHx8IHNlbGVjdGlvbkZvY3VzLm9mZnNldCA8IHNlbGVjdGlvblJhbmdlLnN0YXJ0ID8gc2VsZWN0aW9uRm9jdXMub2Zmc2V0IDogc2VsZWN0aW9uUmFuZ2UuZW5kO1xuICAgICAgICAgICAgc2V0VUlTZWxlY3Rpb24oc2VsZWN0aW9uUmFuZ2Uubm9kZSwge1xuICAgICAgICAgICAgICAgIGFuY2hvck9mZnNldCxcbiAgICAgICAgICAgICAgICBmb2N1c09mZnNldFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCByYW5nZSA9IHNlbGVjdGlvblJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgICAgICAgY29uc3QgY21wID0gcmFuZ2UuY29tcGFyZVBvaW50KHNlbGVjdGlvbkZvY3VzLm5vZGUsIHNlbGVjdGlvbkZvY3VzLm9mZnNldCk7XG4gICAgICAgIGlmIChjbXAgPCAwKSB7XG4gICAgICAgICAgICByYW5nZS5zZXRTdGFydChzZWxlY3Rpb25Gb2N1cy5ub2RlLCBzZWxlY3Rpb25Gb2N1cy5vZmZzZXQpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAgICAgICAgIHJhbmdlLnNldEVuZChzZWxlY3Rpb25Gb2N1cy5ub2RlLCBzZWxlY3Rpb25Gb2N1cy5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgICAgICBzZWxlY3Rpb24gPT09IG51bGwgfHwgc2VsZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgIHNlbGVjdGlvbiA9PT0gbnVsbCB8fCBzZWxlY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZS5jbG9uZVJhbmdlKCkpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgbW9kaWZ5U2VsZWN0aW9uUGVyTW91c2VNb3ZlIH07XG4iLCJmdW5jdGlvbiBpc0RpZmZlcmVudFBvaW50ZXJQb3NpdGlvbihwb3NpdGlvbkEsIHBvc2l0aW9uQikge1xuICAgIHZhciByZWYsIHJlZjEsIHJlZjIsIHJlZjMsIHJlZjQsIHJlZjUsIHJlZjYsIHJlZjc7XG4gICAgcmV0dXJuIHBvc2l0aW9uQS50YXJnZXQgIT09IHBvc2l0aW9uQi50YXJnZXQgfHwgKChyZWYgPSBwb3NpdGlvbkEuY29vcmRzKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi54KSAhPT0gKChyZWYxID0gcG9zaXRpb25CLmNvb3JkcykgPT09IG51bGwgfHwgcmVmMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmMS55KSB8fCAoKHJlZjIgPSBwb3NpdGlvbkEuY29vcmRzKSA9PT0gbnVsbCB8fCByZWYyID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYyLnkpICE9PSAoKHJlZjMgPSBwb3NpdGlvbkIuY29vcmRzKSA9PT0gbnVsbCB8fCByZWYzID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYzLnkpIHx8ICgocmVmNCA9IHBvc2l0aW9uQS5jYXJldCkgPT09IG51bGwgfHwgcmVmNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmNC5ub2RlKSAhPT0gKChyZWY1ID0gcG9zaXRpb25CLmNhcmV0KSA9PT0gbnVsbCB8fCByZWY1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWY1Lm5vZGUpIHx8ICgocmVmNiA9IHBvc2l0aW9uQS5jYXJldCkgPT09IG51bGwgfHwgcmVmNiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmNi5vZmZzZXQpICE9PSAoKHJlZjcgPSBwb3NpdGlvbkIuY2FyZXQpID09PSBudWxsIHx8IHJlZjcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZjcub2Zmc2V0KTtcbn1cblxuZXhwb3J0IHsgaXNEaWZmZXJlbnRQb2ludGVyUG9zaXRpb24gfTtcbiIsImltcG9ydCAnLi4vLi4vZXZlbnQvYmVoYXZpb3IvY2xpY2suanMnO1xuaW1wb3J0ICcuLi8uLi9ldmVudC9iZWhhdmlvci9jdXQuanMnO1xuaW1wb3J0ICcuLi8uLi9ldmVudC9iZWhhdmlvci9rZXlkb3duLmpzJztcbmltcG9ydCAnLi4vLi4vZXZlbnQvYmVoYXZpb3Iva2V5cHJlc3MuanMnO1xuaW1wb3J0ICcuLi8uLi9ldmVudC9iZWhhdmlvci9rZXl1cC5qcyc7XG5pbXBvcnQgJy4uLy4uL2V2ZW50L2JlaGF2aW9yL3Bhc3RlLmpzJztcbmltcG9ydCAnQHRlc3RpbmctbGlicmFyeS9kb20nO1xuaW1wb3J0ICcuLi8uLi9ldmVudC9ldmVudE1hcC5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2NsaWNrL2lzQ2xpY2thYmxlSW5wdXQuanMnO1xuaW1wb3J0ICcuLi8uLi91dGlscy9kYXRhVHJhbnNmZXIvQ2xpcGJvYXJkLmpzJztcbmltcG9ydCAnLi4vLi4vdXRpbHMvZWRpdC9pc0VkaXRhYmxlLmpzJztcbmltcG9ydCAnLi4vLi4vdXRpbHMvZWRpdC9tYXhMZW5ndGguanMnO1xuaW1wb3J0IHsgaXNEaXNhYmxlZCB9IGZyb20gJy4uLy4uL3V0aWxzL21pc2MvaXNEaXNhYmxlZC5qcyc7XG5pbXBvcnQgJ0B0ZXN0aW5nLWxpYnJhcnkvZG9tL2Rpc3QvaGVscGVycy5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2tleURlZi9yZWFkTmV4dERlc2NyaXB0b3IuanMnO1xuaW1wb3J0IHsgZ2V0VHJlZURpZmYgfSBmcm9tICcuLi8uLi91dGlscy9taXNjL2dldFRyZWVEaWZmLmpzJztcbmltcG9ydCAnLi4vLi4vdXRpbHMvbWlzYy9sZXZlbC5qcyc7XG5pbXBvcnQgJy4uLy4uL29wdGlvbnMuanMnO1xuaW1wb3J0IHsgZm9jdXNFbGVtZW50IH0gZnJvbSAnLi4vLi4vZXZlbnQvZm9jdXMuanMnO1xuaW1wb3J0IHsgc2V0U2VsZWN0aW9uUGVyTW91c2VEb3duIH0gZnJvbSAnLi4vLi4vZXZlbnQvc2VsZWN0aW9uL3NldFNlbGVjdGlvblBlck1vdXNlLmpzJztcbmltcG9ydCB7IG1vZGlmeVNlbGVjdGlvblBlck1vdXNlTW92ZSB9IGZyb20gJy4uLy4uL2V2ZW50L3NlbGVjdGlvbi9tb2RpZnlTZWxlY3Rpb25QZXJNb3VzZS5qcyc7XG5pbXBvcnQgeyBnZXRNb3VzZUV2ZW50QnV0dG9uLCBCdXR0b25zIH0gZnJvbSAnLi9idXR0b25zLmpzJztcbmltcG9ydCB7IGlzRGlmZmVyZW50UG9pbnRlclBvc2l0aW9uIH0gZnJvbSAnLi9zaGFyZWQuanMnO1xuXG4vKipcbiAqIFRoaXMgb2JqZWN0IGlzIHRoZSBzaW5nbGUgXCJ2aXJ0dWFsXCIgbW91c2UgdGhhdCBtaWdodCBiZSBjb250cm9sbGVkIGJ5IG11bHRpcGxlIGRpZmZlcmVudCBwb2ludGVyIGRldmljZXMuXG4gKi8gY2xhc3MgTW91c2Uge1xuICAgIG1vdmUoaW5zdGFuY2UsIHBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IHByZXZQb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgIGNvbnN0IHByZXZUYXJnZXQgPSB0aGlzLmdldFRhcmdldChpbnN0YW5jZSk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgaWYgKCFpc0RpZmZlcmVudFBvaW50ZXJQb3NpdGlvbihwcmV2UG9zaXRpb24sIHBvc2l0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHRUYXJnZXQgPSB0aGlzLmdldFRhcmdldChpbnN0YW5jZSk7XG4gICAgICAgIGNvbnN0IGluaXQgPSB0aGlzLmdldEV2ZW50SW5pdCgnbW91c2Vtb3ZlJyk7XG4gICAgICAgIGNvbnN0IFtsZWF2ZSwgZW50ZXJdID0gZ2V0VHJlZURpZmYocHJldlRhcmdldCwgbmV4dFRhcmdldCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWF2ZTogKCk9PntcbiAgICAgICAgICAgICAgICBpZiAocHJldlRhcmdldCAhPT0gbmV4dFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5kaXNwYXRjaFVJRXZlbnQocHJldlRhcmdldCwgJ21vdXNlb3V0JywgaW5pdCk7XG4gICAgICAgICAgICAgICAgICAgIGxlYXZlLmZvckVhY2goKGVsKT0+aW5zdGFuY2UuZGlzcGF0Y2hVSUV2ZW50KGVsLCAnbW91c2VsZWF2ZScsIGluaXQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW50ZXI6ICgpPT57XG4gICAgICAgICAgICAgICAgaWYgKHByZXZUYXJnZXQgIT09IG5leHRUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuZGlzcGF0Y2hVSUV2ZW50KG5leHRUYXJnZXQsICdtb3VzZW92ZXInLCBpbml0KTtcbiAgICAgICAgICAgICAgICAgICAgZW50ZXIuZm9yRWFjaCgoZWwpPT5pbnN0YW5jZS5kaXNwYXRjaFVJRXZlbnQoZWwsICdtb3VzZWVudGVyJywgaW5pdCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb3ZlOiAoKT0+e1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLmRpc3BhdGNoVUlFdmVudChuZXh0VGFyZ2V0LCAnbW91c2Vtb3ZlJywgaW5pdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlTZWxlY3RpbmcoaW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBkb3duKGluc3RhbmNlLCBrZXlEZWYsIHBvaW50ZXIpIHtcbiAgICAgICAgY29uc3QgYnV0dG9uID0gdGhpcy5idXR0b25zLmRvd24oa2V5RGVmKTtcbiAgICAgICAgaWYgKGJ1dHRvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5nZXRUYXJnZXQoaW5zdGFuY2UpO1xuICAgICAgICB0aGlzLmJ1dHRvbkRvd25UYXJnZXRbYnV0dG9uXSA9IHRhcmdldDtcbiAgICAgICAgY29uc3QgZGlzYWJsZWQgPSBpc0Rpc2FibGVkKHRhcmdldCk7XG4gICAgICAgIGNvbnN0IGluaXQgPSB0aGlzLmdldEV2ZW50SW5pdCgnbW91c2Vkb3duJywga2V5RGVmLmJ1dHRvbik7XG4gICAgICAgIGlmIChkaXNhYmxlZCB8fCBpbnN0YW5jZS5kaXNwYXRjaFVJRXZlbnQodGFyZ2V0LCAnbW91c2Vkb3duJywgaW5pdCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRTZWxlY3RpbmcoaW5zdGFuY2UsIGluaXQuZGV0YWlsKTtcbiAgICAgICAgICAgIGZvY3VzRWxlbWVudCh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGlzYWJsZWQgJiYgZ2V0TW91c2VFdmVudEJ1dHRvbihrZXlEZWYuYnV0dG9uKSA9PT0gMikge1xuICAgICAgICAgICAgaW5zdGFuY2UuZGlzcGF0Y2hVSUV2ZW50KHRhcmdldCwgJ2NvbnRleHRtZW51JywgdGhpcy5nZXRFdmVudEluaXQoJ2NvbnRleHRtZW51Jywga2V5RGVmLmJ1dHRvbiwgcG9pbnRlcikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwKGluc3RhbmNlLCBrZXlEZWYsIHBvaW50ZXIpIHtcbiAgICAgICAgY29uc3QgYnV0dG9uID0gdGhpcy5idXR0b25zLnVwKGtleURlZik7XG4gICAgICAgIGlmIChidXR0b24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuZ2V0VGFyZ2V0KGluc3RhbmNlKTtcbiAgICAgICAgaWYgKCFpc0Rpc2FibGVkKHRhcmdldCkpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLmRpc3BhdGNoVUlFdmVudCh0YXJnZXQsICdtb3VzZXVwJywgdGhpcy5nZXRFdmVudEluaXQoJ21vdXNldXAnLCBrZXlEZWYuYnV0dG9uKSk7XG4gICAgICAgICAgICB0aGlzLmVuZFNlbGVjdGluZygpO1xuICAgICAgICAgICAgY29uc3QgY2xpY2tUYXJnZXQgPSBnZXRUcmVlRGlmZih0aGlzLmJ1dHRvbkRvd25UYXJnZXRbYnV0dG9uXSwgdGFyZ2V0KVsyXVswXTtcbiAgICAgICAgICAgIGlmIChjbGlja1RhcmdldCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluaXQgPSB0aGlzLmdldEV2ZW50SW5pdCgnY2xpY2snLCBrZXlEZWYuYnV0dG9uLCBwb2ludGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5pdC5kZXRhaWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuZGlzcGF0Y2hVSUV2ZW50KGNsaWNrVGFyZ2V0LCBpbml0LmJ1dHRvbiA9PT0gMCA/ICdjbGljaycgOiAnYXV4Y2xpY2snLCBpbml0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluaXQuYnV0dG9uID09PSAwICYmIGluaXQuZGV0YWlsID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5kaXNwYXRjaFVJRXZlbnQoY2xpY2tUYXJnZXQsICdkYmxjbGljaycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi50aGlzLmdldEV2ZW50SW5pdCgnZGJsY2xpY2snLCBrZXlEZWYuYnV0dG9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IGluaXQuZGV0YWlsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNldENsaWNrQ291bnQoKSB7XG4gICAgICAgIHRoaXMuY2xpY2tDb3VudC5yZXNldCgpO1xuICAgIH1cbiAgICBnZXRFdmVudEluaXQodHlwZSwgYnV0dG9uLCBwb2ludGVyKSB7XG4gICAgICAgIGNvbnN0IGluaXQgPSB7XG4gICAgICAgICAgICAuLi50aGlzLnBvc2l0aW9uLmNvb3Jkc1xuICAgICAgICB9O1xuICAgICAgICBpZiAocG9pbnRlcikge1xuICAgICAgICAgICAgaW5pdC5wb2ludGVySWQgPSBwb2ludGVyLnBvaW50ZXJJZDtcbiAgICAgICAgICAgIGluaXQucG9pbnRlclR5cGUgPSBwb2ludGVyLnBvaW50ZXJUeXBlO1xuICAgICAgICAgICAgaW5pdC5pc1ByaW1hcnkgPSBwb2ludGVyLmlzUHJpbWFyeTtcbiAgICAgICAgfVxuICAgICAgICBpbml0LmJ1dHRvbiA9IGdldE1vdXNlRXZlbnRCdXR0b24oYnV0dG9uKTtcbiAgICAgICAgaW5pdC5idXR0b25zID0gdGhpcy5idXR0b25zLmdldEJ1dHRvbnMoKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdtb3VzZWRvd24nKSB7XG4gICAgICAgICAgICBpbml0LmRldGFpbCA9IHRoaXMuY2xpY2tDb3VudC5nZXRPbkRvd24oaW5pdC5idXR0b24pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdtb3VzZXVwJykge1xuICAgICAgICAgICAgaW5pdC5kZXRhaWwgPSB0aGlzLmNsaWNrQ291bnQuZ2V0T25VcChpbml0LmJ1dHRvbik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NsaWNrJyB8fCB0eXBlID09PSAnYXV4Y2xpY2snKSB7XG4gICAgICAgICAgICBpbml0LmRldGFpbCA9IHRoaXMuY2xpY2tDb3VudC5pbmNPbkNsaWNrKGluaXQuYnV0dG9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5pdDtcbiAgICB9XG4gICAgZ2V0VGFyZ2V0KGluc3RhbmNlKSB7XG4gICAgICAgIHZhciBfdGFyZ2V0O1xuICAgICAgICByZXR1cm4gKF90YXJnZXQgPSB0aGlzLnBvc2l0aW9uLnRhcmdldCkgIT09IG51bGwgJiYgX3RhcmdldCAhPT0gdm9pZCAwID8gX3RhcmdldCA6IGluc3RhbmNlLmNvbmZpZy5kb2N1bWVudC5ib2R5O1xuICAgIH1cbiAgICBzdGFydFNlbGVjdGluZyhpbnN0YW5jZSwgY2xpY2tDb3VudCkge1xuICAgICAgICB2YXIgcmVmLCByZWYxO1xuICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGV4dGVuZGluZyByYW5nZSAoc2hpZnQpXG4gICAgICAgIHRoaXMuc2VsZWN0aW5nID0gc2V0U2VsZWN0aW9uUGVyTW91c2VEb3duKHtcbiAgICAgICAgICAgIGRvY3VtZW50OiBpbnN0YW5jZS5jb25maWcuZG9jdW1lbnQsXG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMuZ2V0VGFyZ2V0KGluc3RhbmNlKSxcbiAgICAgICAgICAgIG5vZGU6IChyZWYgPSB0aGlzLnBvc2l0aW9uLmNhcmV0KSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5ub2RlLFxuICAgICAgICAgICAgb2Zmc2V0OiAocmVmMSA9IHRoaXMucG9zaXRpb24uY2FyZXQpID09PSBudWxsIHx8IHJlZjEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZjEub2Zmc2V0LFxuICAgICAgICAgICAgY2xpY2tDb3VudFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbW9kaWZ5U2VsZWN0aW5nKGluc3RhbmNlKSB7XG4gICAgICAgIHZhciByZWYsIHJlZjE7XG4gICAgICAgIGlmICghdGhpcy5zZWxlY3RpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBtb2RpZnlTZWxlY3Rpb25QZXJNb3VzZU1vdmUodGhpcy5zZWxlY3RpbmcsIHtcbiAgICAgICAgICAgIGRvY3VtZW50OiBpbnN0YW5jZS5jb25maWcuZG9jdW1lbnQsXG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMuZ2V0VGFyZ2V0KGluc3RhbmNlKSxcbiAgICAgICAgICAgIG5vZGU6IChyZWYgPSB0aGlzLnBvc2l0aW9uLmNhcmV0KSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5ub2RlLFxuICAgICAgICAgICAgb2Zmc2V0OiAocmVmMSA9IHRoaXMucG9zaXRpb24uY2FyZXQpID09PSBudWxsIHx8IHJlZjEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZjEub2Zmc2V0XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbmRTZWxlY3RpbmcoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW5nID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0ge307XG4gICAgICAgIHRoaXMuYnV0dG9ucyA9IG5ldyBCdXR0b25zKCk7XG4gICAgICAgIHRoaXMuYnV0dG9uRG93blRhcmdldCA9IHt9O1xuICAgICAgICAvLyBBY2NvcmRpbmcgdG8gc3BlYyB0aGUgYGRldGFpbGAgb24gY2xpY2sgZXZlbnRzIHNob3VsZCBiZSB0aGUgbnVtYmVyXG4gICAgICAgIC8vIG9mICpjb25zZWN1dGl2ZSogY2xpY2tzIHdpdGggYSBzcGVjaWZpYyBidXR0b24uXG4gICAgICAgIC8vIE9uIGBtb3VzZWRvd25gIGFuZCBgbW91c2V1cGAgaXQgc2hvdWxkIGJlIHRoaXMgbnVtYmVyIGluY3JlYXNlZCBieSBvbmUuXG4gICAgICAgIC8vIEJ1dCB0aGUgYnJvd3NlcnMgZG9uJ3QgaW1wbGVtZW50IGl0IHRoaXMgd2F5LlxuICAgICAgICAvLyBJZiBhbm90aGVyIGJ1dHRvbiBpcyBwcmVzc2VkLFxuICAgICAgICAvLyAgIGluIFdlYmtpdDogdGhlIGBtb3VzZXVwYCBvbiB0aGUgcHJldmlvdXNseSBwcmVzc2VkIGJ1dHRvbiBoYXMgYGRldGFpbDogMGAgYW5kIG5vIGBjbGlja2AvYGF1eGNsaWNrYC5cbiAgICAgICAgLy8gICBpbiBHZWNrbzogdGhlIGBtb3VzZXVwYCBhbmQgY2xpY2sgZXZlbnRzIGhhdmUgdGhlIHNhbWUgZGV0YWlsIGFzIHRoZSBgbW91c2Vkb3duYC5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBkZWxheSB3aGlsZSBhIGJ1dHRvbiBpcyBwcmVzc2VkLFxuICAgICAgICAvLyB0aGUgYG1vdXNldXBgIGFuZCBgY2xpY2tgIGFyZSBub3JtYWwsIGJ1dCBhIGZvbGxvd2luZyBgbW91c2Vkb3duYCBzdGFydHMgYSBuZXcgY2xpY2sgY291bnQuXG4gICAgICAgIC8vIFdlJ2xsIGZvbGxvdyB0aGUgbWluaW1hbCBpbXBsZW1lbnRhdGlvbiBvZiBXZWJraXQuXG4gICAgICAgIHRoaXMuY2xpY2tDb3VudCA9IG5ldyBjbGFzcyB7XG4gICAgICAgICAgICBpbmNPbkNsaWNrKGJ1dHRvbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmRvd25bYnV0dG9uXSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogTnVtYmVyKHRoaXMuZG93bltidXR0b25dKSArIDE7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCA9IHRoaXMuY291bnRbYnV0dG9uXSA9PT0gdW5kZWZpbmVkID8ge30gOiB7XG4gICAgICAgICAgICAgICAgICAgIFtidXR0b25dOiBOdW1iZXIodGhpcy5jb3VudFtidXR0b25dKSArIDFcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2V0T25Eb3duKGJ1dHRvbikge1xuICAgICAgICAgICAgICAgIHZhciBfYnV0dG9uO1xuICAgICAgICAgICAgICAgIHRoaXMuZG93biA9IHtcbiAgICAgICAgICAgICAgICAgICAgW2J1dHRvbl06IChfYnV0dG9uID0gdGhpcy5jb3VudFtidXR0b25dKSAhPT0gbnVsbCAmJiBfYnV0dG9uICE9PSB2b2lkIDAgPyBfYnV0dG9uIDogMFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIF9idXR0b24xO1xuICAgICAgICAgICAgICAgIHRoaXMuY291bnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIFtidXR0b25dOiAoX2J1dHRvbjEgPSB0aGlzLmNvdW50W2J1dHRvbl0pICE9PSBudWxsICYmIF9idXR0b24xICE9PSB2b2lkIDAgPyBfYnV0dG9uMSA6IDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIodGhpcy5jb3VudFtidXR0b25dKSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZXRPblVwKGJ1dHRvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRvd25bYnV0dG9uXSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogTnVtYmVyKHRoaXMuZG93bltidXR0b25dKSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICAgICAgICAgIHRoaXMuZG93biA9IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMuY291bnQgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSgpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgTW91c2UgfTtcbiIsImltcG9ydCB7IFBvaW50ZXJFdmVudHNDaGVja0xldmVsIH0gZnJvbSAnLi4vLi4vb3B0aW9ucy5qcyc7XG5pbXBvcnQgeyBnZXRXaW5kb3cgfSBmcm9tICcuLi9taXNjL2dldFdpbmRvdy5qcyc7XG5pbXBvcnQgeyBpc0VsZW1lbnRUeXBlIH0gZnJvbSAnLi4vbWlzYy9pc0VsZW1lbnRUeXBlLmpzJztcbmltcG9ydCB7IEFwaUxldmVsLCBnZXRMZXZlbFJlZiB9IGZyb20gJy4uL21pc2MvbGV2ZWwuanMnO1xuXG5mdW5jdGlvbiBoYXNQb2ludGVyRXZlbnRzKGluc3RhbmNlLCBlbGVtZW50KSB7XG4gICAgdmFyIHJlZjtcbiAgICByZXR1cm4gKChyZWYgPSBjaGVja1BvaW50ZXJFdmVudHMoaW5zdGFuY2UsIGVsZW1lbnQpKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5wb2ludGVyRXZlbnRzKSAhPT0gJ25vbmUnO1xufVxuZnVuY3Rpb24gY2xvc2VzdFBvaW50ZXJFdmVudHNEZWNsYXJhdGlvbihlbGVtZW50KSB7XG4gICAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICAgIGZvcihsZXQgZWwgPSBlbGVtZW50LCB0cmVlID0gW107IGVsID09PSBudWxsIHx8IGVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbC5vd25lckRvY3VtZW50OyBlbCA9IGVsLnBhcmVudEVsZW1lbnQpe1xuICAgICAgICB0cmVlLnB1c2goZWwpO1xuICAgICAgICBjb25zdCBwb2ludGVyRXZlbnRzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpLnBvaW50ZXJFdmVudHM7XG4gICAgICAgIGlmIChwb2ludGVyRXZlbnRzICYmICFbXG4gICAgICAgICAgICAnaW5oZXJpdCcsXG4gICAgICAgICAgICAndW5zZXQnXG4gICAgICAgIF0uaW5jbHVkZXMocG9pbnRlckV2ZW50cykpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcG9pbnRlckV2ZW50cyxcbiAgICAgICAgICAgICAgICB0cmVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5jb25zdCBQb2ludGVyRXZlbnRzQ2hlY2sgPSBTeW1ib2woJ0xhc3QgY2hlY2sgZm9yIHBvaW50ZXItZXZlbnRzJyk7XG5mdW5jdGlvbiBjaGVja1BvaW50ZXJFdmVudHMoaW5zdGFuY2UsIGVsZW1lbnQpIHtcbiAgICBjb25zdCBsYXN0Q2hlY2sgPSBlbGVtZW50W1BvaW50ZXJFdmVudHNDaGVja107XG4gICAgY29uc3QgbmVlZHNDaGVjayA9IGluc3RhbmNlLmNvbmZpZy5wb2ludGVyRXZlbnRzQ2hlY2sgIT09IFBvaW50ZXJFdmVudHNDaGVja0xldmVsLk5ldmVyICYmICghbGFzdENoZWNrIHx8IGhhc0JpdEZsYWcoaW5zdGFuY2UuY29uZmlnLnBvaW50ZXJFdmVudHNDaGVjaywgUG9pbnRlckV2ZW50c0NoZWNrTGV2ZWwuRWFjaEFwaUNhbGwpICYmIGxhc3RDaGVja1tBcGlMZXZlbC5DYWxsXSAhPT0gZ2V0TGV2ZWxSZWYoaW5zdGFuY2UsIEFwaUxldmVsLkNhbGwpIHx8IGhhc0JpdEZsYWcoaW5zdGFuY2UuY29uZmlnLnBvaW50ZXJFdmVudHNDaGVjaywgUG9pbnRlckV2ZW50c0NoZWNrTGV2ZWwuRWFjaFRyaWdnZXIpICYmIGxhc3RDaGVja1tBcGlMZXZlbC5UcmlnZ2VyXSAhPT0gZ2V0TGV2ZWxSZWYoaW5zdGFuY2UsIEFwaUxldmVsLlRyaWdnZXIpKTtcbiAgICBpZiAoIW5lZWRzQ2hlY2spIHtcbiAgICAgICAgcmV0dXJuIGxhc3RDaGVjayA9PT0gbnVsbCB8fCBsYXN0Q2hlY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhc3RDaGVjay5yZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gY2xvc2VzdFBvaW50ZXJFdmVudHNEZWNsYXJhdGlvbihlbGVtZW50KTtcbiAgICBlbGVtZW50W1BvaW50ZXJFdmVudHNDaGVja10gPSB7XG4gICAgICAgIFtBcGlMZXZlbC5DYWxsXTogZ2V0TGV2ZWxSZWYoaW5zdGFuY2UsIEFwaUxldmVsLkNhbGwpLFxuICAgICAgICBbQXBpTGV2ZWwuVHJpZ2dlcl06IGdldExldmVsUmVmKGluc3RhbmNlLCBBcGlMZXZlbC5UcmlnZ2VyKSxcbiAgICAgICAgcmVzdWx0OiBkZWNsYXJhdGlvblxuICAgIH07XG4gICAgcmV0dXJuIGRlY2xhcmF0aW9uO1xufVxuZnVuY3Rpb24gYXNzZXJ0UG9pbnRlckV2ZW50cyhpbnN0YW5jZSwgZWxlbWVudCkge1xuICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gY2hlY2tQb2ludGVyRXZlbnRzKGluc3RhbmNlLCBlbGVtZW50KTtcbiAgICBpZiAoKGRlY2xhcmF0aW9uID09PSBudWxsIHx8IGRlY2xhcmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZWNsYXJhdGlvbi5wb2ludGVyRXZlbnRzKSA9PT0gJ25vbmUnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihbXG4gICAgICAgICAgICBgVW5hYmxlIHRvIHBlcmZvcm0gcG9pbnRlciBpbnRlcmFjdGlvbiBhcyB0aGUgZWxlbWVudCAke2RlY2xhcmF0aW9uLnRyZWUubGVuZ3RoID4gMSA/ICdpbmhlcml0cycgOiAnaGFzJ30gXFxgcG9pbnRlci1ldmVudHM6IG5vbmVcXGA6YCxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgcHJpbnRUcmVlKGRlY2xhcmF0aW9uLnRyZWUpLCBcbiAgICAgICAgXS5qb2luKCdcXG4nKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcHJpbnRUcmVlKHRyZWUpIHtcbiAgICByZXR1cm4gdHJlZS5yZXZlcnNlKCkubWFwKChlbCwgaSk9PltcbiAgICAgICAgICAgICcnLnBhZEVuZChpKSxcbiAgICAgICAgICAgIGVsLnRhZ05hbWUsXG4gICAgICAgICAgICBlbC5pZCAmJiBgIyR7ZWwuaWR9YCxcbiAgICAgICAgICAgIGVsLmhhc0F0dHJpYnV0ZSgnZGF0YS10ZXN0aWQnKSAmJiBgKHRlc3RJZD0ke2VsLmdldEF0dHJpYnV0ZSgnZGF0YS10ZXN0aWQnKX0pYCxcbiAgICAgICAgICAgIGdldExhYmVsRGVzY3IoZWwpLFxuICAgICAgICAgICAgdHJlZS5sZW5ndGggPiAxICYmIGkgPT09IDAgJiYgJyAgPC0tIFRoaXMgZWxlbWVudCBkZWNsYXJlZCBgcG9pbnRlci1ldmVudHM6IG5vbmVgJyxcbiAgICAgICAgICAgIHRyZWUubGVuZ3RoID4gMSAmJiBpID09PSB0cmVlLmxlbmd0aCAtIDEgJiYgJyAgPC0tIEFzc2VydGVkIHBvaW50ZXIgZXZlbnRzIGhlcmUnLCBcbiAgICAgICAgXS5maWx0ZXIoQm9vbGVhbikuam9pbignJykpLmpvaW4oJ1xcbicpO1xufVxuZnVuY3Rpb24gZ2V0TGFiZWxEZXNjcihlbGVtZW50KSB7XG4gICAgdmFyIHJlZjtcbiAgICBsZXQgbGFiZWw7XG4gICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCdhcmlhLWxhYmVsJykpIHtcbiAgICAgICAgbGFiZWwgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpO1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2FyaWEtbGFiZWxsZWRieScpKSB7XG4gICAgICAgIHZhciByZWYxLCByZWYyO1xuICAgICAgICBsYWJlbCA9IChyZWYxID0gZWxlbWVudC5vd25lckRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsbGVkYnknKSkpID09PSBudWxsIHx8IHJlZjEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChyZWYyID0gcmVmMS50ZXh0Q29udGVudCkgPT09IG51bGwgfHwgcmVmMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmMi50cmltKCk7XG4gICAgfSBlbHNlIGlmIChpc0VsZW1lbnRUeXBlKGVsZW1lbnQsIFtcbiAgICAgICAgJ2J1dHRvbicsXG4gICAgICAgICdpbnB1dCcsXG4gICAgICAgICdtZXRlcicsXG4gICAgICAgICdvdXRwdXQnLFxuICAgICAgICAncHJvZ3Jlc3MnLFxuICAgICAgICAnc2VsZWN0JyxcbiAgICAgICAgJ3RleHRhcmVhJywgXG4gICAgXSkgJiYgKChyZWYgPSBlbGVtZW50LmxhYmVscykgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYubGVuZ3RoKSkge1xuICAgICAgICBsYWJlbCA9IEFycmF5LmZyb20oZWxlbWVudC5sYWJlbHMpLm1hcCgoZWwpPT57XG4gICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgcmV0dXJuIChyZWYgPSBlbC50ZXh0Q29udGVudCkgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYudHJpbSgpO1xuICAgICAgICB9KS5qb2luKCd8Jyk7XG4gICAgfSBlbHNlIGlmIChpc0VsZW1lbnRUeXBlKGVsZW1lbnQsICdidXR0b24nKSkge1xuICAgICAgICB2YXIgcmVmMztcbiAgICAgICAgbGFiZWwgPSAocmVmMyA9IGVsZW1lbnQudGV4dENvbnRlbnQpID09PSBudWxsIHx8IHJlZjMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZjMudHJpbSgpO1xuICAgIH1cbiAgICBsYWJlbCA9IGxhYmVsID09PSBudWxsIHx8IGxhYmVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYWJlbC5yZXBsYWNlKC9cXG4vZywgJyAgJyk7XG4gICAgaWYgKE51bWJlcihsYWJlbCA9PT0gbnVsbCB8fCBsYWJlbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFiZWwubGVuZ3RoKSA+IDMwKSB7XG4gICAgICAgIGxhYmVsID0gYCR7bGFiZWwgPT09IG51bGwgfHwgbGFiZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhYmVsLnN1YnN0cmluZygwLCAyOSl94oCmYDtcbiAgICB9XG4gICAgcmV0dXJuIGxhYmVsID8gYChsYWJlbD0ke2xhYmVsfSlgIDogJyc7XG59XG4vLyBXaXRoIHRoZSBlc2xpbnQgcnVsZSBhbmQgcHJldHRpZXIgdGhlIGJpdHdpc2Ugb3BlcmF0aW9uIGlzbid0IG5pY2UgdG8gcmVhZFxuZnVuY3Rpb24gaGFzQml0RmxhZyhjb25mLCBmbGFnKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICByZXR1cm4gKGNvbmYgJiBmbGFnKSA+IDA7XG59XG5cbmV4cG9ydCB7IGFzc2VydFBvaW50ZXJFdmVudHMsIGhhc1BvaW50ZXJFdmVudHMgfTtcbiIsImltcG9ydCAnLi4vLi4vdXRpbHMvY2xpY2svaXNDbGlja2FibGVJbnB1dC5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2RhdGFUcmFuc2Zlci9DbGlwYm9hcmQuanMnO1xuaW1wb3J0ICcuLi8uLi91dGlscy9lZGl0L2lzRWRpdGFibGUuanMnO1xuaW1wb3J0ICcuLi8uLi91dGlscy9lZGl0L21heExlbmd0aC5qcyc7XG5pbXBvcnQgJ0B0ZXN0aW5nLWxpYnJhcnkvZG9tL2Rpc3QvaGVscGVycy5qcyc7XG5pbXBvcnQgJy4uLy4uL3V0aWxzL2tleURlZi9yZWFkTmV4dERlc2NyaXB0b3IuanMnO1xuaW1wb3J0IHsgZ2V0VHJlZURpZmYgfSBmcm9tICcuLi8uLi91dGlscy9taXNjL2dldFRyZWVEaWZmLmpzJztcbmltcG9ydCAnLi4vLi4vdXRpbHMvbWlzYy9sZXZlbC5qcyc7XG5pbXBvcnQgeyBhc3NlcnRQb2ludGVyRXZlbnRzLCBoYXNQb2ludGVyRXZlbnRzIH0gZnJvbSAnLi4vLi4vdXRpbHMvcG9pbnRlci9jc3NQb2ludGVyRXZlbnRzLmpzJztcbmltcG9ydCB7IGlzRGlmZmVyZW50UG9pbnRlclBvc2l0aW9uIH0gZnJvbSAnLi9zaGFyZWQuanMnO1xuXG5jbGFzcyBQb2ludGVyIHtcbiAgICBpbml0KGluc3RhbmNlLCBwb3NpdGlvbikge1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuZ2V0VGFyZ2V0KGluc3RhbmNlKTtcbiAgICAgICAgY29uc3QgWywgZW50ZXJdID0gZ2V0VHJlZURpZmYobnVsbCwgdGFyZ2V0KTtcbiAgICAgICAgY29uc3QgaW5pdCA9IHRoaXMuZ2V0RXZlbnRJbml0KCk7XG4gICAgICAgIGFzc2VydFBvaW50ZXJFdmVudHMoaW5zdGFuY2UsIHRhcmdldCk7XG4gICAgICAgIGluc3RhbmNlLmRpc3BhdGNoVUlFdmVudCh0YXJnZXQsICdwb2ludGVyb3ZlcicsIGluaXQpO1xuICAgICAgICBlbnRlci5mb3JFYWNoKChlbCk9Pmluc3RhbmNlLmRpc3BhdGNoVUlFdmVudChlbCwgJ3BvaW50ZXJlbnRlcicsIGluaXQpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG1vdmUoaW5zdGFuY2UsIHBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IHByZXZQb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgIGNvbnN0IHByZXZUYXJnZXQgPSB0aGlzLmdldFRhcmdldChpbnN0YW5jZSk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgaWYgKCFpc0RpZmZlcmVudFBvaW50ZXJQb3NpdGlvbihwcmV2UG9zaXRpb24sIHBvc2l0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHRUYXJnZXQgPSB0aGlzLmdldFRhcmdldChpbnN0YW5jZSk7XG4gICAgICAgIGNvbnN0IGluaXQgPSB0aGlzLmdldEV2ZW50SW5pdCgpO1xuICAgICAgICBjb25zdCBbbGVhdmUsIGVudGVyXSA9IGdldFRyZWVEaWZmKHByZXZUYXJnZXQsIG5leHRUYXJnZXQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVhdmU6ICgpPT57XG4gICAgICAgICAgICAgICAgaWYgKGhhc1BvaW50ZXJFdmVudHMoaW5zdGFuY2UsIHByZXZUYXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2VGFyZ2V0ICE9PSBuZXh0VGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5kaXNwYXRjaFVJRXZlbnQocHJldlRhcmdldCwgJ3BvaW50ZXJvdXQnLCBpbml0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlYXZlLmZvckVhY2goKGVsKT0+aW5zdGFuY2UuZGlzcGF0Y2hVSUV2ZW50KGVsLCAncG9pbnRlcmxlYXZlJywgaW5pdCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudGVyOiAoKT0+e1xuICAgICAgICAgICAgICAgIGFzc2VydFBvaW50ZXJFdmVudHMoaW5zdGFuY2UsIG5leHRUYXJnZXQpO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2VGFyZ2V0ICE9PSBuZXh0VGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmRpc3BhdGNoVUlFdmVudChuZXh0VGFyZ2V0LCAncG9pbnRlcm92ZXInLCBpbml0KTtcbiAgICAgICAgICAgICAgICAgICAgZW50ZXIuZm9yRWFjaCgoZWwpPT5pbnN0YW5jZS5kaXNwYXRjaFVJRXZlbnQoZWwsICdwb2ludGVyZW50ZXInLCBpbml0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1vdmU6ICgpPT57XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZGlzcGF0Y2hVSUV2ZW50KG5leHRUYXJnZXQsICdwb2ludGVybW92ZScsIGluaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBkb3duKGluc3RhbmNlLCBfa2V5RGVmKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRG93bikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuZ2V0VGFyZ2V0KGluc3RhbmNlKTtcbiAgICAgICAgYXNzZXJ0UG9pbnRlckV2ZW50cyhpbnN0YW5jZSwgdGFyZ2V0KTtcbiAgICAgICAgdGhpcy5pc0Rvd24gPSB0cnVlO1xuICAgICAgICB0aGlzLmlzUHJldmVudGVkID0gIWluc3RhbmNlLmRpc3BhdGNoVUlFdmVudCh0YXJnZXQsICdwb2ludGVyZG93bicsIHRoaXMuZ2V0RXZlbnRJbml0KCkpO1xuICAgIH1cbiAgICB1cChpbnN0YW5jZSwgX2tleURlZikge1xuICAgICAgICBpZiAoIXRoaXMuaXNEb3duKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5nZXRUYXJnZXQoaW5zdGFuY2UpO1xuICAgICAgICBhc3NlcnRQb2ludGVyRXZlbnRzKGluc3RhbmNlLCB0YXJnZXQpO1xuICAgICAgICB0aGlzLmlzRG93biA9IGZhbHNlO1xuICAgICAgICBpbnN0YW5jZS5kaXNwYXRjaFVJRXZlbnQodGFyZ2V0LCAncG9pbnRlcnVwJywgdGhpcy5nZXRFdmVudEluaXQoKSk7XG4gICAgfVxuICAgIHJlbGVhc2UoaW5zdGFuY2UpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5nZXRUYXJnZXQoaW5zdGFuY2UpO1xuICAgICAgICBjb25zdCBbbGVhdmVdID0gZ2V0VHJlZURpZmYodGFyZ2V0LCBudWxsKTtcbiAgICAgICAgY29uc3QgaW5pdCA9IHRoaXMuZ2V0RXZlbnRJbml0KCk7XG4gICAgICAgIC8vIEN1cnJlbnRseSB0aGVyZSBpcyBubyBQb2ludGVyRXZlbnRzQ2hlY2tMZXZlbCB0aGF0IHdvdWxkXG4gICAgICAgIC8vIG1ha2UgdGhpcyBjaGVjayBub3QgdXNlIHRoZSAqYXNzZXJ0ZWQqIGNhY2hlZCB2YWx1ZSBmcm9tIGB1cGAuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovIGlmIChoYXNQb2ludGVyRXZlbnRzKGluc3RhbmNlLCB0YXJnZXQpKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5kaXNwYXRjaFVJRXZlbnQodGFyZ2V0LCAncG9pbnRlcm91dCcsIGluaXQpO1xuICAgICAgICAgICAgbGVhdmUuZm9yRWFjaCgoZWwpPT5pbnN0YW5jZS5kaXNwYXRjaFVJRXZlbnQoZWwsICdwb2ludGVybGVhdmUnLCBpbml0KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0NhbmNlbGxlZCA9IHRydWU7XG4gICAgfVxuICAgIGdldFRhcmdldChpbnN0YW5jZSkge1xuICAgICAgICB2YXIgX3RhcmdldDtcbiAgICAgICAgcmV0dXJuIChfdGFyZ2V0ID0gdGhpcy5wb3NpdGlvbi50YXJnZXQpICE9PSBudWxsICYmIF90YXJnZXQgIT09IHZvaWQgMCA/IF90YXJnZXQgOiBpbnN0YW5jZS5jb25maWcuZG9jdW1lbnQuYm9keTtcbiAgICB9XG4gICAgZ2V0RXZlbnRJbml0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udGhpcy5wb3NpdGlvbi5jb29yZHMsXG4gICAgICAgICAgICBwb2ludGVySWQ6IHRoaXMucG9pbnRlcklkLFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IHRoaXMucG9pbnRlclR5cGUsXG4gICAgICAgICAgICBpc1ByaW1hcnk6IHRoaXMuaXNQcmltYXJ5XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHsgcG9pbnRlcklkICwgcG9pbnRlclR5cGUgLCBpc1ByaW1hcnkgIH0pe1xuICAgICAgICB0aGlzLmlzTXVsdGl0b3VjaCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzQ2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNEb3duID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNQcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHt9O1xuICAgICAgICB0aGlzLnBvaW50ZXJJZCA9IHBvaW50ZXJJZDtcbiAgICAgICAgdGhpcy5wb2ludGVyVHlwZSA9IHBvaW50ZXJUeXBlO1xuICAgICAgICB0aGlzLmlzUHJpbWFyeSA9IGlzUHJpbWFyeTtcbiAgICAgICAgdGhpcy5pc011bHRpdG91Y2ggPSAhaXNQcmltYXJ5O1xuICAgIH1cbn1cblxuZXhwb3J0IHsgUG9pbnRlciB9O1xuIiwiaW1wb3J0IHsgQnV0dG9ucyB9IGZyb20gJy4vYnV0dG9ucy5qcyc7XG5pbXBvcnQgeyBEZXZpY2UgfSBmcm9tICcuL2RldmljZS5qcyc7XG5pbXBvcnQgeyBNb3VzZSB9IGZyb20gJy4vbW91c2UuanMnO1xuaW1wb3J0IHsgUG9pbnRlciB9IGZyb20gJy4vcG9pbnRlci5qcyc7XG5cbnZhciBfcmVnaXN0cnksIF9rO1xuY2xhc3MgUG9pbnRlckhvc3Qge1xuICAgIGlzS2V5UHJlc3NlZChrZXlEZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGV2aWNlcy5nZXQoa2V5RGVmLnBvaW50ZXJUeXBlKS5pc1ByZXNzZWQoa2V5RGVmKTtcbiAgICB9XG4gICAgYXN5bmMgcHJlc3MoaW5zdGFuY2UsIGtleURlZiwgcG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgcG9pbnRlck5hbWUgPSB0aGlzLmdldFBvaW50ZXJOYW1lKGtleURlZik7XG4gICAgICAgIGNvbnN0IHBvaW50ZXIgPSBrZXlEZWYucG9pbnRlclR5cGUgPT09ICd0b3VjaCcgPyB0aGlzLnBvaW50ZXJzLm5ldyhwb2ludGVyTmFtZSwga2V5RGVmKS5pbml0KGluc3RhbmNlLCBwb3NpdGlvbikgOiB0aGlzLnBvaW50ZXJzLmdldChwb2ludGVyTmFtZSk7XG4gICAgICAgIC8vIFRPRE86IGRlcHJlY2F0ZSB0aGUgZm9sbG93aW5nIGltcGxpY2l0IHNldHRpbmcgb2YgcG9zaXRpb25cbiAgICAgICAgcG9pbnRlci5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICBpZiAocG9pbnRlci5wb2ludGVyVHlwZSAhPT0gJ3RvdWNoJykge1xuICAgICAgICAgICAgdGhpcy5tb3VzZS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGV2aWNlcy5nZXQoa2V5RGVmLnBvaW50ZXJUeXBlKS5hZGRQcmVzc2VkKGtleURlZik7XG4gICAgICAgIHRoaXMuYnV0dG9ucy5kb3duKGtleURlZik7XG4gICAgICAgIHBvaW50ZXIuZG93bihpbnN0YW5jZSwga2V5RGVmKTtcbiAgICAgICAgaWYgKHBvaW50ZXIucG9pbnRlclR5cGUgIT09ICd0b3VjaCcgJiYgIXBvaW50ZXIuaXNQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW91c2UuZG93bihpbnN0YW5jZSwga2V5RGVmLCBwb2ludGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBtb3ZlKGluc3RhbmNlLCBwb2ludGVyTmFtZSwgcG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgcG9pbnRlciA9IHRoaXMucG9pbnRlcnMuZ2V0KHBvaW50ZXJOYW1lKTtcbiAgICAgICAgLy8gSW4gKHNvbWU/KSBicm93c2VycyB0aGlzIG9yZGVyIG9mIGV2ZW50cyBjYW4gYmUgb2JzZXJ2ZWQuXG4gICAgICAgIC8vIFRoaXMgaW50ZXJ3ZWF2aW5nIG9mIGV2ZW50cyBpcyBwcm9iYWJseSB1bm5lY2Vzc2FyeS5cbiAgICAgICAgLy8gV2hpbGUgdGhlIG9yZGVyIG9mIG1vdXNlIChvciBwb2ludGVyKSBldmVudHMgaXMgZGVmaW5lZCBwZXIgc3BlYyxcbiAgICAgICAgLy8gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgaW50ZXJ3ZWF2ZS9mb2xsb3cgb24gYSB1c2VyIGludGVyYWN0aW9uIGRlcGVuZHMgb24gdGhlIGltcGxlbWVudGF0aW9uLlxuICAgICAgICBjb25zdCBwb2ludGVybW92ZSA9IHBvaW50ZXIubW92ZShpbnN0YW5jZSwgcG9zaXRpb24pO1xuICAgICAgICBjb25zdCBtb3VzZW1vdmUgPSBwb2ludGVyLnBvaW50ZXJUeXBlID09PSAndG91Y2gnIHx8IHBvaW50ZXIuaXNQcmV2ZW50ZWQgJiYgcG9pbnRlci5pc0Rvd24gPyB1bmRlZmluZWQgOiB0aGlzLm1vdXNlLm1vdmUoaW5zdGFuY2UsIHBvc2l0aW9uKTtcbiAgICAgICAgcG9pbnRlcm1vdmUgPT09IG51bGwgfHwgcG9pbnRlcm1vdmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvaW50ZXJtb3ZlLmxlYXZlKCk7XG4gICAgICAgIG1vdXNlbW92ZSA9PT0gbnVsbCB8fCBtb3VzZW1vdmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1vdXNlbW92ZS5sZWF2ZSgpO1xuICAgICAgICBwb2ludGVybW92ZSA9PT0gbnVsbCB8fCBwb2ludGVybW92ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9pbnRlcm1vdmUuZW50ZXIoKTtcbiAgICAgICAgbW91c2Vtb3ZlID09PSBudWxsIHx8IG1vdXNlbW92ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbW91c2Vtb3ZlLmVudGVyKCk7XG4gICAgICAgIHBvaW50ZXJtb3ZlID09PSBudWxsIHx8IHBvaW50ZXJtb3ZlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwb2ludGVybW92ZS5tb3ZlKCk7XG4gICAgICAgIG1vdXNlbW92ZSA9PT0gbnVsbCB8fCBtb3VzZW1vdmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1vdXNlbW92ZS5tb3ZlKCk7XG4gICAgfVxuICAgIGFzeW5jIHJlbGVhc2UoaW5zdGFuY2UsIGtleURlZiwgcG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgZGV2aWNlID0gdGhpcy5kZXZpY2VzLmdldChrZXlEZWYucG9pbnRlclR5cGUpO1xuICAgICAgICBkZXZpY2UucmVtb3ZlUHJlc3NlZChrZXlEZWYpO1xuICAgICAgICB0aGlzLmJ1dHRvbnMudXAoa2V5RGVmKTtcbiAgICAgICAgY29uc3QgcG9pbnRlciA9IHRoaXMucG9pbnRlcnMuZ2V0KHRoaXMuZ2V0UG9pbnRlck5hbWUoa2V5RGVmKSk7XG4gICAgICAgIC8vIFRPRE86IGRlcHJlY2F0ZSB0aGUgZm9sbG93aW5nIGltcGxpY2l0IHNldHRpbmcgb2YgcG9zaXRpb25cbiAgICAgICAgcG9pbnRlci5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICBpZiAocG9pbnRlci5wb2ludGVyVHlwZSAhPT0gJ3RvdWNoJykge1xuICAgICAgICAgICAgdGhpcy5tb3VzZS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXZpY2UuY291bnRQcmVzc2VkID09PSAwKSB7XG4gICAgICAgICAgICBwb2ludGVyLnVwKGluc3RhbmNlLCBrZXlEZWYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb2ludGVyLnBvaW50ZXJUeXBlID09PSAndG91Y2gnKSB7XG4gICAgICAgICAgICBwb2ludGVyLnJlbGVhc2UoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcG9pbnRlci5pc1ByZXZlbnRlZCkge1xuICAgICAgICAgICAgaWYgKHBvaW50ZXIucG9pbnRlclR5cGUgPT09ICd0b3VjaCcgJiYgIXBvaW50ZXIuaXNNdWx0aXRvdWNoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW91c2Vtb3ZlID0gdGhpcy5tb3VzZS5tb3ZlKGluc3RhbmNlLCBwb2ludGVyLnBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBtb3VzZW1vdmUgPT09IG51bGwgfHwgbW91c2Vtb3ZlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb3VzZW1vdmUubGVhdmUoKTtcbiAgICAgICAgICAgICAgICBtb3VzZW1vdmUgPT09IG51bGwgfHwgbW91c2Vtb3ZlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb3VzZW1vdmUuZW50ZXIoKTtcbiAgICAgICAgICAgICAgICBtb3VzZW1vdmUgPT09IG51bGwgfHwgbW91c2Vtb3ZlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb3VzZW1vdmUubW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMubW91c2UuZG93bihpbnN0YW5jZSwga2V5RGVmLCBwb2ludGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcG9pbnRlci5pc011bHRpdG91Y2gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtb3VzZW1vdmUxID0gdGhpcy5tb3VzZS5tb3ZlKGluc3RhbmNlLCBwb2ludGVyLnBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBtb3VzZW1vdmUxID09PSBudWxsIHx8IG1vdXNlbW92ZTEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1vdXNlbW92ZTEubGVhdmUoKTtcbiAgICAgICAgICAgICAgICBtb3VzZW1vdmUxID09PSBudWxsIHx8IG1vdXNlbW92ZTEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1vdXNlbW92ZTEuZW50ZXIoKTtcbiAgICAgICAgICAgICAgICBtb3VzZW1vdmUxID09PSBudWxsIHx8IG1vdXNlbW92ZTEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1vdXNlbW92ZTEubW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMubW91c2UudXAoaW5zdGFuY2UsIGtleURlZiwgcG9pbnRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UG9pbnRlck5hbWUoa2V5RGVmKSB7XG4gICAgICAgIHJldHVybiBrZXlEZWYucG9pbnRlclR5cGUgPT09ICd0b3VjaCcgPyBrZXlEZWYubmFtZSA6IGtleURlZi5wb2ludGVyVHlwZTtcbiAgICB9XG4gICAgZ2V0UHJldmlvdXNQb3NpdGlvbihwb2ludGVyTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb2ludGVycy5oYXMocG9pbnRlck5hbWUpID8gdGhpcy5wb2ludGVycy5nZXQocG9pbnRlck5hbWUpLnBvc2l0aW9uIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXNldENsaWNrQ291bnQoKSB7XG4gICAgICAgIHRoaXMubW91c2UucmVzZXRDbGlja0NvdW50KCk7XG4gICAgfVxuICAgIGdldE1vdXNlVGFyZ2V0KGluc3RhbmNlKSB7XG4gICAgICAgIHZhciBfdGFyZ2V0O1xuICAgICAgICByZXR1cm4gKF90YXJnZXQgPSB0aGlzLm1vdXNlLnBvc2l0aW9uLnRhcmdldCkgIT09IG51bGwgJiYgX3RhcmdldCAhPT0gdm9pZCAwID8gX3RhcmdldCA6IGluc3RhbmNlLmNvbmZpZy5kb2N1bWVudC5ib2R5O1xuICAgIH1cbiAgICBzZXRNb3VzZVBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMubW91c2UucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgdGhpcy5wb2ludGVycy5nZXQoJ21vdXNlJykucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc3lzdGVtKXtcbiAgICAgICAgdGhpcy5kZXZpY2VzID0gbmV3IGNsYXNzIHtcbiAgICAgICAgICAgIGdldChrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgICAgICAgICAocmVmID0gKF9yZWdpc3RyeSA9IHRoaXMucmVnaXN0cnkpW19rID0ga10pICE9PSBudWxsICYmIHJlZiAhPT0gdm9pZCAwID8gcmVmIDogX3JlZ2lzdHJ5W19rXSA9IG5ldyBEZXZpY2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RyeVtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWdpc3RyeSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KCk7XG4gICAgICAgIHRoaXMucG9pbnRlcnMgPSBuZXcgY2xhc3Mge1xuICAgICAgICAgICAgbmV3KHBvaW50ZXJOYW1lLCBrZXlEZWYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1ByaW1hcnkgPSBrZXlEZWYucG9pbnRlclR5cGUgIT09ICd0b3VjaCcgfHwgIU9iamVjdC52YWx1ZXModGhpcy5yZWdpc3RyeSkuc29tZSgocCk9PnAucG9pbnRlclR5cGUgPT09ICd0b3VjaCcgJiYgIXAuaXNDYW5jZWxsZWQpO1xuICAgICAgICAgICAgICAgIGlmICghaXNQcmltYXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5yZWdpc3RyeSkuZm9yRWFjaCgocCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwLnBvaW50ZXJUeXBlID09PSBrZXlEZWYucG9pbnRlclR5cGUgJiYgIXAuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmlzTXVsdGl0b3VjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdHJ5W3BvaW50ZXJOYW1lXSA9IG5ldyBQb2ludGVyKHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlcklkOiB0aGlzLm5leHRJZCsrLFxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZToga2V5RGVmLnBvaW50ZXJUeXBlLFxuICAgICAgICAgICAgICAgICAgICBpc1ByaW1hcnlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RyeVtwb2ludGVyTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZXQocG9pbnRlck5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzKHBvaW50ZXJOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyeWluZyB0byBhY2Nlc3MgcG9pbnRlciBcIiR7cG9pbnRlck5hbWV9XCIgd2hpY2ggZG9lcyBub3QgZXhpc3QuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5W3BvaW50ZXJOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhcyhwb2ludGVyTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwb2ludGVyTmFtZSBpbiB0aGlzLnJlZ2lzdHJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdHJ5ID0ge1xuICAgICAgICAgICAgICAgICAgICBtb3VzZTogbmV3IFBvaW50ZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlcklkOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGU6ICdtb3VzZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ByaW1hcnk6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dElkID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSgpO1xuICAgICAgICB0aGlzLnN5c3RlbSA9IHN5c3RlbTtcbiAgICAgICAgdGhpcy5idXR0b25zID0gbmV3IEJ1dHRvbnMoKTtcbiAgICAgICAgdGhpcy5tb3VzZSA9IG5ldyBNb3VzZSgpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgUG9pbnRlckhvc3QgfTtcbiIsImltcG9ydCB7IEtleWJvYXJkSG9zdCB9IGZyb20gJy4va2V5Ym9hcmQuanMnO1xuaW1wb3J0IHsgUG9pbnRlckhvc3QgfSBmcm9tICcuL3BvaW50ZXIvaW5kZXguanMnO1xuXG4vKipcbiAqIEBpbnRlcm5hbCBEbyBub3QgY3JlYXRlL2FsdGVyIHRoaXMgYnkgeW91cnNlbGYgYXMgdGhpcyB0eXBlIG1pZ2h0IGJlIHN1YmplY3QgdG8gY2hhbmdlcy5cbiAqLyBjbGFzcyBTeXN0ZW0ge1xuICAgIGdldFVJRXZlbnRNb2RpZmllcnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhbHRLZXk6IHRoaXMua2V5Ym9hcmQubW9kaWZpZXJzLkFsdCxcbiAgICAgICAgICAgIGN0cmxLZXk6IHRoaXMua2V5Ym9hcmQubW9kaWZpZXJzLkNvbnRyb2wsXG4gICAgICAgICAgICBtZXRhS2V5OiB0aGlzLmtleWJvYXJkLm1vZGlmaWVycy5NZXRhLFxuICAgICAgICAgICAgc2hpZnRLZXk6IHRoaXMua2V5Ym9hcmQubW9kaWZpZXJzLlNoaWZ0LFxuICAgICAgICAgICAgbW9kaWZpZXJBbHRHcmFwaDogdGhpcy5rZXlib2FyZC5tb2RpZmllcnMuQWx0R3JhcGgsXG4gICAgICAgICAgICBtb2RpZmllckNhcHNMb2NrOiB0aGlzLmtleWJvYXJkLm1vZGlmaWVycy5DYXBzTG9jayxcbiAgICAgICAgICAgIG1vZGlmaWVyRm46IHRoaXMua2V5Ym9hcmQubW9kaWZpZXJzLkZuLFxuICAgICAgICAgICAgbW9kaWZpZXJGbkxvY2s6IHRoaXMua2V5Ym9hcmQubW9kaWZpZXJzLkZuTG9jayxcbiAgICAgICAgICAgIG1vZGlmaWVyTnVtTG9jazogdGhpcy5rZXlib2FyZC5tb2RpZmllcnMuTnVtTG9jayxcbiAgICAgICAgICAgIG1vZGlmaWVyU2Nyb2xsTG9jazogdGhpcy5rZXlib2FyZC5tb2RpZmllcnMuU2Nyb2xsTG9jayxcbiAgICAgICAgICAgIG1vZGlmaWVyU3ltYm9sOiB0aGlzLmtleWJvYXJkLm1vZGlmaWVycy5TeW1ib2wsXG4gICAgICAgICAgICBtb2RpZmllclN5bWJvbExvY2s6IHRoaXMua2V5Ym9hcmQubW9kaWZpZXJzLlN5bWJvbExvY2tcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5rZXlib2FyZCA9IG5ldyBLZXlib2FyZEhvc3QodGhpcyk7XG4gICAgICAgIHRoaXMucG9pbnRlciA9IG5ldyBQb2ludGVySG9zdCh0aGlzKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IFN5c3RlbSB9O1xuIiwiYXN5bmMgZnVuY3Rpb24gY2xpY2soZWxlbWVudCkge1xuICAgIGNvbnN0IHBvaW50ZXJJbiA9IFtdO1xuICAgIGlmICghdGhpcy5jb25maWcuc2tpcEhvdmVyKSB7XG4gICAgICAgIHBvaW50ZXJJbi5wdXNoKHtcbiAgICAgICAgICAgIHRhcmdldDogZWxlbWVudFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcG9pbnRlckluLnB1c2goe1xuICAgICAgICBrZXlzOiAnW01vdXNlTGVmdF0nLFxuICAgICAgICB0YXJnZXQ6IGVsZW1lbnRcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5wb2ludGVyKHBvaW50ZXJJbik7XG59XG5hc3luYyBmdW5jdGlvbiBkYmxDbGljayhlbGVtZW50KSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRlcihbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRhcmdldDogZWxlbWVudFxuICAgICAgICB9LFxuICAgICAgICAnW01vdXNlTGVmdF1bTW91c2VMZWZ0XSdcbiAgICBdKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHRyaXBsZUNsaWNrKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gdGhpcy5wb2ludGVyKFtcbiAgICAgICAge1xuICAgICAgICAgICAgdGFyZ2V0OiBlbGVtZW50XG4gICAgICAgIH0sXG4gICAgICAgICdbTW91c2VMZWZ0XVtNb3VzZUxlZnRdW01vdXNlTGVmdF0nXG4gICAgXSk7XG59XG5cbmV4cG9ydCB7IGNsaWNrLCBkYmxDbGljaywgdHJpcGxlQ2xpY2sgfTtcbiIsImltcG9ydCAnLi4vdXRpbHMvY2xpY2svaXNDbGlja2FibGVJbnB1dC5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2RhdGFUcmFuc2Zlci9DbGlwYm9hcmQuanMnO1xuaW1wb3J0ICcuLi91dGlscy9lZGl0L2lzRWRpdGFibGUuanMnO1xuaW1wb3J0ICcuLi91dGlscy9lZGl0L21heExlbmd0aC5qcyc7XG5pbXBvcnQgJ0B0ZXN0aW5nLWxpYnJhcnkvZG9tL2Rpc3QvaGVscGVycy5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2tleURlZi9yZWFkTmV4dERlc2NyaXB0b3IuanMnO1xuaW1wb3J0ICcuLi91dGlscy9taXNjL2xldmVsLmpzJztcbmltcG9ydCB7IGFzc2VydFBvaW50ZXJFdmVudHMgfSBmcm9tICcuLi91dGlscy9wb2ludGVyL2Nzc1BvaW50ZXJFdmVudHMuanMnO1xuXG5hc3luYyBmdW5jdGlvbiBob3ZlcihlbGVtZW50KSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRlcih7XG4gICAgICAgIHRhcmdldDogZWxlbWVudFxuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gdW5ob3ZlcihlbGVtZW50KSB7XG4gICAgYXNzZXJ0UG9pbnRlckV2ZW50cyh0aGlzLCB0aGlzLnN5c3RlbS5wb2ludGVyLmdldE1vdXNlVGFyZ2V0KHRoaXMpKTtcbiAgICByZXR1cm4gdGhpcy5wb2ludGVyKHtcbiAgICAgICAgdGFyZ2V0OiBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keVxuICAgIH0pO1xufVxuXG5leHBvcnQgeyBob3ZlciwgdW5ob3ZlciB9O1xuIiwiYXN5bmMgZnVuY3Rpb24gdGFiKHsgc2hpZnQgIH0gPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmtleWJvYXJkKHNoaWZ0ID09PSB0cnVlID8gJ3tTaGlmdD59e1RhYn17L1NoaWZ0fScgOiBzaGlmdCA9PT0gZmFsc2UgPyAnWy9TaGlmdExlZnRdWy9TaGlmdFJpZ2h0XXtUYWJ9JyA6ICd7VGFifScpO1xufVxuXG5leHBvcnQgeyB0YWIgfTtcbiIsImltcG9ydCAnLi4vdXRpbHMvY2xpY2svaXNDbGlja2FibGVJbnB1dC5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2RhdGFUcmFuc2Zlci9DbGlwYm9hcmQuanMnO1xuaW1wb3J0ICcuLi91dGlscy9lZGl0L2lzRWRpdGFibGUuanMnO1xuaW1wb3J0ICcuLi91dGlscy9lZGl0L21heExlbmd0aC5qcyc7XG5pbXBvcnQgJ0B0ZXN0aW5nLWxpYnJhcnkvZG9tL2Rpc3QvaGVscGVycy5qcyc7XG5pbXBvcnQgeyByZWFkTmV4dERlc2NyaXB0b3IgfSBmcm9tICcuLi91dGlscy9rZXlEZWYvcmVhZE5leHREZXNjcmlwdG9yLmpzJztcbmltcG9ydCAnLi4vdXRpbHMvbWlzYy9sZXZlbC5qcyc7XG5pbXBvcnQgJy4uL29wdGlvbnMuanMnO1xuXG4vKipcbiAqIFBhcnNlIGtleSBkZWZpbnRpb25zIHBlciBga2V5Ym9hcmRNYXBgXG4gKlxuICogS2V5cyBjYW4gYmUgcmVmZXJlbmNlZCBieSBge2tleX1gIG9yIGB7c3BlY2lhbH1gIGFzIHdlbGwgYXMgcGh5c2ljYWwgbG9jYXRpb25zIHBlciBgW2NvZGVdYC5cbiAqIEV2ZXJ5dGhpbmcgZWxzZSB3aWxsIGJlIGludGVycHJldGVkIGFzIGEgdHlwZWQgY2hhcmFjdGVyIC0gZS5nLiBgYWAuXG4gKiBCcmFja2V0cyBge2AgYW5kIGBbYCBjYW4gYmUgZXNjYXBlZCBieSBkb3VibGluZyAtIGUuZy4gYGZvb1tbYmFyYCB0cmFuc2xhdGVzIHRvIGBmb29bYmFyYC5cbiAqIEtlZXBpbmcgdGhlIGtleSBwcmVzc2VkIGNhbiBiZSB3cml0dGVuIGFzIGB7a2V5Pn1gLlxuICogV2hlbiBrZWVwaW5nIHRoZSBrZXkgcHJlc3NlZCB5b3UgY2FuIGNob29zZSBob3cgbG9uZyAoaG93IG1hbnkga2V5ZG93biBhbmQga2V5cHJlc3MpIHRoZSBrZXkgaXMgcHJlc3NlZCBge2tleT4zfWAuXG4gKiBZb3UgY2FuIHRoZW4gcmVsZWFzZSB0aGUga2V5IHBlciBge2tleT4zL31gIG9yIGtlZXAgaXQgcHJlc3NlZCBhbmQgY29udGludWUgd2l0aCB0aGUgbmV4dCBrZXkuXG4gKi8gZnVuY3Rpb24gcGFyc2VLZXlEZWYoa2V5Ym9hcmRNYXAsIHRleHQpIHtcbiAgICBjb25zdCBkZWZzID0gW107XG4gICAgZG8ge1xuICAgICAgICBjb25zdCB7IHR5cGUgLCBkZXNjcmlwdG9yICwgY29uc3VtZWRMZW5ndGggLCByZWxlYXNlUHJldmlvdXMgLCByZWxlYXNlU2VsZiA9dHJ1ZSAsIHJlcGVhdCAsICB9ID0gcmVhZE5leHREZXNjcmlwdG9yKHRleHQsICdrZXlib2FyZCcpO1xuICAgICAgICB2YXIgcmVmO1xuICAgICAgICBjb25zdCBrZXlEZWYgPSAocmVmID0ga2V5Ym9hcmRNYXAuZmluZCgoZGVmKT0+e1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdbJykge1xuICAgICAgICAgICAgICAgIHZhciByZWY7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgocmVmID0gZGVmLmNvZGUpID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmLnRvTG93ZXJDYXNlKCkpID09PSBkZXNjcmlwdG9yLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd7Jykge1xuICAgICAgICAgICAgICAgIHZhciByZWYxO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKHJlZjEgPSBkZWYua2V5KSA9PT0gbnVsbCB8fCByZWYxID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYxLnRvTG93ZXJDYXNlKCkpID09PSBkZXNjcmlwdG9yLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVmLmtleSA9PT0gZGVzY3JpcHRvcjtcbiAgICAgICAgfSkpICE9PSBudWxsICYmIHJlZiAhPT0gdm9pZCAwID8gcmVmIDoge1xuICAgICAgICAgICAga2V5OiAnVW5rbm93bicsXG4gICAgICAgICAgICBjb2RlOiAnVW5rbm93bicsXG4gICAgICAgICAgICBbdHlwZSA9PT0gJ1snID8gJ2NvZGUnIDogJ2tleSddOiBkZXNjcmlwdG9yXG4gICAgICAgIH07XG4gICAgICAgIGRlZnMucHVzaCh7XG4gICAgICAgICAgICBrZXlEZWYsXG4gICAgICAgICAgICByZWxlYXNlUHJldmlvdXMsXG4gICAgICAgICAgICByZWxlYXNlU2VsZixcbiAgICAgICAgICAgIHJlcGVhdFxuICAgICAgICB9KTtcbiAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoY29uc3VtZWRMZW5ndGgpO1xuICAgIH13aGlsZSAodGV4dClcbiAgICByZXR1cm4gZGVmcztcbn1cblxuZXhwb3J0IHsgcGFyc2VLZXlEZWYgfTtcbiIsImltcG9ydCAnLi4vdXRpbHMvY2xpY2svaXNDbGlja2FibGVJbnB1dC5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2RhdGFUcmFuc2Zlci9DbGlwYm9hcmQuanMnO1xuaW1wb3J0ICcuLi91dGlscy9lZGl0L2lzRWRpdGFibGUuanMnO1xuaW1wb3J0ICcuLi91dGlscy9lZGl0L21heExlbmd0aC5qcyc7XG5pbXBvcnQgJ0B0ZXN0aW5nLWxpYnJhcnkvZG9tL2Rpc3QvaGVscGVycy5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2tleURlZi9yZWFkTmV4dERlc2NyaXB0b3IuanMnO1xuaW1wb3J0ICcuLi91dGlscy9taXNjL2xldmVsLmpzJztcbmltcG9ydCB7IHdhaXQgfSBmcm9tICcuLi91dGlscy9taXNjL3dhaXQuanMnO1xuaW1wb3J0ICcuLi9vcHRpb25zLmpzJztcbmltcG9ydCB7IHBhcnNlS2V5RGVmIH0gZnJvbSAnLi9wYXJzZUtleURlZi5qcyc7XG5cbmFzeW5jIGZ1bmN0aW9uIGtleWJvYXJkKHRleHQpIHtcbiAgICBjb25zdCBhY3Rpb25zID0gcGFyc2VLZXlEZWYodGhpcy5jb25maWcua2V5Ym9hcmRNYXAsIHRleHQpO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBhY3Rpb25zLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgYXdhaXQgd2FpdCh0aGlzLmNvbmZpZyk7XG4gICAgICAgIGF3YWl0IGtleWJvYXJkQWN0aW9uKHRoaXMsIGFjdGlvbnNbaV0pO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGtleWJvYXJkQWN0aW9uKGluc3RhbmNlLCB7IGtleURlZiAsIHJlbGVhc2VQcmV2aW91cyAsIHJlbGVhc2VTZWxmICwgcmVwZWF0ICB9KSB7XG4gICAgY29uc3QgeyBzeXN0ZW0gIH0gPSBpbnN0YW5jZTtcbiAgICAvLyBSZWxlYXNlIHRoZSBrZXkgYXV0b21hdGljYWxseSBpZiBpdCB3YXMgcHJlc3NlZCBiZWZvcmUuXG4gICAgaWYgKHN5c3RlbS5rZXlib2FyZC5pc0tleVByZXNzZWQoa2V5RGVmKSkge1xuICAgICAgICBhd2FpdCBzeXN0ZW0ua2V5Ym9hcmQua2V5dXAoaW5zdGFuY2UsIGtleURlZik7XG4gICAgfVxuICAgIGlmICghcmVsZWFzZVByZXZpb3VzKSB7XG4gICAgICAgIGZvcihsZXQgaSA9IDE7IGkgPD0gcmVwZWF0OyBpKyspe1xuICAgICAgICAgICAgYXdhaXQgc3lzdGVtLmtleWJvYXJkLmtleWRvd24oaW5zdGFuY2UsIGtleURlZik7XG4gICAgICAgICAgICBpZiAoaSA8IHJlcGVhdCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHdhaXQoaW5zdGFuY2UuY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZWxlYXNlIHRoZSBrZXkgb25seSBvbiB0aGUgbGFzdCBpdGVyYXRpb24gb24gYHN0YXRlLnJlcGVhdEtleWAuXG4gICAgICAgIGlmIChyZWxlYXNlU2VsZikge1xuICAgICAgICAgICAgYXdhaXQgc3lzdGVtLmtleWJvYXJkLmtleXVwKGluc3RhbmNlLCBrZXlEZWYpO1xuICAgICAgICB9XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gcmVsZWFzZUFsbEtleXMoaW5zdGFuY2UpIHtcbiAgICBmb3IgKGNvbnN0IGsgb2YgaW5zdGFuY2Uuc3lzdGVtLmtleWJvYXJkLmdldFByZXNzZWRLZXlzKCkpe1xuICAgICAgICBhd2FpdCBpbnN0YW5jZS5zeXN0ZW0ua2V5Ym9hcmQua2V5dXAoaW5zdGFuY2UsIGspO1xuICAgIH1cbn1cblxuZXhwb3J0IHsga2V5Ym9hcmQsIHJlbGVhc2VBbGxLZXlzIH07XG4iLCJpbXBvcnQgJy4uL3V0aWxzL2NsaWNrL2lzQ2xpY2thYmxlSW5wdXQuanMnO1xuaW1wb3J0IHsgY3JlYXRlRGF0YVRyYW5zZmVyIH0gZnJvbSAnLi4vdXRpbHMvZGF0YVRyYW5zZmVyL0RhdGFUcmFuc2Zlci5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2RhdGFUcmFuc2Zlci9DbGlwYm9hcmQuanMnO1xuaW1wb3J0ICcuLi91dGlscy9lZGl0L2lzRWRpdGFibGUuanMnO1xuaW1wb3J0ICcuLi91dGlscy9lZGl0L21heExlbmd0aC5qcyc7XG5pbXBvcnQgeyBnZXRXaW5kb3cgfSBmcm9tICcuLi91dGlscy9taXNjL2dldFdpbmRvdy5qcyc7XG5pbXBvcnQgeyBoYXNPd25TZWxlY3Rpb24gfSBmcm9tICcuLi91dGlscy9mb2N1cy9zZWxlY3Rpb24uanMnO1xuaW1wb3J0ICcuLi91dGlscy9rZXlEZWYvcmVhZE5leHREZXNjcmlwdG9yLmpzJztcbmltcG9ydCAnLi4vdXRpbHMvbWlzYy9sZXZlbC5qcyc7XG5pbXBvcnQgJy4uL29wdGlvbnMuanMnO1xuaW1wb3J0IHsgZ2V0VUlTZWxlY3Rpb24sIGdldFVJVmFsdWUgfSBmcm9tICcuL1VJLmpzJztcblxuZnVuY3Rpb24gY29weVNlbGVjdGlvbih0YXJnZXQpIHtcbiAgICBjb25zdCBkYXRhID0gaGFzT3duU2VsZWN0aW9uKHRhcmdldCkgPyB7XG4gICAgICAgICd0ZXh0L3BsYWluJzogcmVhZFNlbGVjdGVkVmFsdWVGcm9tSW5wdXQodGFyZ2V0KVxuICAgIH0gOiB7XG4gICAgICAgICd0ZXh0L3BsYWluJzogU3RyaW5nKHRhcmdldC5vd25lckRvY3VtZW50LmdldFNlbGVjdGlvbigpKVxuICAgIH07XG4gICAgY29uc3QgZHQgPSBjcmVhdGVEYXRhVHJhbnNmZXIoZ2V0V2luZG93KHRhcmdldCkpO1xuICAgIGZvcihjb25zdCB0eXBlIGluIGRhdGEpe1xuICAgICAgICBpZiAoZGF0YVt0eXBlXSkge1xuICAgICAgICAgICAgZHQuc2V0RGF0YSh0eXBlLCBkYXRhW3R5cGVdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZHQ7XG59XG5mdW5jdGlvbiByZWFkU2VsZWN0ZWRWYWx1ZUZyb21JbnB1dCh0YXJnZXQpIHtcbiAgICBjb25zdCBzZWwgPSBnZXRVSVNlbGVjdGlvbih0YXJnZXQpO1xuICAgIGNvbnN0IHZhbCA9IGdldFVJVmFsdWUodGFyZ2V0KTtcbiAgICByZXR1cm4gdmFsLnN1YnN0cmluZyhzZWwuc3RhcnRPZmZzZXQsIHNlbC5lbmRPZmZzZXQpO1xufVxuXG5leHBvcnQgeyBjb3B5U2VsZWN0aW9uIH07XG4iLCJpbXBvcnQgJy4uL3V0aWxzL2NsaWNrL2lzQ2xpY2thYmxlSW5wdXQuanMnO1xuaW1wb3J0IHsgd3JpdGVEYXRhVHJhbnNmZXJUb0NsaXBib2FyZCB9IGZyb20gJy4uL3V0aWxzL2RhdGFUcmFuc2Zlci9DbGlwYm9hcmQuanMnO1xuaW1wb3J0ICcuLi91dGlscy9lZGl0L2lzRWRpdGFibGUuanMnO1xuaW1wb3J0ICcuLi91dGlscy9lZGl0L21heExlbmd0aC5qcyc7XG5pbXBvcnQgJ0B0ZXN0aW5nLWxpYnJhcnkvZG9tL2Rpc3QvaGVscGVycy5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2tleURlZi9yZWFkTmV4dERlc2NyaXB0b3IuanMnO1xuaW1wb3J0ICcuLi91dGlscy9taXNjL2xldmVsLmpzJztcbmltcG9ydCAnLi4vb3B0aW9ucy5qcyc7XG5pbXBvcnQgeyBjb3B5U2VsZWN0aW9uIH0gZnJvbSAnLi4vZG9jdW1lbnQvY29weVNlbGVjdGlvbi5qcyc7XG5cbmFzeW5jIGZ1bmN0aW9uIGNvcHkoKSB7XG4gICAgY29uc3QgZG9jID0gdGhpcy5jb25maWcuZG9jdW1lbnQ7XG4gICAgdmFyIF9hY3RpdmVFbGVtZW50O1xuICAgIGNvbnN0IHRhcmdldCA9IChfYWN0aXZlRWxlbWVudCA9IGRvYy5hY3RpdmVFbGVtZW50KSAhPT0gbnVsbCAmJiBfYWN0aXZlRWxlbWVudCAhPT0gdm9pZCAwID8gX2FjdGl2ZUVsZW1lbnQgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBkb2MuYm9keTtcbiAgICBjb25zdCBjbGlwYm9hcmREYXRhID0gY29weVNlbGVjdGlvbih0YXJnZXQpO1xuICAgIGlmIChjbGlwYm9hcmREYXRhLml0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmRpc3BhdGNoVUlFdmVudCh0YXJnZXQsICdjb3B5Jywge1xuICAgICAgICBjbGlwYm9hcmREYXRhXG4gICAgfSkgJiYgdGhpcy5jb25maWcud3JpdGVUb0NsaXBib2FyZCkge1xuICAgICAgICBhd2FpdCB3cml0ZURhdGFUcmFuc2ZlclRvQ2xpcGJvYXJkKGRvYywgY2xpcGJvYXJkRGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBjbGlwYm9hcmREYXRhO1xufVxuXG5leHBvcnQgeyBjb3B5IH07XG4iLCJpbXBvcnQgJy4uL3V0aWxzL2NsaWNrL2lzQ2xpY2thYmxlSW5wdXQuanMnO1xuaW1wb3J0IHsgd3JpdGVEYXRhVHJhbnNmZXJUb0NsaXBib2FyZCB9IGZyb20gJy4uL3V0aWxzL2RhdGFUcmFuc2Zlci9DbGlwYm9hcmQuanMnO1xuaW1wb3J0ICcuLi91dGlscy9lZGl0L2lzRWRpdGFibGUuanMnO1xuaW1wb3J0ICcuLi91dGlscy9lZGl0L21heExlbmd0aC5qcyc7XG5pbXBvcnQgJ0B0ZXN0aW5nLWxpYnJhcnkvZG9tL2Rpc3QvaGVscGVycy5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2tleURlZi9yZWFkTmV4dERlc2NyaXB0b3IuanMnO1xuaW1wb3J0ICcuLi91dGlscy9taXNjL2xldmVsLmpzJztcbmltcG9ydCAnLi4vb3B0aW9ucy5qcyc7XG5pbXBvcnQgeyBjb3B5U2VsZWN0aW9uIH0gZnJvbSAnLi4vZG9jdW1lbnQvY29weVNlbGVjdGlvbi5qcyc7XG5cbmFzeW5jIGZ1bmN0aW9uIGN1dCgpIHtcbiAgICBjb25zdCBkb2MgPSB0aGlzLmNvbmZpZy5kb2N1bWVudDtcbiAgICB2YXIgX2FjdGl2ZUVsZW1lbnQ7XG4gICAgY29uc3QgdGFyZ2V0ID0gKF9hY3RpdmVFbGVtZW50ID0gZG9jLmFjdGl2ZUVsZW1lbnQpICE9PSBudWxsICYmIF9hY3RpdmVFbGVtZW50ICE9PSB2b2lkIDAgPyBfYWN0aXZlRWxlbWVudCA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGRvYy5ib2R5O1xuICAgIGNvbnN0IGNsaXBib2FyZERhdGEgPSBjb3B5U2VsZWN0aW9uKHRhcmdldCk7XG4gICAgaWYgKGNsaXBib2FyZERhdGEuaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGlzcGF0Y2hVSUV2ZW50KHRhcmdldCwgJ2N1dCcsIHtcbiAgICAgICAgY2xpcGJvYXJkRGF0YVxuICAgIH0pICYmIHRoaXMuY29uZmlnLndyaXRlVG9DbGlwYm9hcmQpIHtcbiAgICAgICAgYXdhaXQgd3JpdGVEYXRhVHJhbnNmZXJUb0NsaXBib2FyZCh0YXJnZXQub3duZXJEb2N1bWVudCwgY2xpcGJvYXJkRGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBjbGlwYm9hcmREYXRhO1xufVxuXG5leHBvcnQgeyBjdXQgfTtcbiIsImltcG9ydCAnLi4vdXRpbHMvY2xpY2svaXNDbGlja2FibGVJbnB1dC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVEYXRhVHJhbnNmZXIgfSBmcm9tICcuLi91dGlscy9kYXRhVHJhbnNmZXIvRGF0YVRyYW5zZmVyLmpzJztcbmltcG9ydCB7IHJlYWREYXRhVHJhbnNmZXJGcm9tQ2xpcGJvYXJkIH0gZnJvbSAnLi4vdXRpbHMvZGF0YVRyYW5zZmVyL0NsaXBib2FyZC5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2VkaXQvaXNFZGl0YWJsZS5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2VkaXQvbWF4TGVuZ3RoLmpzJztcbmltcG9ydCB7IGdldFdpbmRvdyB9IGZyb20gJy4uL3V0aWxzL21pc2MvZ2V0V2luZG93LmpzJztcbmltcG9ydCAnLi4vdXRpbHMva2V5RGVmL3JlYWROZXh0RGVzY3JpcHRvci5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL21pc2MvbGV2ZWwuanMnO1xuaW1wb3J0ICcuLi9vcHRpb25zLmpzJztcblxuYXN5bmMgZnVuY3Rpb24gcGFzdGUoY2xpcGJvYXJkRGF0YSkge1xuICAgIGNvbnN0IGRvYyA9IHRoaXMuY29uZmlnLmRvY3VtZW50O1xuICAgIHZhciBfYWN0aXZlRWxlbWVudDtcbiAgICBjb25zdCB0YXJnZXQgPSAoX2FjdGl2ZUVsZW1lbnQgPSBkb2MuYWN0aXZlRWxlbWVudCkgIT09IG51bGwgJiYgX2FjdGl2ZUVsZW1lbnQgIT09IHZvaWQgMCA/IF9hY3RpdmVFbGVtZW50IDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZG9jLmJvZHk7XG4gICAgdmFyIHJlZjtcbiAgICBjb25zdCBkYXRhVHJhbnNmZXIgPSAocmVmID0gdHlwZW9mIGNsaXBib2FyZERhdGEgPT09ICdzdHJpbmcnID8gZ2V0Q2xpcGJvYXJkRGF0YUZyb21TdHJpbmcoZG9jLCBjbGlwYm9hcmREYXRhKSA6IGNsaXBib2FyZERhdGEpICE9PSBudWxsICYmIHJlZiAhPT0gdm9pZCAwID8gcmVmIDogYXdhaXQgcmVhZERhdGFUcmFuc2ZlckZyb21DbGlwYm9hcmQoZG9jKS5jYXRjaCgoKT0+e1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B1c2VyRXZlbnQucGFzdGUoKWAgd2l0aG91dCBgY2xpcGJvYXJkRGF0YWAgcmVxdWlyZXMgdGhlIGBDbGlwYm9hcmRBUElgIHRvIGJlIGF2YWlsYWJsZS4nKTtcbiAgICB9KTtcbiAgICB0aGlzLmRpc3BhdGNoVUlFdmVudCh0YXJnZXQsICdwYXN0ZScsIHtcbiAgICAgICAgY2xpcGJvYXJkRGF0YTogZGF0YVRyYW5zZmVyXG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRDbGlwYm9hcmREYXRhRnJvbVN0cmluZyhkb2MsIHRleHQpIHtcbiAgICBjb25zdCBkdCA9IGNyZWF0ZURhdGFUcmFuc2ZlcihnZXRXaW5kb3coZG9jKSk7XG4gICAgZHQuc2V0RGF0YSgndGV4dCcsIHRleHQpO1xuICAgIHJldHVybiBkdDtcbn1cblxuZXhwb3J0IHsgcGFzdGUgfTtcbiIsImltcG9ydCAnLi4vdXRpbHMvY2xpY2svaXNDbGlja2FibGVJbnB1dC5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2RhdGFUcmFuc2Zlci9DbGlwYm9hcmQuanMnO1xuaW1wb3J0ICcuLi91dGlscy9lZGl0L2lzRWRpdGFibGUuanMnO1xuaW1wb3J0ICcuLi91dGlscy9lZGl0L21heExlbmd0aC5qcyc7XG5pbXBvcnQgJ0B0ZXN0aW5nLWxpYnJhcnkvZG9tL2Rpc3QvaGVscGVycy5qcyc7XG5pbXBvcnQgeyByZWFkTmV4dERlc2NyaXB0b3IgfSBmcm9tICcuLi91dGlscy9rZXlEZWYvcmVhZE5leHREZXNjcmlwdG9yLmpzJztcbmltcG9ydCAnLi4vdXRpbHMvbWlzYy9sZXZlbC5qcyc7XG5pbXBvcnQgJy4uL29wdGlvbnMuanMnO1xuXG5mdW5jdGlvbiBwYXJzZUtleURlZihwb2ludGVyTWFwLCBrZXlzKSB7XG4gICAgY29uc3QgZGVmcyA9IFtdO1xuICAgIGRvIHtcbiAgICAgICAgY29uc3QgeyBkZXNjcmlwdG9yICwgY29uc3VtZWRMZW5ndGggLCByZWxlYXNlUHJldmlvdXMgLCByZWxlYXNlU2VsZiA9dHJ1ZSAsICB9ID0gcmVhZE5leHREZXNjcmlwdG9yKGtleXMsICdwb2ludGVyJyk7XG4gICAgICAgIGNvbnN0IGtleURlZiA9IHBvaW50ZXJNYXAuZmluZCgocCk9PnAubmFtZSA9PT0gZGVzY3JpcHRvcik7XG4gICAgICAgIGlmIChrZXlEZWYpIHtcbiAgICAgICAgICAgIGRlZnMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5RGVmLFxuICAgICAgICAgICAgICAgIHJlbGVhc2VQcmV2aW91cyxcbiAgICAgICAgICAgICAgICByZWxlYXNlU2VsZlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAga2V5cyA9IGtleXMuc2xpY2UoY29uc3VtZWRMZW5ndGgpO1xuICAgIH13aGlsZSAoa2V5cylcbiAgICByZXR1cm4gZGVmcztcbn1cblxuZXhwb3J0IHsgcGFyc2VLZXlEZWYgfTtcbiIsImltcG9ydCAnLi4vdXRpbHMvY2xpY2svaXNDbGlja2FibGVJbnB1dC5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2RhdGFUcmFuc2Zlci9DbGlwYm9hcmQuanMnO1xuaW1wb3J0ICcuLi91dGlscy9lZGl0L2lzRWRpdGFibGUuanMnO1xuaW1wb3J0ICcuLi91dGlscy9lZGl0L21heExlbmd0aC5qcyc7XG5pbXBvcnQgJ0B0ZXN0aW5nLWxpYnJhcnkvZG9tL2Rpc3QvaGVscGVycy5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2tleURlZi9yZWFkTmV4dERlc2NyaXB0b3IuanMnO1xuaW1wb3J0IHsgc2V0TGV2ZWxSZWYsIEFwaUxldmVsIH0gZnJvbSAnLi4vdXRpbHMvbWlzYy9sZXZlbC5qcyc7XG5pbXBvcnQgeyB3YWl0IH0gZnJvbSAnLi4vdXRpbHMvbWlzYy93YWl0LmpzJztcbmltcG9ydCAnLi4vb3B0aW9ucy5qcyc7XG5pbXBvcnQgeyBwYXJzZUtleURlZiB9IGZyb20gJy4vcGFyc2VLZXlEZWYuanMnO1xuXG5hc3luYyBmdW5jdGlvbiBwb2ludGVyKGlucHV0KSB7XG4gICAgY29uc3QgeyBwb2ludGVyTWFwICB9ID0gdGhpcy5jb25maWc7XG4gICAgY29uc3QgYWN0aW9ucyA9IFtdO1xuICAgIChBcnJheS5pc0FycmF5KGlucHV0KSA/IGlucHV0IDogW1xuICAgICAgICBpbnB1dFxuICAgIF0pLmZvckVhY2goKGFjdGlvbklucHV0KT0+e1xuICAgICAgICBpZiAodHlwZW9mIGFjdGlvbklucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKC4uLnBhcnNlS2V5RGVmKHBvaW50ZXJNYXAsIGFjdGlvbklucHV0KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoJ2tleXMnIGluIGFjdGlvbklucHV0KSB7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goLi4ucGFyc2VLZXlEZWYocG9pbnRlck1hcCwgYWN0aW9uSW5wdXQua2V5cykubWFwKChpKT0+KHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYWN0aW9uSW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIC4uLmlcbiAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKGFjdGlvbklucHV0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBhY3Rpb25zLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgYXdhaXQgd2FpdCh0aGlzLmNvbmZpZyk7XG4gICAgICAgIGF3YWl0IHBvaW50ZXJBY3Rpb24odGhpcywgYWN0aW9uc1tpXSk7XG4gICAgfVxuICAgIHRoaXMuc3lzdGVtLnBvaW50ZXIucmVzZXRDbGlja0NvdW50KCk7XG59XG5hc3luYyBmdW5jdGlvbiBwb2ludGVyQWN0aW9uKGluc3RhbmNlLCBhY3Rpb24pIHtcbiAgICB2YXIgcmVmLCByZWYxO1xuICAgIGNvbnN0IHBvaW50ZXJOYW1lID0gJ3BvaW50ZXJOYW1lJyBpbiBhY3Rpb24gJiYgYWN0aW9uLnBvaW50ZXJOYW1lID8gYWN0aW9uLnBvaW50ZXJOYW1lIDogJ2tleURlZicgaW4gYWN0aW9uID8gaW5zdGFuY2Uuc3lzdGVtLnBvaW50ZXIuZ2V0UG9pbnRlck5hbWUoYWN0aW9uLmtleURlZikgOiAnbW91c2UnO1xuICAgIGNvbnN0IHByZXZpb3VzUG9zaXRpb24gPSBpbnN0YW5jZS5zeXN0ZW0ucG9pbnRlci5nZXRQcmV2aW91c1Bvc2l0aW9uKHBvaW50ZXJOYW1lKTtcbiAgICB2YXIgX3RhcmdldCwgX2Nvb3JkcywgX25vZGUsIF9vZmZzZXQ7XG4gICAgY29uc3QgcG9zaXRpb24gPSB7XG4gICAgICAgIHRhcmdldDogKF90YXJnZXQgPSBhY3Rpb24udGFyZ2V0KSAhPT0gbnVsbCAmJiBfdGFyZ2V0ICE9PSB2b2lkIDAgPyBfdGFyZ2V0IDogZ2V0UHJldlRhcmdldChpbnN0YW5jZSwgcHJldmlvdXNQb3NpdGlvbiksXG4gICAgICAgIGNvb3JkczogKF9jb29yZHMgPSBhY3Rpb24uY29vcmRzKSAhPT0gbnVsbCAmJiBfY29vcmRzICE9PSB2b2lkIDAgPyBfY29vcmRzIDogcHJldmlvdXNQb3NpdGlvbiA9PT0gbnVsbCB8fCBwcmV2aW91c1Bvc2l0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmV2aW91c1Bvc2l0aW9uLmNvb3JkcyxcbiAgICAgICAgY2FyZXQ6IHtcbiAgICAgICAgICAgIG5vZGU6IChfbm9kZSA9IGFjdGlvbi5ub2RlKSAhPT0gbnVsbCAmJiBfbm9kZSAhPT0gdm9pZCAwID8gX25vZGUgOiBoYXNDYXJldFBvc2l0aW9uKGFjdGlvbikgPyB1bmRlZmluZWQgOiBwcmV2aW91c1Bvc2l0aW9uID09PSBudWxsIHx8IHByZXZpb3VzUG9zaXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IChyZWYgPSBwcmV2aW91c1Bvc2l0aW9uLmNhcmV0KSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5ub2RlLFxuICAgICAgICAgICAgb2Zmc2V0OiAoX29mZnNldCA9IGFjdGlvbi5vZmZzZXQpICE9PSBudWxsICYmIF9vZmZzZXQgIT09IHZvaWQgMCA/IF9vZmZzZXQgOiBoYXNDYXJldFBvc2l0aW9uKGFjdGlvbikgPyB1bmRlZmluZWQgOiBwcmV2aW91c1Bvc2l0aW9uID09PSBudWxsIHx8IHByZXZpb3VzUG9zaXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IChyZWYxID0gcHJldmlvdXNQb3NpdGlvbi5jYXJldCkgPT09IG51bGwgfHwgcmVmMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmMS5vZmZzZXRcbiAgICAgICAgfVxuICAgIH07XG4gICAgaWYgKCdrZXlEZWYnIGluIGFjdGlvbikge1xuICAgICAgICBpZiAoaW5zdGFuY2Uuc3lzdGVtLnBvaW50ZXIuaXNLZXlQcmVzc2VkKGFjdGlvbi5rZXlEZWYpKSB7XG4gICAgICAgICAgICBzZXRMZXZlbFJlZihpbnN0YW5jZSwgQXBpTGV2ZWwuVHJpZ2dlcik7XG4gICAgICAgICAgICBhd2FpdCBpbnN0YW5jZS5zeXN0ZW0ucG9pbnRlci5yZWxlYXNlKGluc3RhbmNlLCBhY3Rpb24ua2V5RGVmLCBwb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhY3Rpb24ucmVsZWFzZVByZXZpb3VzKSB7XG4gICAgICAgICAgICBzZXRMZXZlbFJlZihpbnN0YW5jZSwgQXBpTGV2ZWwuVHJpZ2dlcik7XG4gICAgICAgICAgICBhd2FpdCBpbnN0YW5jZS5zeXN0ZW0ucG9pbnRlci5wcmVzcyhpbnN0YW5jZSwgYWN0aW9uLmtleURlZiwgcG9zaXRpb24pO1xuICAgICAgICAgICAgaWYgKGFjdGlvbi5yZWxlYXNlU2VsZikge1xuICAgICAgICAgICAgICAgIHNldExldmVsUmVmKGluc3RhbmNlLCBBcGlMZXZlbC5UcmlnZ2VyKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBpbnN0YW5jZS5zeXN0ZW0ucG9pbnRlci5yZWxlYXNlKGluc3RhbmNlLCBhY3Rpb24ua2V5RGVmLCBwb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBzZXRMZXZlbFJlZihpbnN0YW5jZSwgQXBpTGV2ZWwuVHJpZ2dlcik7XG4gICAgICAgIGF3YWl0IGluc3RhbmNlLnN5c3RlbS5wb2ludGVyLm1vdmUoaW5zdGFuY2UsIHBvaW50ZXJOYW1lLCBwb3NpdGlvbik7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzQ2FyZXRQb3NpdGlvbihhY3Rpb24pIHtcbiAgICB2YXIgX3RhcmdldCwgcmVmO1xuICAgIHJldHVybiAhISgocmVmID0gKF90YXJnZXQgPSBhY3Rpb24udGFyZ2V0KSAhPT0gbnVsbCAmJiBfdGFyZ2V0ICE9PSB2b2lkIDAgPyBfdGFyZ2V0IDogYWN0aW9uLm5vZGUpICE9PSBudWxsICYmIHJlZiAhPT0gdm9pZCAwID8gcmVmIDogYWN0aW9uLm9mZnNldCAhPT0gdW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uIGdldFByZXZUYXJnZXQoaW5zdGFuY2UsIHBvc2l0aW9uKSB7XG4gICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgcG9pbnRlciBoYXMgbm8gcHJldmlvdXMgcG9zaXRpb24uIFByb3ZpZGUgYSB0YXJnZXQgcHJvcGVydHkhJyk7XG4gICAgfVxuICAgIHZhciBfdGFyZ2V0O1xuICAgIHJldHVybiAoX3RhcmdldCA9IHBvc2l0aW9uLnRhcmdldCkgIT09IG51bGwgJiYgX3RhcmdldCAhPT0gdm9pZCAwID8gX3RhcmdldCA6IGluc3RhbmNlLmNvbmZpZy5kb2N1bWVudC5ib2R5O1xufVxuXG5leHBvcnQgeyBwb2ludGVyIH07XG4iLCJpbXBvcnQgJy4uL2V2ZW50L2JlaGF2aW9yL2NsaWNrLmpzJztcbmltcG9ydCAnLi4vZXZlbnQvYmVoYXZpb3IvY3V0LmpzJztcbmltcG9ydCAnLi4vZXZlbnQvYmVoYXZpb3Iva2V5ZG93bi5qcyc7XG5pbXBvcnQgJy4uL2V2ZW50L2JlaGF2aW9yL2tleXByZXNzLmpzJztcbmltcG9ydCAnLi4vZXZlbnQvYmVoYXZpb3Iva2V5dXAuanMnO1xuaW1wb3J0ICcuLi9ldmVudC9iZWhhdmlvci9wYXN0ZS5qcyc7XG5pbXBvcnQgJ0B0ZXN0aW5nLWxpYnJhcnkvZG9tJztcbmltcG9ydCAnLi4vZXZlbnQvZXZlbnRNYXAuanMnO1xuaW1wb3J0ICcuLi91dGlscy9jbGljay9pc0NsaWNrYWJsZUlucHV0LmpzJztcbmltcG9ydCAnLi4vdXRpbHMvZGF0YVRyYW5zZmVyL0NsaXBib2FyZC5qcyc7XG5pbXBvcnQgeyBpc0VkaXRhYmxlIH0gZnJvbSAnLi4vdXRpbHMvZWRpdC9pc0VkaXRhYmxlLmpzJztcbmltcG9ydCAnLi4vdXRpbHMvZWRpdC9tYXhMZW5ndGguanMnO1xuaW1wb3J0IHsgaXNEaXNhYmxlZCB9IGZyb20gJy4uL3V0aWxzL21pc2MvaXNEaXNhYmxlZC5qcyc7XG5pbXBvcnQgJ0B0ZXN0aW5nLWxpYnJhcnkvZG9tL2Rpc3QvaGVscGVycy5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2tleURlZi9yZWFkTmV4dERlc2NyaXB0b3IuanMnO1xuaW1wb3J0ICcuLi91dGlscy9taXNjL2xldmVsLmpzJztcbmltcG9ydCAnLi4vb3B0aW9ucy5qcyc7XG5pbXBvcnQgeyBmb2N1c0VsZW1lbnQgfSBmcm9tICcuLi9ldmVudC9mb2N1cy5qcyc7XG5pbXBvcnQgeyBpbnB1dCB9IGZyb20gJy4uL2V2ZW50L2lucHV0LmpzJztcbmltcG9ydCB7IHNlbGVjdEFsbCwgaXNBbGxTZWxlY3RlZCB9IGZyb20gJy4uL2V2ZW50L3NlbGVjdGlvbi9zZWxlY3RBbGwuanMnO1xuXG5hc3luYyBmdW5jdGlvbiBjbGVhcihlbGVtZW50KSB7XG4gICAgaWYgKCFpc0VkaXRhYmxlKGVsZW1lbnQpIHx8IGlzRGlzYWJsZWQoZWxlbWVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhcigpYCBpcyBvbmx5IHN1cHBvcnRlZCBvbiBlZGl0YWJsZSBlbGVtZW50cy4nKTtcbiAgICB9XG4gICAgZm9jdXNFbGVtZW50KGVsZW1lbnQpO1xuICAgIGlmIChlbGVtZW50Lm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWxlbWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBlbGVtZW50IHRvIGJlIGNsZWFyZWQgY291bGQgbm90IGJlIGZvY3VzZWQuJyk7XG4gICAgfVxuICAgIHNlbGVjdEFsbChlbGVtZW50KTtcbiAgICBpZiAoIWlzQWxsU2VsZWN0ZWQoZWxlbWVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZWxlbWVudCBjb250ZW50IHRvIGJlIGNsZWFyZWQgY291bGQgbm90IGJlIHNlbGVjdGVkLicpO1xuICAgIH1cbiAgICBpbnB1dCh0aGlzLCBlbGVtZW50LCAnJywgJ2RlbGV0ZUNvbnRlbnRCYWNrd2FyZCcpO1xufVxuXG5leHBvcnQgeyBjbGVhciB9O1xuIiwiaW1wb3J0IHsgZ2V0Q29uZmlnIH0gZnJvbSAnQHRlc3RpbmctbGlicmFyeS9kb20nO1xuaW1wb3J0ICcuLi91dGlscy9jbGljay9pc0NsaWNrYWJsZUlucHV0LmpzJztcbmltcG9ydCAnLi4vdXRpbHMvZGF0YVRyYW5zZmVyL0NsaXBib2FyZC5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2VkaXQvaXNFZGl0YWJsZS5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2VkaXQvbWF4TGVuZ3RoLmpzJztcbmltcG9ydCB7IGlzRWxlbWVudFR5cGUgfSBmcm9tICcuLi91dGlscy9taXNjL2lzRWxlbWVudFR5cGUuanMnO1xuaW1wb3J0IHsgaXNEaXNhYmxlZCB9IGZyb20gJy4uL3V0aWxzL21pc2MvaXNEaXNhYmxlZC5qcyc7XG5pbXBvcnQgJ0B0ZXN0aW5nLWxpYnJhcnkvZG9tL2Rpc3QvaGVscGVycy5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2tleURlZi9yZWFkTmV4dERlc2NyaXB0b3IuanMnO1xuaW1wb3J0ICcuLi91dGlscy9taXNjL2xldmVsLmpzJztcbmltcG9ydCB7IHdhaXQgfSBmcm9tICcuLi91dGlscy9taXNjL3dhaXQuanMnO1xuaW1wb3J0IHsgaGFzUG9pbnRlckV2ZW50cyB9IGZyb20gJy4uL3V0aWxzL3BvaW50ZXIvY3NzUG9pbnRlckV2ZW50cy5qcyc7XG5pbXBvcnQgJy4uL2V2ZW50L2JlaGF2aW9yL2NsaWNrLmpzJztcbmltcG9ydCAnLi4vZXZlbnQvYmVoYXZpb3IvY3V0LmpzJztcbmltcG9ydCAnLi4vZXZlbnQvYmVoYXZpb3Iva2V5ZG93bi5qcyc7XG5pbXBvcnQgJy4uL2V2ZW50L2JlaGF2aW9yL2tleXByZXNzLmpzJztcbmltcG9ydCAnLi4vZXZlbnQvYmVoYXZpb3Iva2V5dXAuanMnO1xuaW1wb3J0ICcuLi9ldmVudC9iZWhhdmlvci9wYXN0ZS5qcyc7XG5pbXBvcnQgJy4uL2V2ZW50L2V2ZW50TWFwLmpzJztcbmltcG9ydCB7IGZvY3VzRWxlbWVudCB9IGZyb20gJy4uL2V2ZW50L2ZvY3VzLmpzJztcblxuYXN5bmMgZnVuY3Rpb24gc2VsZWN0T3B0aW9ucyhzZWxlY3QsIHZhbHVlcykge1xuICAgIHJldHVybiBzZWxlY3RPcHRpb25zQmFzZS5jYWxsKHRoaXMsIHRydWUsIHNlbGVjdCwgdmFsdWVzKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGRlc2VsZWN0T3B0aW9ucyhzZWxlY3QsIHZhbHVlcykge1xuICAgIHJldHVybiBzZWxlY3RPcHRpb25zQmFzZS5jYWxsKHRoaXMsIGZhbHNlLCBzZWxlY3QsIHZhbHVlcyk7XG59XG5hc3luYyBmdW5jdGlvbiBzZWxlY3RPcHRpb25zQmFzZShuZXdWYWx1ZSwgc2VsZWN0LCB2YWx1ZXMpIHtcbiAgICBpZiAoIW5ld1ZhbHVlICYmICFzZWxlY3QubXVsdGlwbGUpIHtcbiAgICAgICAgdGhyb3cgZ2V0Q29uZmlnKCkuZ2V0RWxlbWVudEVycm9yKGBVbmFibGUgdG8gZGVzZWxlY3QgYW4gb3B0aW9uIGluIGEgbm9uLW11bHRpcGxlIHNlbGVjdC4gVXNlIHNlbGVjdE9wdGlvbnMgdG8gY2hhbmdlIHRoZSBzZWxlY3Rpb24gaW5zdGVhZC5gLCBzZWxlY3QpO1xuICAgIH1cbiAgICBjb25zdCB2YWxBcnJheSA9IEFycmF5LmlzQXJyYXkodmFsdWVzKSA/IHZhbHVlcyA6IFtcbiAgICAgICAgdmFsdWVzXG4gICAgXTtcbiAgICBjb25zdCBhbGxPcHRpb25zID0gQXJyYXkuZnJvbShzZWxlY3QucXVlcnlTZWxlY3RvckFsbCgnb3B0aW9uLCBbcm9sZT1cIm9wdGlvblwiXScpKTtcbiAgICBjb25zdCBzZWxlY3RlZE9wdGlvbnMgPSB2YWxBcnJheS5tYXAoKHZhbCk9PntcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgIT09ICdzdHJpbmcnICYmIGFsbE9wdGlvbnMuaW5jbHVkZXModmFsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nT3B0aW9uID0gYWxsT3B0aW9ucy5maW5kKChvKT0+by52YWx1ZSA9PT0gdmFsIHx8IG8uaW5uZXJIVE1MID09PSB2YWwpO1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoaW5nT3B0aW9uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBnZXRDb25maWcoKS5nZXRFbGVtZW50RXJyb3IoYFZhbHVlIFwiJHtTdHJpbmcodmFsKX1cIiBub3QgZm91bmQgaW4gb3B0aW9uc2AsIHNlbGVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KS5maWx0ZXIoKG9wdGlvbik9PiFpc0Rpc2FibGVkKG9wdGlvbikpO1xuICAgIGlmIChpc0Rpc2FibGVkKHNlbGVjdCkgfHwgIXNlbGVjdGVkT3B0aW9ucy5sZW5ndGgpIHJldHVybjtcbiAgICBjb25zdCBzZWxlY3RPcHRpb24gPSAob3B0aW9uKT0+e1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBuZXdWYWx1ZTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaFVJRXZlbnQoc2VsZWN0LCAnaW5wdXQnLCB7XG4gICAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgICAgY2FuY2VsYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb21wb3NlZDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaFVJRXZlbnQoc2VsZWN0LCAnY2hhbmdlJyk7XG4gICAgfTtcbiAgICBpZiAoaXNFbGVtZW50VHlwZShzZWxlY3QsICdzZWxlY3QnKSkge1xuICAgICAgICBpZiAoc2VsZWN0Lm11bHRpcGxlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBzZWxlY3RlZE9wdGlvbnMpe1xuICAgICAgICAgICAgICAgIGNvbnN0IHdpdGhQb2ludGVyRXZlbnRzID0gdGhpcy5jb25maWcucG9pbnRlckV2ZW50c0NoZWNrID09PSAwID8gdHJ1ZSA6IGhhc1BvaW50ZXJFdmVudHModGhpcywgb3B0aW9uKTtcbiAgICAgICAgICAgICAgICAvLyBldmVudHMgZmlyZWQgZm9yIG11bHRpcGxlIHNlbGVjdCBhcmUgd2VpcmQuIENhbid0IHVzZSBob3Zlci4uLlxuICAgICAgICAgICAgICAgIGlmICh3aXRoUG9pbnRlckV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVUlFdmVudChvcHRpb24sICdwb2ludGVyb3ZlcicpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVUlFdmVudChzZWxlY3QsICdwb2ludGVyZW50ZXInKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFVJRXZlbnQob3B0aW9uLCAnbW91c2VvdmVyJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hVSUV2ZW50KHNlbGVjdCwgJ21vdXNlZW50ZXInKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFVJRXZlbnQob3B0aW9uLCAncG9pbnRlcm1vdmUnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFVJRXZlbnQob3B0aW9uLCAnbW91c2Vtb3ZlJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hVSUV2ZW50KG9wdGlvbiwgJ3BvaW50ZXJkb3duJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hVSUV2ZW50KG9wdGlvbiwgJ21vdXNlZG93bicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb2N1c0VsZW1lbnQoc2VsZWN0KTtcbiAgICAgICAgICAgICAgICBpZiAod2l0aFBvaW50ZXJFdmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFVJRXZlbnQob3B0aW9uLCAncG9pbnRlcnVwJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hVSUV2ZW50KG9wdGlvbiwgJ21vdXNldXAnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZWN0T3B0aW9uKG9wdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKHdpdGhQb2ludGVyRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hVSUV2ZW50KG9wdGlvbiwgJ2NsaWNrJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF3YWl0IHdhaXQodGhpcy5jb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNlbGVjdGVkT3B0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHdpdGhQb2ludGVyRXZlbnRzMSA9IHRoaXMuY29uZmlnLnBvaW50ZXJFdmVudHNDaGVjayA9PT0gMCA/IHRydWUgOiBoYXNQb2ludGVyRXZlbnRzKHRoaXMsIHNlbGVjdCk7XG4gICAgICAgICAgICAvLyB0aGUgY2xpY2sgdG8gb3BlbiB0aGUgc2VsZWN0IG9wdGlvbnNcbiAgICAgICAgICAgIGlmICh3aXRoUG9pbnRlckV2ZW50czEpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNsaWNrKHNlbGVjdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvY3VzRWxlbWVudChzZWxlY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZWN0T3B0aW9uKHNlbGVjdGVkT3B0aW9uc1swXSk7XG4gICAgICAgICAgICBpZiAod2l0aFBvaW50ZXJFdmVudHMxKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIGJyb3dzZXIgdHJpZ2dlcnMgYW5vdGhlciBjbGljayBldmVudCBvbiB0aGUgc2VsZWN0IGZvciB0aGUgY2xpY2sgb24gdGhlIG9wdGlvblxuICAgICAgICAgICAgICAgIC8vIHRoaXMgc2Vjb25kIGNsaWNrIGhhcyBubyAnZG93bicgcGhhc2VcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVUlFdmVudChzZWxlY3QsICdwb2ludGVyb3ZlcicpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hVSUV2ZW50KHNlbGVjdCwgJ3BvaW50ZXJlbnRlcicpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hVSUV2ZW50KHNlbGVjdCwgJ21vdXNlb3ZlcicpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hVSUV2ZW50KHNlbGVjdCwgJ21vdXNlZW50ZXInKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVUlFdmVudChzZWxlY3QsICdwb2ludGVydXAnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVUlFdmVudChzZWxlY3QsICdtb3VzZXVwJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFVJRXZlbnQoc2VsZWN0LCAnY2xpY2snKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHdhaXQodGhpcy5jb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZ2V0Q29uZmlnKCkuZ2V0RWxlbWVudEVycm9yKGBDYW5ub3Qgc2VsZWN0IG11bHRpcGxlIG9wdGlvbnMgb24gYSBub24tbXVsdGlwbGUgc2VsZWN0YCwgc2VsZWN0KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2VsZWN0LmdldEF0dHJpYnV0ZSgncm9sZScpID09PSAnbGlzdGJveCcpIHtcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb24xIG9mIHNlbGVjdGVkT3B0aW9ucyl7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNsaWNrKG9wdGlvbjEpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy51bmhvdmVyKG9wdGlvbjEpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZ2V0Q29uZmlnKCkuZ2V0RWxlbWVudEVycm9yKGBDYW5ub3Qgc2VsZWN0IG9wdGlvbnMgb24gZWxlbWVudHMgdGhhdCBhcmUgbmVpdGhlciBzZWxlY3Qgbm9yIGxpc3Rib3ggZWxlbWVudHNgLCBzZWxlY3QpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgZGVzZWxlY3RPcHRpb25zLCBzZWxlY3RPcHRpb25zIH07XG4iLCJpbXBvcnQgeyByZWxlYXNlQWxsS2V5cyB9IGZyb20gJy4uL2tleWJvYXJkL2luZGV4LmpzJztcbmltcG9ydCAnLi4vdXRpbHMvY2xpY2svaXNDbGlja2FibGVJbnB1dC5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2RhdGFUcmFuc2Zlci9DbGlwYm9hcmQuanMnO1xuaW1wb3J0ICcuLi91dGlscy9lZGl0L2lzRWRpdGFibGUuanMnO1xuaW1wb3J0ICcuLi91dGlscy9lZGl0L21heExlbmd0aC5qcyc7XG5pbXBvcnQgJ0B0ZXN0aW5nLWxpYnJhcnkvZG9tL2Rpc3QvaGVscGVycy5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2tleURlZi9yZWFkTmV4dERlc2NyaXB0b3IuanMnO1xuaW1wb3J0ICcuLi91dGlscy9taXNjL2xldmVsLmpzJztcbmltcG9ydCAnLi4vb3B0aW9ucy5qcyc7XG5pbXBvcnQgeyBzZXRTZWxlY3Rpb25SYW5nZSB9IGZyb20gJy4uL2V2ZW50L3NlbGVjdGlvbi9zZXRTZWxlY3Rpb25SYW5nZS5qcyc7XG5cbmFzeW5jIGZ1bmN0aW9uIHR5cGUoZWxlbWVudCwgdGV4dCwgeyBza2lwQ2xpY2sgPXRoaXMuY29uZmlnLnNraXBDbGljayAsIHNraXBBdXRvQ2xvc2UgPXRoaXMuY29uZmlnLnNraXBBdXRvQ2xvc2UgLCBpbml0aWFsU2VsZWN0aW9uU3RhcnQgLCBpbml0aWFsU2VsZWN0aW9uRW5kICB9ID0ge30pIHtcbiAgICAvLyBUT0RPOiBwcm9wZXJseSB0eXBlIGd1YXJkXG4gICAgLy8gd2UgdXNlIHRoaXMgd29ya2Fyb3VuZCBmb3Igbm93IHRvIHByZXZlbnQgY2hhbmdpbmcgYmVoYXZpb3JcbiAgICBpZiAoZWxlbWVudC5kaXNhYmxlZCkgcmV0dXJuO1xuICAgIGlmICghc2tpcENsaWNrKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY2xpY2soZWxlbWVudCk7XG4gICAgfVxuICAgIGlmIChpbml0aWFsU2VsZWN0aW9uU3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXRTZWxlY3Rpb25SYW5nZShlbGVtZW50LCBpbml0aWFsU2VsZWN0aW9uU3RhcnQsIGluaXRpYWxTZWxlY3Rpb25FbmQgIT09IG51bGwgJiYgaW5pdGlhbFNlbGVjdGlvbkVuZCAhPT0gdm9pZCAwID8gaW5pdGlhbFNlbGVjdGlvbkVuZCA6IGluaXRpYWxTZWxlY3Rpb25TdGFydCk7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMua2V5Ym9hcmQodGV4dCk7XG4gICAgaWYgKCFza2lwQXV0b0Nsb3NlKSB7XG4gICAgICAgIGF3YWl0IHJlbGVhc2VBbGxLZXlzKHRoaXMpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgdHlwZSB9O1xuIiwiLy8gSXQgaXMgbm90IHBvc3NpYmxlIHRvIGNyZWF0ZSBhIHJlYWwgRmlsZUxpc3QgcHJvZ3JhbW1hdGljYWxseS5cbi8vIFRoZXJlZm9yZSBhc3NpZ25pbmcgYGZpbGVzYCBwcm9wZXJ0eSB3aXRoIGEgcHJvZ3JhbW1hdGljYWxseSBjcmVhdGVkIEZpbGVMaXN0IHJlc3VsdHMgaW4gYW4gZXJyb3IuXG4vLyBKdXN0IGFzc2lnbmluZyB0aGUgcHJvcGVydHkgKGFzIHBlciBmaXJlRXZlbnQpIGJyZWFrcyB0aGUgaW50ZXJ3ZWF2aW5nIHdpdGggdGhlIGB2YWx1ZWAgcHJvcGVydHkuXG5jb25zdCBmYWtlRmlsZXMgPSBTeW1ib2woJ2ZpbGVzIGFuZCB2YWx1ZSBwcm9wZXJ0aWVzIGFyZSBtb2NrZWQnKTtcbmZ1bmN0aW9uIHJlc3RvcmVQcm9wZXJ0eShvYmosIHByb3AsIGRlc2NyaXB0b3IpIHtcbiAgICBpZiAoZGVzY3JpcHRvcikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCBkZXNjcmlwdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWR5bmFtaWMtZGVsZXRlXG4gICAgICAgIGRlbGV0ZSBvYmpbcHJvcF07XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0RmlsZXMoZWwsIGZpbGVzKSB7XG4gICAgdmFyIHJlZjtcbiAgICAocmVmID0gZWxbZmFrZUZpbGVzXSkgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYucmVzdG9yZSgpO1xuICAgIGNvbnN0IHR5cGVEZXNjciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZWwsICd0eXBlJyk7XG4gICAgY29uc3QgdmFsdWVEZXNjciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZWwsICd2YWx1ZScpO1xuICAgIGNvbnN0IGZpbGVzRGVzY3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGVsLCAnZmlsZXMnKTtcbiAgICBmdW5jdGlvbiByZXN0b3JlKCkge1xuICAgICAgICByZXN0b3JlUHJvcGVydHkoZWwsICd0eXBlJywgdHlwZURlc2NyKTtcbiAgICAgICAgcmVzdG9yZVByb3BlcnR5KGVsLCAndmFsdWUnLCB2YWx1ZURlc2NyKTtcbiAgICAgICAgcmVzdG9yZVByb3BlcnR5KGVsLCAnZmlsZXMnLCBmaWxlc0Rlc2NyKTtcbiAgICB9XG4gICAgZWxbZmFrZUZpbGVzXSA9IHtcbiAgICAgICAgcmVzdG9yZVxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZWwsIHtcbiAgICAgICAgZmlsZXM6IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogKCk9PmZpbGVzXG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6ICgpPT5maWxlcy5sZW5ndGggPyBgQzpcXFxcZmFrZXBhdGhcXFxcJHtmaWxlc1swXS5uYW1lfWAgOiAnJyxcbiAgICAgICAgICAgIHNldCAodikge1xuICAgICAgICAgICAgICAgIGlmICh2ID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICByZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVEZXNjciA9PT0gbnVsbCB8fCB2YWx1ZURlc2NyID09PSB2b2lkIDAgPyB2b2lkIDAgOiAocmVmID0gdmFsdWVEZXNjci5zZXQpID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmLmNhbGwoZWwsIHYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiAoKT0+J2ZpbGUnLFxuICAgICAgICAgICAgc2V0ICh2KSB7XG4gICAgICAgICAgICAgICAgaWYgKHYgIT09ICdmaWxlJykge1xuICAgICAgICAgICAgICAgICAgICByZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgIGVsLnR5cGUgPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5leHBvcnQgeyBzZXRGaWxlcyB9O1xuIiwiaW1wb3J0ICcuLi91dGlscy9jbGljay9pc0NsaWNrYWJsZUlucHV0LmpzJztcbmltcG9ydCB7IGNyZWF0ZUZpbGVMaXN0IH0gZnJvbSAnLi4vdXRpbHMvZGF0YVRyYW5zZmVyL0ZpbGVMaXN0LmpzJztcbmltcG9ydCAnLi4vdXRpbHMvZGF0YVRyYW5zZmVyL0NsaXBib2FyZC5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2VkaXQvaXNFZGl0YWJsZS5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2VkaXQvbWF4TGVuZ3RoLmpzJztcbmltcG9ydCB7IHNldEZpbGVzIH0gZnJvbSAnLi4vdXRpbHMvZWRpdC9zZXRGaWxlcy5qcyc7XG5pbXBvcnQgeyBpc0VsZW1lbnRUeXBlIH0gZnJvbSAnLi4vdXRpbHMvbWlzYy9pc0VsZW1lbnRUeXBlLmpzJztcbmltcG9ydCB7IGlzRGlzYWJsZWQgfSBmcm9tICcuLi91dGlscy9taXNjL2lzRGlzYWJsZWQuanMnO1xuaW1wb3J0IHsgZ2V0V2luZG93IH0gZnJvbSAnLi4vdXRpbHMvbWlzYy9nZXRXaW5kb3cuanMnO1xuaW1wb3J0ICcuLi91dGlscy9rZXlEZWYvcmVhZE5leHREZXNjcmlwdG9yLmpzJztcbmltcG9ydCAnLi4vdXRpbHMvbWlzYy9sZXZlbC5qcyc7XG5pbXBvcnQgJy4uL29wdGlvbnMuanMnO1xuXG5hc3luYyBmdW5jdGlvbiB1cGxvYWQoZWxlbWVudCwgZmlsZU9yRmlsZXMpIHtcbiAgICBjb25zdCBpbnB1dCA9IGlzRWxlbWVudFR5cGUoZWxlbWVudCwgJ2xhYmVsJykgPyBlbGVtZW50LmNvbnRyb2wgOiBlbGVtZW50O1xuICAgIGlmICghaW5wdXQgfHwgIWlzRWxlbWVudFR5cGUoaW5wdXQsICdpbnB1dCcsIHtcbiAgICAgICAgdHlwZTogJ2ZpbGUnXG4gICAgfSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlICR7aW5wdXQgPT09IGVsZW1lbnQgPyAnZ2l2ZW4nIDogJ2Fzc29jaWF0ZWQnfSAke2lucHV0ID09PSBudWxsIHx8IGlucHV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnB1dC50YWdOYW1lfSBlbGVtZW50IGRvZXMgbm90IGFjY2VwdCBmaWxlIHVwbG9hZHNgKTtcbiAgICB9XG4gICAgaWYgKGlzRGlzYWJsZWQoZWxlbWVudCkpIHJldHVybjtcbiAgICBjb25zdCBmaWxlcyA9IChBcnJheS5pc0FycmF5KGZpbGVPckZpbGVzKSA/IGZpbGVPckZpbGVzIDogW1xuICAgICAgICBmaWxlT3JGaWxlc1xuICAgIF0pLmZpbHRlcigoZmlsZSk9PiF0aGlzLmNvbmZpZy5hcHBseUFjY2VwdCB8fCBpc0FjY2VwdGFibGVGaWxlKGZpbGUsIGlucHV0LmFjY2VwdCkpLnNsaWNlKDAsIGlucHV0Lm11bHRpcGxlID8gdW5kZWZpbmVkIDogMSk7XG4gICAgY29uc3QgZmlsZURpYWxvZyA9ICgpPT57XG4gICAgICAgIHZhciByZWY7XG4gICAgICAgIC8vIGRvIG5vdCBmaXJlIGFuIGlucHV0IGV2ZW50IGlmIHRoZSBmaWxlIHNlbGVjdGlvbiBkb2VzIG5vdCBjaGFuZ2VcbiAgICAgICAgaWYgKGZpbGVzLmxlbmd0aCA9PT0gKChyZWYgPSBpbnB1dC5maWxlcykgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYubGVuZ3RoKSAmJiBmaWxlcy5ldmVyeSgoZiwgaSk9PntcbiAgICAgICAgICAgIHZhciByZWY7XG4gICAgICAgICAgICByZXR1cm4gZiA9PT0gKChyZWYgPSBpbnB1dC5maWxlcykgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYuaXRlbShpKSk7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0RmlsZXMoaW5wdXQsIGNyZWF0ZUZpbGVMaXN0KGdldFdpbmRvdyhlbGVtZW50KSwgZmlsZXMpKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaFVJRXZlbnQoaW5wdXQsICdpbnB1dCcpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoVUlFdmVudChpbnB1dCwgJ2NoYW5nZScpO1xuICAgIH07XG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignZmlsZURpYWxvZycsIGZpbGVEaWFsb2cpO1xuICAgIGF3YWl0IHRoaXMuY2xpY2soZWxlbWVudCk7XG4gICAgaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZmlsZURpYWxvZycsIGZpbGVEaWFsb2cpO1xufVxuZnVuY3Rpb24gaXNBY2NlcHRhYmxlRmlsZShmaWxlLCBhY2NlcHQpIHtcbiAgICBpZiAoIWFjY2VwdCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qgd2lsZGNhcmRzID0gW1xuICAgICAgICAnYXVkaW8vKicsXG4gICAgICAgICdpbWFnZS8qJyxcbiAgICAgICAgJ3ZpZGVvLyonXG4gICAgXTtcbiAgICByZXR1cm4gYWNjZXB0LnNwbGl0KCcsJykuc29tZSgoYWNjZXB0VG9rZW4pPT57XG4gICAgICAgIGlmIChhY2NlcHRUb2tlbi5zdGFydHNXaXRoKCcuJykpIHtcbiAgICAgICAgICAgIC8vIHRva2VucyBzdGFydGluZyB3aXRoIGEgZG90IHJlcHJlc2VudCBhIGZpbGUgZXh0ZW5zaW9uXG4gICAgICAgICAgICByZXR1cm4gZmlsZS5uYW1lLmVuZHNXaXRoKGFjY2VwdFRva2VuKTtcbiAgICAgICAgfSBlbHNlIGlmICh3aWxkY2FyZHMuaW5jbHVkZXMoYWNjZXB0VG9rZW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsZS50eXBlLnN0YXJ0c1dpdGgoYWNjZXB0VG9rZW4uc3Vic3RyKDAsIGFjY2VwdFRva2VuLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsZS50eXBlID09PSBhY2NlcHRUb2tlbjtcbiAgICB9KTtcbn1cblxuZXhwb3J0IHsgdXBsb2FkIH07XG4iLCJleHBvcnQgeyBjbGljaywgZGJsQ2xpY2ssIHRyaXBsZUNsaWNrIH0gZnJvbSAnLi4vY29udmVuaWVuY2UvY2xpY2suanMnO1xuZXhwb3J0IHsgaG92ZXIsIHVuaG92ZXIgfSBmcm9tICcuLi9jb252ZW5pZW5jZS9ob3Zlci5qcyc7XG5leHBvcnQgeyB0YWIgfSBmcm9tICcuLi9jb252ZW5pZW5jZS90YWIuanMnO1xuZXhwb3J0IHsga2V5Ym9hcmQgfSBmcm9tICcuLi9rZXlib2FyZC9pbmRleC5qcyc7XG5leHBvcnQgeyBjb3B5IH0gZnJvbSAnLi4vY2xpcGJvYXJkL2NvcHkuanMnO1xuZXhwb3J0IHsgY3V0IH0gZnJvbSAnLi4vY2xpcGJvYXJkL2N1dC5qcyc7XG5leHBvcnQgeyBwYXN0ZSB9IGZyb20gJy4uL2NsaXBib2FyZC9wYXN0ZS5qcyc7XG5leHBvcnQgeyBwb2ludGVyIH0gZnJvbSAnLi4vcG9pbnRlci9pbmRleC5qcyc7XG5leHBvcnQgeyBjbGVhciB9IGZyb20gJy4uL3V0aWxpdHkvY2xlYXIuanMnO1xuZXhwb3J0IHsgZGVzZWxlY3RPcHRpb25zLCBzZWxlY3RPcHRpb25zIH0gZnJvbSAnLi4vdXRpbGl0eS9zZWxlY3RPcHRpb25zLmpzJztcbmV4cG9ydCB7IHR5cGUgfSBmcm9tICcuLi91dGlsaXR5L3R5cGUuanMnO1xuZXhwb3J0IHsgdXBsb2FkIH0gZnJvbSAnLi4vdXRpbGl0eS91cGxvYWQuanMnO1xuIiwiaW1wb3J0IHsgZ2V0Q29uZmlnIH0gZnJvbSAnQHRlc3RpbmctbGlicmFyeS9kb20nO1xuXG4vKipcbiAqIFdyYXAgYW4gaW50ZXJuYWwgUHJvbWlzZVxuICovIGZ1bmN0aW9uIHdyYXBBc3luYyhpbXBsZW1lbnRhdGlvbikge1xuICAgIHJldHVybiBnZXRDb25maWcoKS5hc3luY1dyYXBwZXIoaW1wbGVtZW50YXRpb24pO1xufVxuXG5leHBvcnQgeyB3cmFwQXN5bmMgfTtcbiIsImltcG9ydCB7IHByZXBhcmVEb2N1bWVudCB9IGZyb20gJy4uL2RvY3VtZW50L3ByZXBhcmVEb2N1bWVudC5qcyc7XG5pbXBvcnQgeyBkaXNwYXRjaEV2ZW50LCBkaXNwYXRjaFVJRXZlbnQgfSBmcm9tICcuLi9ldmVudC9kaXNwYXRjaEV2ZW50LmpzJztcbmltcG9ydCAnLi4vdXRpbHMvY2xpY2svaXNDbGlja2FibGVJbnB1dC5qcyc7XG5pbXBvcnQgeyBhdHRhY2hDbGlwYm9hcmRTdHViVG9WaWV3IH0gZnJvbSAnLi4vdXRpbHMvZGF0YVRyYW5zZmVyL0NsaXBib2FyZC5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2VkaXQvaXNFZGl0YWJsZS5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2VkaXQvbWF4TGVuZ3RoLmpzJztcbmltcG9ydCAnQHRlc3RpbmctbGlicmFyeS9kb20vZGlzdC9oZWxwZXJzLmpzJztcbmltcG9ydCAnLi4vdXRpbHMva2V5RGVmL3JlYWROZXh0RGVzY3JpcHRvci5qcyc7XG5pbXBvcnQgeyBnZXREb2N1bWVudEZyb21Ob2RlIH0gZnJvbSAnLi4vdXRpbHMvbWlzYy9nZXREb2N1bWVudEZyb21Ob2RlLmpzJztcbmltcG9ydCB7IHNldExldmVsUmVmLCBBcGlMZXZlbCB9IGZyb20gJy4uL3V0aWxzL21pc2MvbGV2ZWwuanMnO1xuaW1wb3J0IHsgd2FpdCB9IGZyb20gJy4uL3V0aWxzL21pc2Mvd2FpdC5qcyc7XG5pbXBvcnQgeyBQb2ludGVyRXZlbnRzQ2hlY2tMZXZlbCB9IGZyb20gJy4uL29wdGlvbnMuanMnO1xuaW1wb3J0ICdAdGVzdGluZy1saWJyYXJ5L2RvbSc7XG5pbXBvcnQgeyBkZWZhdWx0S2V5TWFwIH0gZnJvbSAnLi4va2V5Ym9hcmQva2V5TWFwLmpzJztcbmltcG9ydCB7IGRlZmF1bHRLZXlNYXAgYXMgZGVmYXVsdEtleU1hcCQxIH0gZnJvbSAnLi4vcG9pbnRlci9rZXlNYXAuanMnO1xuaW1wb3J0IHsgU3lzdGVtIH0gZnJvbSAnLi4vc3lzdGVtL2luZGV4LmpzJztcbmltcG9ydCAqIGFzIGFwaSBmcm9tICcuL2FwaS5qcyc7XG5pbXBvcnQgeyB3cmFwQXN5bmMgfSBmcm9tICcuL3dyYXBBc3luYy5qcyc7XG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIGFwcGxpZWQgd2hlbiBBUEkgaXMgY2FsbGVkIHBlciBgdXNlckV2ZW50LmFueUFwaSgpYFxuICovIGNvbnN0IGRlZmF1bHRPcHRpb25zRGlyZWN0ID0ge1xuICAgIGFwcGx5QWNjZXB0OiB0cnVlLFxuICAgIGF1dG9Nb2RpZnk6IHRydWUsXG4gICAgZGVsYXk6IDAsXG4gICAgZG9jdW1lbnQ6IGdsb2JhbFRoaXMuZG9jdW1lbnQsXG4gICAga2V5Ym9hcmRNYXA6IGRlZmF1bHRLZXlNYXAsXG4gICAgcG9pbnRlck1hcDogZGVmYXVsdEtleU1hcCQxLFxuICAgIHBvaW50ZXJFdmVudHNDaGVjazogUG9pbnRlckV2ZW50c0NoZWNrTGV2ZWwuRWFjaEFwaUNhbGwsXG4gICAgc2tpcEF1dG9DbG9zZTogZmFsc2UsXG4gICAgc2tpcENsaWNrOiBmYWxzZSxcbiAgICBza2lwSG92ZXI6IGZhbHNlLFxuICAgIHdyaXRlVG9DbGlwYm9hcmQ6IGZhbHNlLFxuICAgIGFkdmFuY2VUaW1lcnM6ICgpPT5Qcm9taXNlLnJlc29sdmUoKVxufTtcbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIGFwcGxpZWQgd2hlbiBBUEkgaXMgY2FsbGVkIHBlciBgdXNlckV2ZW50KCkuYW55QXBpKClgXG4gKi8gY29uc3QgZGVmYXVsdE9wdGlvbnNTZXR1cCA9IHtcbiAgICAuLi5kZWZhdWx0T3B0aW9uc0RpcmVjdCxcbiAgICB3cml0ZVRvQ2xpcGJvYXJkOiB0cnVlXG59O1xuZnVuY3Rpb24gY3JlYXRlQ29uZmlnKG9wdGlvbnMgPSB7fSwgZGVmYXVsdHMgPSBkZWZhdWx0T3B0aW9uc1NldHVwLCBub2RlKSB7XG4gICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudChvcHRpb25zLCBub2RlLCBkZWZhdWx0cyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZGVmYXVsdHMsXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGRvY3VtZW50XG4gICAgfTtcbn1cbi8qKlxuICogU3RhcnQgYSBcInNlc3Npb25cIiB3aXRoIHVzZXJFdmVudC5cbiAqIEFsbCBBUElzIHJldHVybmVkIGJ5IHRoaXMgZnVuY3Rpb24gc2hhcmUgYW4gaW5wdXQgZGV2aWNlIHN0YXRlIGFuZCBhIGRlZmF1bHQgY29uZmlndXJhdGlvbi5cbiAqLyBmdW5jdGlvbiBzZXR1cE1haW4ob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgY29uZmlnID0gY3JlYXRlQ29uZmlnKG9wdGlvbnMpO1xuICAgIHByZXBhcmVEb2N1bWVudChjb25maWcuZG9jdW1lbnQpO1xuICAgIHZhciBfZGVmYXVsdFZpZXc7XG4gICAgY29uc3QgdmlldyA9IChfZGVmYXVsdFZpZXcgPSBjb25maWcuZG9jdW1lbnQuZGVmYXVsdFZpZXcpICE9PSBudWxsICYmIF9kZWZhdWx0VmlldyAhPT0gdm9pZCAwID8gX2RlZmF1bHRWaWV3IDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZ2xvYmFsVGhpcy53aW5kb3c7XG4gICAgYXR0YWNoQ2xpcGJvYXJkU3R1YlRvVmlldyh2aWV3KTtcbiAgICByZXR1cm4gY3JlYXRlSW5zdGFuY2UoY29uZmlnKS5hcGk7XG59XG4vKipcbiAqIFNldHVwIGluIGRpcmVjdCBjYWxsIHBlciBgdXNlckV2ZW50LmFueUFwaSgpYFxuICovIGZ1bmN0aW9uIHNldHVwRGlyZWN0KHsga2V5Ym9hcmRTdGF0ZSAsIHBvaW50ZXJTdGF0ZSAsIC4uLm9wdGlvbnMgfSA9IHt9LCBub2RlKSB7XG4gICAgY29uc3QgY29uZmlnID0gY3JlYXRlQ29uZmlnKG9wdGlvbnMsIGRlZmF1bHRPcHRpb25zRGlyZWN0LCBub2RlKTtcbiAgICBwcmVwYXJlRG9jdW1lbnQoY29uZmlnLmRvY3VtZW50KTtcbiAgICB2YXIgcmVmO1xuICAgIGNvbnN0IHN5c3RlbSA9IChyZWYgPSBwb2ludGVyU3RhdGUgIT09IG51bGwgJiYgcG9pbnRlclN0YXRlICE9PSB2b2lkIDAgPyBwb2ludGVyU3RhdGUgOiBrZXlib2FyZFN0YXRlKSAhPT0gbnVsbCAmJiByZWYgIT09IHZvaWQgMCA/IHJlZiA6IG5ldyBTeXN0ZW0oKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhcGk6IGNyZWF0ZUluc3RhbmNlKGNvbmZpZywgc3lzdGVtKS5hcGksXG4gICAgICAgIHN5c3RlbVxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZSBhIHNldCBvZiBjYWxsYmFja3Mgd2l0aCBkaWZmZXJlbnQgZGVmYXVsdCBzZXR0aW5ncyBidXQgdGhlIHNhbWUgc3RhdGUuXG4gKi8gZnVuY3Rpb24gc2V0dXBTdWIob3B0aW9ucykge1xuICAgIHJldHVybiBjcmVhdGVJbnN0YW5jZSh7XG4gICAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgfSwgdGhpcy5zeXN0ZW0pLmFwaTtcbn1cbmZ1bmN0aW9uIHdyYXBBbmRCaW5kSW1wbChpbnN0YW5jZSwgaW1wbCkge1xuICAgIGZ1bmN0aW9uIG1ldGhvZCguLi5hcmdzKSB7XG4gICAgICAgIHNldExldmVsUmVmKGluc3RhbmNlLCBBcGlMZXZlbC5DYWxsKTtcbiAgICAgICAgcmV0dXJuIHdyYXBBc3luYygoKT0+aW1wbC5hcHBseShpbnN0YW5jZSwgYXJncykudGhlbihhc3luYyAocmV0KT0+e1xuICAgICAgICAgICAgICAgIGF3YWl0IHdhaXQoaW5zdGFuY2UuY29uZmlnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfSkpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWV0aG9kLCAnbmFtZScsIHtcbiAgICAgICAgZ2V0OiAoKT0+aW1wbC5uYW1lXG4gICAgfSk7XG4gICAgcmV0dXJuIG1ldGhvZDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKGNvbmZpZywgc3lzdGVtID0gbmV3IFN5c3RlbSgpKSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB7fTtcbiAgICBPYmplY3QuYXNzaWduKGluc3RhbmNlLCB7XG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgZGlzcGF0Y2hFdmVudDogZGlzcGF0Y2hFdmVudC5iaW5kKGluc3RhbmNlKSxcbiAgICAgICAgZGlzcGF0Y2hVSUV2ZW50OiBkaXNwYXRjaFVJRXZlbnQuYmluZChpbnN0YW5jZSksXG4gICAgICAgIHN5c3RlbSxcbiAgICAgICAgbGV2ZWxSZWZzOiB7fSxcbiAgICAgICAgLi4uYXBpXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgIGFwaToge1xuICAgICAgICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGFwaSkubWFwKChbbmFtZSwgYXBpXSk9PltcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgd3JhcEFuZEJpbmRJbXBsKGluc3RhbmNlLCBhcGkpLCBcbiAgICAgICAgICAgICAgICBdKSksXG4gICAgICAgICAgICBzZXR1cDogc2V0dXBTdWIuYmluZChpbnN0YW5jZSlcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBnZXREb2N1bWVudChvcHRpb25zLCBub2RlLCBkZWZhdWx0cykge1xuICAgIHZhciBfZG9jdW1lbnQsIHJlZjtcbiAgICByZXR1cm4gKHJlZiA9IChfZG9jdW1lbnQgPSBvcHRpb25zLmRvY3VtZW50KSAhPT0gbnVsbCAmJiBfZG9jdW1lbnQgIT09IHZvaWQgMCA/IF9kb2N1bWVudCA6IG5vZGUgJiYgZ2V0RG9jdW1lbnRGcm9tTm9kZShub2RlKSkgIT09IG51bGwgJiYgcmVmICE9PSB2b2lkIDAgPyByZWYgOiBkZWZhdWx0cy5kb2N1bWVudDtcbn1cblxuZXhwb3J0IHsgY3JlYXRlQ29uZmlnLCBjcmVhdGVJbnN0YW5jZSwgc2V0dXBEaXJlY3QsIHNldHVwTWFpbiwgc2V0dXBTdWIgfTtcbiIsImltcG9ydCB7IHNldHVwRGlyZWN0IH0gZnJvbSAnLi9zZXR1cC5qcyc7XG5cbmZ1bmN0aW9uIGNsZWFyKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gc2V0dXBEaXJlY3QoKS5hcGkuY2xlYXIoZWxlbWVudCk7XG59XG5mdW5jdGlvbiBjbGljayhlbGVtZW50LCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gc2V0dXBEaXJlY3Qob3B0aW9ucywgZWxlbWVudCkuYXBpLmNsaWNrKGVsZW1lbnQpO1xufVxuZnVuY3Rpb24gY29weShvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gc2V0dXBEaXJlY3Qob3B0aW9ucykuYXBpLmNvcHkoKTtcbn1cbmZ1bmN0aW9uIGN1dChvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gc2V0dXBEaXJlY3Qob3B0aW9ucykuYXBpLmN1dCgpO1xufVxuZnVuY3Rpb24gZGJsQ2xpY2soZWxlbWVudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHNldHVwRGlyZWN0KG9wdGlvbnMpLmFwaS5kYmxDbGljayhlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGRlc2VsZWN0T3B0aW9ucyhzZWxlY3QsIHZhbHVlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHNldHVwRGlyZWN0KG9wdGlvbnMpLmFwaS5kZXNlbGVjdE9wdGlvbnMoc2VsZWN0LCB2YWx1ZXMpO1xufVxuZnVuY3Rpb24gaG92ZXIoZWxlbWVudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHNldHVwRGlyZWN0KG9wdGlvbnMpLmFwaS5ob3ZlcihlbGVtZW50KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGtleWJvYXJkKHRleHQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXBpICwgc3lzdGVtICB9ID0gc2V0dXBEaXJlY3Qob3B0aW9ucyk7XG4gICAgcmV0dXJuIGFwaS5rZXlib2FyZCh0ZXh0KS50aGVuKCgpPT5zeXN0ZW0pO1xufVxuYXN5bmMgZnVuY3Rpb24gcG9pbnRlcihpbnB1dCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcGkgLCBzeXN0ZW0gIH0gPSBzZXR1cERpcmVjdChvcHRpb25zKTtcbiAgICByZXR1cm4gYXBpLnBvaW50ZXIoaW5wdXQpLnRoZW4oKCk9PnN5c3RlbSk7XG59XG5mdW5jdGlvbiBwYXN0ZShjbGlwYm9hcmREYXRhLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHNldHVwRGlyZWN0KG9wdGlvbnMpLmFwaS5wYXN0ZShjbGlwYm9hcmREYXRhKTtcbn1cbmZ1bmN0aW9uIHNlbGVjdE9wdGlvbnMoc2VsZWN0LCB2YWx1ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBzZXR1cERpcmVjdChvcHRpb25zKS5hcGkuc2VsZWN0T3B0aW9ucyhzZWxlY3QsIHZhbHVlcyk7XG59XG5mdW5jdGlvbiB0cmlwbGVDbGljayhlbGVtZW50LCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gc2V0dXBEaXJlY3Qob3B0aW9ucykuYXBpLnRyaXBsZUNsaWNrKGVsZW1lbnQpO1xufVxuZnVuY3Rpb24gdHlwZShlbGVtZW50LCB0ZXh0LCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gc2V0dXBEaXJlY3Qob3B0aW9ucywgZWxlbWVudCkuYXBpLnR5cGUoZWxlbWVudCwgdGV4dCwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiB1bmhvdmVyKGVsZW1lbnQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXBpICwgc3lzdGVtICB9ID0gc2V0dXBEaXJlY3Qob3B0aW9ucyk7XG4gICAgc3lzdGVtLnBvaW50ZXIuc2V0TW91c2VQb3NpdGlvbih7XG4gICAgICAgIHRhcmdldDogZWxlbWVudFxuICAgIH0pO1xuICAgIHJldHVybiBhcGkudW5ob3ZlcihlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIHVwbG9hZChlbGVtZW50LCBmaWxlT3JGaWxlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHNldHVwRGlyZWN0KG9wdGlvbnMpLmFwaS51cGxvYWQoZWxlbWVudCwgZmlsZU9yRmlsZXMpO1xufVxuZnVuY3Rpb24gdGFiKG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBzZXR1cERpcmVjdCgpLmFwaS50YWIob3B0aW9ucyk7XG59XG5cbmV4cG9ydCB7IGNsZWFyLCBjbGljaywgY29weSwgY3V0LCBkYmxDbGljaywgZGVzZWxlY3RPcHRpb25zLCBob3Zlciwga2V5Ym9hcmQsIHBhc3RlLCBwb2ludGVyLCBzZWxlY3RPcHRpb25zLCB0YWIsIHRyaXBsZUNsaWNrLCB0eXBlLCB1bmhvdmVyLCB1cGxvYWQgfTtcbiIsImltcG9ydCB7IHNldHVwTWFpbiB9IGZyb20gJy4vc2V0dXAuanMnO1xuaW1wb3J0ICogYXMgZGlyZWN0QXBpIGZyb20gJy4vZGlyZWN0QXBpLmpzJztcblxuY29uc3QgdXNlckV2ZW50ID0ge1xuICAgIC4uLmRpcmVjdEFwaSxcbiAgICBzZXR1cDogc2V0dXBNYWluXG59O1xuXG5leHBvcnQgeyB1c2VyRXZlbnQgfTtcbiIsImV4cG9ydCB7IHVzZXJFdmVudCBhcyBkZWZhdWx0IH0gZnJvbSAnLi9zZXR1cC9pbmRleC5qcyc7XG5leHBvcnQgeyBQb2ludGVyRXZlbnRzQ2hlY2tMZXZlbCB9IGZyb20gJy4vb3B0aW9ucy5qcyc7XG4iLCIvLyBub2RlX21vZHVsZXMvQHN0b3J5Ym9vay9nbG9iYWwvZGlzdC9pbmRleC5tanNcbnZhciBzY29wZSA9ICgoKSA9PiB7XG4gIGxldCB3aW47XG4gIHJldHVybiB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgPyB3aW4gPSB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsVGhpcyA8IFwidVwiID8gd2luID0gZ2xvYmFsVGhpcyA6IHR5cGVvZiBnbG9iYWwgPCBcInVcIiA/IHdpbiA9IGdsb2JhbCA6IHR5cGVvZiBzZWxmIDwgXCJ1XCIgPyB3aW4gPSBzZWxmIDogd2luID0ge30sIHdpbjtcbn0pKCk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ac3Rvcnlib29rL2NsaWVudC1sb2dnZXIvZGlzdC9pbmRleC5tanNcbnZhciB7IExPR0xFVkVMIH0gPSBzY29wZSwgbGV2ZWxzID0geyB0cmFjZTogMSwgZGVidWc6IDIsIGluZm86IDMsIHdhcm46IDQsIGVycm9yOiA1LCBzaWxlbnQ6IDEwIH0sIGN1cnJlbnRMb2dMZXZlbFN0cmluZyA9IExPR0xFVkVMLCBjdXJyZW50TG9nTGV2ZWxOdW1iZXIgPSBsZXZlbHNbY3VycmVudExvZ0xldmVsU3RyaW5nXSB8fCBsZXZlbHMuaW5mbywgbG9nZ2VyID0geyB0cmFjZTogKG1lc3NhZ2UsIC4uLnJlc3QpID0+IHtcbiAgY3VycmVudExvZ0xldmVsTnVtYmVyIDw9IGxldmVscy50cmFjZSAmJiBjb25zb2xlLnRyYWNlKG1lc3NhZ2UsIC4uLnJlc3QpO1xufSwgZGVidWc6IChtZXNzYWdlLCAuLi5yZXN0KSA9PiB7XG4gIGN1cnJlbnRMb2dMZXZlbE51bWJlciA8PSBsZXZlbHMuZGVidWcgJiYgY29uc29sZS5kZWJ1ZyhtZXNzYWdlLCAuLi5yZXN0KTtcbn0sIGluZm86IChtZXNzYWdlLCAuLi5yZXN0KSA9PiB7XG4gIGN1cnJlbnRMb2dMZXZlbE51bWJlciA8PSBsZXZlbHMuaW5mbyAmJiBjb25zb2xlLmluZm8obWVzc2FnZSwgLi4ucmVzdCk7XG59LCB3YXJuOiAobWVzc2FnZSwgLi4ucmVzdCkgPT4ge1xuICBjdXJyZW50TG9nTGV2ZWxOdW1iZXIgPD0gbGV2ZWxzLndhcm4gJiYgY29uc29sZS53YXJuKG1lc3NhZ2UsIC4uLnJlc3QpO1xufSwgZXJyb3I6IChtZXNzYWdlLCAuLi5yZXN0KSA9PiB7XG4gIGN1cnJlbnRMb2dMZXZlbE51bWJlciA8PSBsZXZlbHMuZXJyb3IgJiYgY29uc29sZS5lcnJvcihtZXNzYWdlLCAuLi5yZXN0KTtcbn0sIGxvZzogKG1lc3NhZ2UsIC4uLnJlc3QpID0+IHtcbiAgY3VycmVudExvZ0xldmVsTnVtYmVyIDwgbGV2ZWxzLnNpbGVudCAmJiBjb25zb2xlLmxvZyhtZXNzYWdlLCAuLi5yZXN0KTtcbn0gfSwgbG9nZ2VkID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgb25jZSA9ICh0eXBlKSA9PiAobWVzc2FnZSwgLi4ucmVzdCkgPT4ge1xuICBpZiAoIWxvZ2dlZC5oYXMobWVzc2FnZSkpXG4gICAgcmV0dXJuIGxvZ2dlZC5hZGQobWVzc2FnZSksIGxvZ2dlclt0eXBlXShtZXNzYWdlLCAuLi5yZXN0KTtcbn07XG5vbmNlLmNsZWFyID0gKCkgPT4gbG9nZ2VkLmNsZWFyKCk7XG5vbmNlLnRyYWNlID0gb25jZShcInRyYWNlXCIpO1xub25jZS5kZWJ1ZyA9IG9uY2UoXCJkZWJ1Z1wiKTtcbm9uY2UuaW5mbyA9IG9uY2UoXCJpbmZvXCIpO1xub25jZS53YXJuID0gb25jZShcIndhcm5cIik7XG5vbmNlLmVycm9yID0gb25jZShcImVycm9yXCIpO1xub25jZS5sb2cgPSBvbmNlKFwibG9nXCIpO1xudmFyIGRlcHJlY2F0ZSA9IG9uY2UoXCJ3YXJuXCIpLCBwcmV0dHkgPSAodHlwZSkgPT4gKC4uLmFyZ3MpID0+IHtcbiAgbGV0IGFyZ0FycmF5ID0gW107XG4gIGlmIChhcmdzLmxlbmd0aCkge1xuICAgIGxldCBzdGFydFRhZ1JlID0gLzxzcGFuXFxzK3N0eWxlPShbJ1wiXSkoW14nXCJdKilcXDFcXHMqPi9naSwgZW5kVGFnUmUgPSAvPFxcL3NwYW4+L2dpLCByZVJlc3VsdEFycmF5O1xuICAgIGZvciAoYXJnQXJyYXkucHVzaChhcmdzWzBdLnJlcGxhY2Uoc3RhcnRUYWdSZSwgXCIlY1wiKS5yZXBsYWNlKGVuZFRhZ1JlLCBcIiVjXCIpKTsgcmVSZXN1bHRBcnJheSA9IHN0YXJ0VGFnUmUuZXhlYyhhcmdzWzBdKTsgKVxuICAgICAgYXJnQXJyYXkucHVzaChyZVJlc3VsdEFycmF5WzJdKSwgYXJnQXJyYXkucHVzaChcIlwiKTtcbiAgICBmb3IgKGxldCBqID0gMTsgaiA8IGFyZ3MubGVuZ3RoOyBqKyspXG4gICAgICBhcmdBcnJheS5wdXNoKGFyZ3Nbal0pO1xuICB9XG4gIGxvZ2dlclt0eXBlXS5hcHBseShsb2dnZXIsIGFyZ0FycmF5KTtcbn07XG5wcmV0dHkudHJhY2UgPSBwcmV0dHkoXCJ0cmFjZVwiKTtcbnByZXR0eS5kZWJ1ZyA9IHByZXR0eShcImRlYnVnXCIpO1xucHJldHR5LmluZm8gPSBwcmV0dHkoXCJpbmZvXCIpO1xucHJldHR5Lndhcm4gPSBwcmV0dHkoXCJ3YXJuXCIpO1xucHJldHR5LmVycm9yID0gcHJldHR5KFwiZXJyb3JcIik7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ac3Rvcnlib29rL2NoYW5uZWxzL2Rpc3QvaW5kZXgubWpzXG52YXIgZ2VuZXJhdGVSYW5kb21JZCA9ICgpID0+IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMTYpLnNsaWNlKDIpLCBDaGFubmVsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7IHRyYW5zcG9ydCwgYXN5bmMgPSAhMSB9ID0ge30pIHtcbiAgICB0aGlzLnNlbmRlciA9IGdlbmVyYXRlUmFuZG9tSWQoKSwgdGhpcy5ldmVudHMgPSB7fSwgdGhpcy5kYXRhID0ge30sIHRoaXMudHJhbnNwb3J0ID0gdm9pZCAwLCB0aGlzLmlzQXN5bmMgPSBhc3luYywgdHJhbnNwb3J0ICYmICh0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydCwgdGhpcy50cmFuc3BvcnQuc2V0SGFuZGxlcigoZXZlbnQpID0+IHRoaXMuaGFuZGxlRXZlbnQoZXZlbnQpKSk7XG4gIH1cbiAgZ2V0IGhhc1RyYW5zcG9ydCgpIHtcbiAgICByZXR1cm4gISF0aGlzLnRyYW5zcG9ydDtcbiAgfVxuICBhZGRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXSA9IHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0gfHwgW10sIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0ucHVzaChsaXN0ZW5lcik7XG4gIH1cbiAgZW1pdChldmVudE5hbWUsIC4uLmFyZ3MpIHtcbiAgICBsZXQgZXZlbnQgPSB7IHR5cGU6IGV2ZW50TmFtZSwgYXJncywgZnJvbTogdGhpcy5zZW5kZXIgfSwgb3B0aW9ucyA9IHt9O1xuICAgIGFyZ3MubGVuZ3RoID49IDEgJiYgYXJnc1swXSAmJiBhcmdzWzBdLm9wdGlvbnMgJiYgKG9wdGlvbnMgPSBhcmdzWzBdLm9wdGlvbnMpO1xuICAgIGxldCBoYW5kbGVyID0gKCkgPT4ge1xuICAgICAgdGhpcy50cmFuc3BvcnQgJiYgdGhpcy50cmFuc3BvcnQuc2VuZChldmVudCwgb3B0aW9ucyksIHRoaXMuaGFuZGxlRXZlbnQoZXZlbnQpO1xuICAgIH07XG4gICAgdGhpcy5pc0FzeW5jID8gc2V0SW1tZWRpYXRlKGhhbmRsZXIpIDogaGFuZGxlcigpO1xuICB9XG4gIGxhc3QoZXZlbnROYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVtldmVudE5hbWVdO1xuICB9XG4gIGV2ZW50TmFtZXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZXZlbnRzKTtcbiAgfVxuICBsaXN0ZW5lckNvdW50KGV2ZW50TmFtZSkge1xuICAgIGxldCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycyhldmVudE5hbWUpO1xuICAgIHJldHVybiBsaXN0ZW5lcnMgPyBsaXN0ZW5lcnMubGVuZ3RoIDogMDtcbiAgfVxuICBsaXN0ZW5lcnMoZXZlbnROYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0gfHwgdm9pZCAwO1xuICB9XG4gIG9uY2UoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIGxldCBvbmNlTGlzdGVuZXIgPSB0aGlzLm9uY2VMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICB0aGlzLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgb25jZUxpc3RlbmVyKTtcbiAgfVxuICByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKSB7XG4gICAgZXZlbnROYW1lID8gdGhpcy5ldmVudHNbZXZlbnROYW1lXSAmJiBkZWxldGUgdGhpcy5ldmVudHNbZXZlbnROYW1lXSA6IHRoaXMuZXZlbnRzID0ge307XG4gIH1cbiAgcmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIGxldCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycyhldmVudE5hbWUpO1xuICAgIGxpc3RlbmVycyAmJiAodGhpcy5ldmVudHNbZXZlbnROYW1lXSA9IGxpc3RlbmVycy5maWx0ZXIoKGwpID0+IGwgIT09IGxpc3RlbmVyKSk7XG4gIH1cbiAgb24oZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIHRoaXMuYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gIH1cbiAgb2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICB9XG4gIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgbGV0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzKGV2ZW50LnR5cGUpO1xuICAgIGxpc3RlbmVycyAmJiBsaXN0ZW5lcnMubGVuZ3RoICYmIGxpc3RlbmVycy5mb3JFYWNoKChmbikgPT4ge1xuICAgICAgZm4uYXBwbHkoZXZlbnQsIGV2ZW50LmFyZ3MpO1xuICAgIH0pLCB0aGlzLmRhdGFbZXZlbnQudHlwZV0gPSBldmVudC5hcmdzO1xuICB9XG4gIG9uY2VMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgbGV0IG9uY2VMaXN0ZW5lciA9ICguLi5hcmdzKSA9PiAodGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIG9uY2VMaXN0ZW5lciksIGxpc3RlbmVyKC4uLmFyZ3MpKTtcbiAgICByZXR1cm4gb25jZUxpc3RlbmVyO1xuICB9XG59O1xuXG4vLyBub2RlX21vZHVsZXMvQHN0b3J5Ym9vay9jb3JlLWV2ZW50cy9kaXN0L2luZGV4Lm1qc1xudmFyIGV2ZW50cyA9ICgoZXZlbnRzMikgPT4gKGV2ZW50czIuQ0hBTk5FTF9DUkVBVEVEID0gXCJjaGFubmVsQ3JlYXRlZFwiLCBldmVudHMyLkNPTkZJR19FUlJPUiA9IFwiY29uZmlnRXJyb3JcIiwgZXZlbnRzMi5TVE9SWV9JTkRFWF9JTlZBTElEQVRFRCA9IFwic3RvcnlJbmRleEludmFsaWRhdGVkXCIsIGV2ZW50czIuU1RPUllfU1BFQ0lGSUVEID0gXCJzdG9yeVNwZWNpZmllZFwiLCBldmVudHMyLlNFVF9DT05GSUcgPSBcInNldENvbmZpZ1wiLCBldmVudHMyLlNFVF9TVE9SSUVTID0gXCJzZXRTdG9yaWVzXCIsIGV2ZW50czIuU0VUX0lOREVYID0gXCJzZXRJbmRleFwiLCBldmVudHMyLlNFVF9DVVJSRU5UX1NUT1JZID0gXCJzZXRDdXJyZW50U3RvcnlcIiwgZXZlbnRzMi5DVVJSRU5UX1NUT1JZX1dBU19TRVQgPSBcImN1cnJlbnRTdG9yeVdhc1NldFwiLCBldmVudHMyLkZPUkNFX1JFX1JFTkRFUiA9IFwiZm9yY2VSZVJlbmRlclwiLCBldmVudHMyLkZPUkNFX1JFTU9VTlQgPSBcImZvcmNlUmVtb3VudFwiLCBldmVudHMyLlBSRUxPQURfRU5UUklFUyA9IFwicHJlbG9hZFN0b3JpZXNcIiwgZXZlbnRzMi5TVE9SWV9QUkVQQVJFRCA9IFwic3RvcnlQcmVwYXJlZFwiLCBldmVudHMyLkRPQ1NfUFJFUEFSRUQgPSBcImRvY3NQcmVwYXJlZFwiLCBldmVudHMyLlNUT1JZX0NIQU5HRUQgPSBcInN0b3J5Q2hhbmdlZFwiLCBldmVudHMyLlNUT1JZX1VOQ0hBTkdFRCA9IFwic3RvcnlVbmNoYW5nZWRcIiwgZXZlbnRzMi5TVE9SWV9SRU5ERVJFRCA9IFwic3RvcnlSZW5kZXJlZFwiLCBldmVudHMyLlNUT1JZX01JU1NJTkcgPSBcInN0b3J5TWlzc2luZ1wiLCBldmVudHMyLlNUT1JZX0VSUk9SRUQgPSBcInN0b3J5RXJyb3JlZFwiLCBldmVudHMyLlNUT1JZX1RIUkVXX0VYQ0VQVElPTiA9IFwic3RvcnlUaHJld0V4Y2VwdGlvblwiLCBldmVudHMyLlNUT1JZX1JFTkRFUl9QSEFTRV9DSEFOR0VEID0gXCJzdG9yeVJlbmRlclBoYXNlQ2hhbmdlZFwiLCBldmVudHMyLlBMQVlfRlVOQ1RJT05fVEhSRVdfRVhDRVBUSU9OID0gXCJwbGF5RnVuY3Rpb25UaHJld0V4Y2VwdGlvblwiLCBldmVudHMyLlVQREFURV9TVE9SWV9BUkdTID0gXCJ1cGRhdGVTdG9yeUFyZ3NcIiwgZXZlbnRzMi5TVE9SWV9BUkdTX1VQREFURUQgPSBcInN0b3J5QXJnc1VwZGF0ZWRcIiwgZXZlbnRzMi5SRVNFVF9TVE9SWV9BUkdTID0gXCJyZXNldFN0b3J5QXJnc1wiLCBldmVudHMyLlNFVF9HTE9CQUxTID0gXCJzZXRHbG9iYWxzXCIsIGV2ZW50czIuVVBEQVRFX0dMT0JBTFMgPSBcInVwZGF0ZUdsb2JhbHNcIiwgZXZlbnRzMi5HTE9CQUxTX1VQREFURUQgPSBcImdsb2JhbHNVcGRhdGVkXCIsIGV2ZW50czIuUkVHSVNURVJfU1VCU0NSSVBUSU9OID0gXCJyZWdpc3RlclN1YnNjcmlwdGlvblwiLCBldmVudHMyLlBSRVZJRVdfS0VZRE9XTiA9IFwicHJldmlld0tleWRvd25cIiwgZXZlbnRzMi5QUkVWSUVXX0JVSUxERVJfUFJPR1JFU1MgPSBcInByZXZpZXdfYnVpbGRlcl9wcm9ncmVzc1wiLCBldmVudHMyLlNFTEVDVF9TVE9SWSA9IFwic2VsZWN0U3RvcnlcIiwgZXZlbnRzMi5TVE9SSUVTX0NPTExBUFNFX0FMTCA9IFwic3Rvcmllc0NvbGxhcHNlQWxsXCIsIGV2ZW50czIuU1RPUklFU19FWFBBTkRfQUxMID0gXCJzdG9yaWVzRXhwYW5kQWxsXCIsIGV2ZW50czIuRE9DU19SRU5ERVJFRCA9IFwiZG9jc1JlbmRlcmVkXCIsIGV2ZW50czIuU0hBUkVEX1NUQVRFX0NIQU5HRUQgPSBcInNoYXJlZFN0YXRlQ2hhbmdlZFwiLCBldmVudHMyLlNIQVJFRF9TVEFURV9TRVQgPSBcInNoYXJlZFN0YXRlU2V0XCIsIGV2ZW50czIuTkFWSUdBVEVfVVJMID0gXCJuYXZpZ2F0ZVVybFwiLCBldmVudHMyLlVQREFURV9RVUVSWV9QQVJBTVMgPSBcInVwZGF0ZVF1ZXJ5UGFyYW1zXCIsIGV2ZW50czIpKShldmVudHMgfHwge30pO1xudmFyIHsgQ0hBTk5FTF9DUkVBVEVELCBDT05GSUdfRVJST1IsIENVUlJFTlRfU1RPUllfV0FTX1NFVCwgRE9DU19QUkVQQVJFRCwgRE9DU19SRU5ERVJFRCwgRk9SQ0VfUkVfUkVOREVSLCBGT1JDRV9SRU1PVU5ULCBHTE9CQUxTX1VQREFURUQsIE5BVklHQVRFX1VSTCwgUExBWV9GVU5DVElPTl9USFJFV19FWENFUFRJT04sIFBSRUxPQURfRU5UUklFUywgUFJFVklFV19CVUlMREVSX1BST0dSRVNTLCBQUkVWSUVXX0tFWURPV04sIFJFR0lTVEVSX1NVQlNDUklQVElPTiwgUkVTRVRfU1RPUllfQVJHUywgU0VMRUNUX1NUT1JZLCBTRVRfQ09ORklHLCBTRVRfQ1VSUkVOVF9TVE9SWSwgU0VUX0dMT0JBTFMsIFNFVF9JTkRFWCwgU0VUX1NUT1JJRVMsIFNIQVJFRF9TVEFURV9DSEFOR0VELCBTSEFSRURfU1RBVEVfU0VULCBTVE9SSUVTX0NPTExBUFNFX0FMTCwgU1RPUklFU19FWFBBTkRfQUxMLCBTVE9SWV9BUkdTX1VQREFURUQsIFNUT1JZX0NIQU5HRUQsIFNUT1JZX0VSUk9SRUQsIFNUT1JZX0lOREVYX0lOVkFMSURBVEVELCBTVE9SWV9NSVNTSU5HLCBTVE9SWV9QUkVQQVJFRCwgU1RPUllfUkVOREVSX1BIQVNFX0NIQU5HRUQsIFNUT1JZX1JFTkRFUkVELCBTVE9SWV9TUEVDSUZJRUQsIFNUT1JZX1RIUkVXX0VYQ0VQVElPTiwgU1RPUllfVU5DSEFOR0VELCBVUERBVEVfR0xPQkFMUywgVVBEQVRFX1FVRVJZX1BBUkFNUywgVVBEQVRFX1NUT1JZX0FSR1MgfSA9IGV2ZW50cywgSUdOT1JFRF9FWENFUFRJT04gPSBuZXcgRXJyb3IoXCJpZ25vcmVkRXhjZXB0aW9uXCIpO1xuXG4vLyBub2RlX21vZHVsZXMvQHN0b3J5Ym9vay9wcmV2aWV3LWFwaS9kaXN0L2NodW5rLUJPTVNON0haLm1qc1xuZnVuY3Rpb24gbW9ja0NoYW5uZWwoKSB7XG4gIGxldCB0cmFuc3BvcnQgPSB7IHNldEhhbmRsZXI6ICgpID0+IHtcbiAgfSwgc2VuZDogKCkgPT4ge1xuICB9IH07XG4gIHJldHVybiBuZXcgQ2hhbm5lbCh7IHRyYW5zcG9ydCB9KTtcbn1cbnZhciBBZGRvblN0b3JlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmdldENoYW5uZWwgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuY2hhbm5lbCkge1xuICAgICAgICBsZXQgY2hhbm5lbCA9IG1vY2tDaGFubmVsKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNldENoYW5uZWwoY2hhbm5lbCksIGNoYW5uZWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jaGFubmVsO1xuICAgIH0sIHRoaXMuZ2V0U2VydmVyQ2hhbm5lbCA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5zZXJ2ZXJDaGFubmVsKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBY2Nlc3Npbmcgbm9uLWV4aXN0ZW50IHNlcnZlckNoYW5uZWxcIik7XG4gICAgICByZXR1cm4gdGhpcy5zZXJ2ZXJDaGFubmVsO1xuICAgIH0sIHRoaXMucmVhZHkgPSAoKSA9PiB0aGlzLnByb21pc2UsIHRoaXMuaGFzQ2hhbm5lbCA9ICgpID0+ICEhdGhpcy5jaGFubmVsLCB0aGlzLmhhc1NlcnZlckNoYW5uZWwgPSAoKSA9PiAhIXRoaXMuc2VydmVyQ2hhbm5lbCwgdGhpcy5zZXRDaGFubmVsID0gKGNoYW5uZWwpID0+IHtcbiAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWwsIHRoaXMucmVzb2x2ZSgpO1xuICAgIH0sIHRoaXMuc2V0U2VydmVyQ2hhbm5lbCA9IChjaGFubmVsKSA9PiB7XG4gICAgICB0aGlzLnNlcnZlckNoYW5uZWwgPSBjaGFubmVsO1xuICAgIH0sIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMpID0+IHtcbiAgICAgIHRoaXMucmVzb2x2ZSA9ICgpID0+IHJlcyh0aGlzLmdldENoYW5uZWwoKSk7XG4gICAgfSk7XG4gIH1cbn0sIEtFWSA9IFwiX19TVE9SWUJPT0tfQURET05TX1BSRVZJRVdcIjtcbmZ1bmN0aW9uIGdldEFkZG9uc1N0b3JlKCkge1xuICByZXR1cm4gc2NvcGVbS0VZXSB8fCAoc2NvcGVbS0VZXSA9IG5ldyBBZGRvblN0b3JlKCkpLCBzY29wZVtLRVldO1xufVxudmFyIGFkZG9ucyA9IGdldEFkZG9uc1N0b3JlKCk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ac3Rvcnlib29rL2luc3RydW1lbnRlci9kaXN0L2luZGV4Lm1qc1xudmFyIENhbGxTdGF0ZXMgPSAoKENhbGxTdGF0ZXMyKSA9PiAoQ2FsbFN0YXRlczIuRE9ORSA9IFwiZG9uZVwiLCBDYWxsU3RhdGVzMi5FUlJPUiA9IFwiZXJyb3JcIiwgQ2FsbFN0YXRlczIuQUNUSVZFID0gXCJhY3RpdmVcIiwgQ2FsbFN0YXRlczIuV0FJVElORyA9IFwid2FpdGluZ1wiLCBDYWxsU3RhdGVzMikpKENhbGxTdGF0ZXMgfHwge30pLCBFVkVOVFMgPSB7IENBTEw6IFwic3Rvcnlib29rL2luc3RydW1lbnRlci9jYWxsXCIsIFNZTkM6IFwic3Rvcnlib29rL2luc3RydW1lbnRlci9zeW5jXCIsIFNUQVJUOiBcInN0b3J5Ym9vay9pbnN0cnVtZW50ZXIvc3RhcnRcIiwgQkFDSzogXCJzdG9yeWJvb2svaW5zdHJ1bWVudGVyL2JhY2tcIiwgR09UTzogXCJzdG9yeWJvb2svaW5zdHJ1bWVudGVyL2dvdG9cIiwgTkVYVDogXCJzdG9yeWJvb2svaW5zdHJ1bWVudGVyL25leHRcIiwgRU5EOiBcInN0b3J5Ym9vay9pbnN0cnVtZW50ZXIvZW5kXCIgfSwgY29udHJvbHNEaXNhYmxlZCA9IHsgc3RhcnQ6ICExLCBiYWNrOiAhMSwgZ290bzogITEsIG5leHQ6ICExLCBlbmQ6ICExIH0sIGFscmVhZHlDb21wbGV0ZWRFeGNlcHRpb24gPSBuZXcgRXJyb3IoXCJUaGlzIGZ1bmN0aW9uIHJhbiBhZnRlciB0aGUgcGxheSBmdW5jdGlvbiBjb21wbGV0ZWQuIERpZCB5b3UgZm9yZ2V0IHRvIGBhd2FpdGAgaXQ/XCIpLCBpc09iamVjdCA9IChvKSA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09IFwiW29iamVjdCBPYmplY3RdXCIsIGlzTW9kdWxlID0gKG8pID0+IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gXCJbb2JqZWN0IE1vZHVsZV1cIiwgaXNJbnN0cnVtZW50YWJsZSA9IChvKSA9PiB7XG4gIGlmICghaXNPYmplY3QobykgJiYgIWlzTW9kdWxlKG8pKVxuICAgIHJldHVybiAhMTtcbiAgaWYgKG8uY29uc3RydWN0b3IgPT09IHZvaWQgMClcbiAgICByZXR1cm4gITA7XG4gIGxldCBwcm90byA9IG8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICByZXR1cm4gISghaXNPYmplY3QocHJvdG8pIHx8IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgXCJpc1Byb3RvdHlwZU9mXCIpID09PSAhMSk7XG59LCBjb25zdHJ1Y3QgPSAob2JqKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBvYmouY29uc3RydWN0b3IoKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59LCBnZXRJbml0aWFsU3RhdGUgPSAoKSA9PiAoeyByZW5kZXJQaGFzZTogdm9pZCAwLCBpc0RlYnVnZ2luZzogITEsIGlzUGxheWluZzogITEsIGlzTG9ja2VkOiAhMSwgY3Vyc29yOiAwLCBjYWxsczogW10sIHNoYWRvd0NhbGxzOiBbXSwgY2FsbFJlZnNCeVJlc3VsdDogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgY2hhaW5lZENhbGxJZHM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIGFuY2VzdG9yczogW10sIHBsYXlVbnRpbDogdm9pZCAwLCByZXNvbHZlcnM6IHt9LCBzeW5jVGltZW91dDogdm9pZCAwIH0pLCBnZXRSZXRhaW5lZFN0YXRlID0gKHN0YXRlLCBpc0RlYnVnZ2luZyA9ICExKSA9PiB7XG4gIGxldCBjYWxscyA9IChpc0RlYnVnZ2luZyA/IHN0YXRlLnNoYWRvd0NhbGxzIDogc3RhdGUuY2FsbHMpLmZpbHRlcigoY2FsbCkgPT4gY2FsbC5yZXRhaW4pO1xuICBpZiAoIWNhbGxzLmxlbmd0aClcbiAgICByZXR1cm47XG4gIGxldCBjYWxsUmVmc0J5UmVzdWx0ID0gbmV3IE1hcChBcnJheS5mcm9tKHN0YXRlLmNhbGxSZWZzQnlSZXN1bHQuZW50cmllcygpKS5maWx0ZXIoKFssIHJlZl0pID0+IHJlZi5yZXRhaW4pKTtcbiAgcmV0dXJuIHsgY3Vyc29yOiBjYWxscy5sZW5ndGgsIGNhbGxzLCBjYWxsUmVmc0J5UmVzdWx0IH07XG59LCBJbnN0cnVtZW50ZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMSwgdGhpcy5jaGFubmVsID0gYWRkb25zLmdldENoYW5uZWwoKSwgdGhpcy5zdGF0ZSA9IHNjb3BlLndpbmRvdy5wYXJlbnQuX19TVE9SWUJPT0tfQURET05fSU5URVJBQ1RJT05TX0lOU1RSVU1FTlRFUl9TVEFURV9fIHx8IHt9O1xuICAgIGxldCByZXNldFN0YXRlID0gKHsgc3RvcnlJZCwgaXNQbGF5aW5nID0gITAsIGlzRGVidWdnaW5nID0gITEgfSkgPT4ge1xuICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRTdGF0ZShzdG9yeUlkKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoc3RvcnlJZCwgeyAuLi5nZXRJbml0aWFsU3RhdGUoKSwgLi4uZ2V0UmV0YWluZWRTdGF0ZShzdGF0ZSwgaXNEZWJ1Z2dpbmcpLCBzaGFkb3dDYWxsczogaXNEZWJ1Z2dpbmcgPyBzdGF0ZS5zaGFkb3dDYWxscyA6IFtdLCBjaGFpbmVkQ2FsbElkczogaXNEZWJ1Z2dpbmcgPyBzdGF0ZS5jaGFpbmVkQ2FsbElkcyA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIHBsYXlVbnRpbDogaXNEZWJ1Z2dpbmcgPyBzdGF0ZS5wbGF5VW50aWwgOiB2b2lkIDAsIGlzUGxheWluZywgaXNEZWJ1Z2dpbmcgfSksIHRoaXMuc3luYyhzdG9yeUlkKTtcbiAgICB9O1xuICAgIHRoaXMuY2hhbm5lbC5vbihGT1JDRV9SRU1PVU5ULCByZXNldFN0YXRlKSwgdGhpcy5jaGFubmVsLm9uKFNUT1JZX1JFTkRFUl9QSEFTRV9DSEFOR0VELCAoeyBzdG9yeUlkLCBuZXdQaGFzZSB9KSA9PiB7XG4gICAgICBsZXQgeyBpc0RlYnVnZ2luZyB9ID0gdGhpcy5nZXRTdGF0ZShzdG9yeUlkKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoc3RvcnlJZCwgeyByZW5kZXJQaGFzZTogbmV3UGhhc2UgfSksIG5ld1BoYXNlID09PSBcInByZXBhcmluZ1wiICYmIGlzRGVidWdnaW5nICYmIHJlc2V0U3RhdGUoeyBzdG9yeUlkIH0pLCBuZXdQaGFzZSA9PT0gXCJwbGF5aW5nXCIgJiYgcmVzZXRTdGF0ZSh7IHN0b3J5SWQsIGlzRGVidWdnaW5nIH0pLCBuZXdQaGFzZSA9PT0gXCJwbGF5ZWRcIiAmJiB0aGlzLnNldFN0YXRlKHN0b3J5SWQsIHsgaXNMb2NrZWQ6ICExLCBpc1BsYXlpbmc6ICExLCBpc0RlYnVnZ2luZzogITEgfSksIG5ld1BoYXNlID09PSBcImVycm9yZWRcIiAmJiB0aGlzLnNldFN0YXRlKHN0b3J5SWQsIHsgaXNMb2NrZWQ6ICExLCBpc1BsYXlpbmc6ICExIH0pO1xuICAgIH0pLCB0aGlzLmNoYW5uZWwub24oU0VUX0NVUlJFTlRfU1RPUlksICgpID0+IHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPyB0aGlzLmNsZWFudXAoKSA6IHRoaXMuaW5pdGlhbGl6ZWQgPSAhMDtcbiAgICB9KTtcbiAgICBsZXQgc3RhcnQgPSAoeyBzdG9yeUlkLCBwbGF5VW50aWwgfSkgPT4ge1xuICAgICAgdGhpcy5nZXRTdGF0ZShzdG9yeUlkKS5pc0RlYnVnZ2luZyB8fCB0aGlzLnNldFN0YXRlKHN0b3J5SWQsICh7IGNhbGxzIH0pID0+ICh7IGNhbGxzOiBbXSwgc2hhZG93Q2FsbHM6IGNhbGxzLm1hcCgoY2FsbCkgPT4gKHsgLi4uY2FsbCwgc3RhdHVzOiBcIndhaXRpbmdcIiB9KSksIGlzRGVidWdnaW5nOiAhMCB9KSk7XG4gICAgICBsZXQgbG9nID0gdGhpcy5nZXRMb2coc3RvcnlJZCk7XG4gICAgICB0aGlzLnNldFN0YXRlKHN0b3J5SWQsICh7IHNoYWRvd0NhbGxzIH0pID0+IHtcbiAgICAgICAgaWYgKHBsYXlVbnRpbCB8fCAhbG9nLmxlbmd0aClcbiAgICAgICAgICByZXR1cm4geyBwbGF5VW50aWwgfTtcbiAgICAgICAgbGV0IGZpcnN0Um93SW5kZXggPSBzaGFkb3dDYWxscy5maW5kSW5kZXgoKGNhbGwpID0+IGNhbGwuaWQgPT09IGxvZ1swXS5jYWxsSWQpO1xuICAgICAgICByZXR1cm4geyBwbGF5VW50aWw6IHNoYWRvd0NhbGxzLnNsaWNlKDAsIGZpcnN0Um93SW5kZXgpLmZpbHRlcigoY2FsbCkgPT4gY2FsbC5pbnRlcmNlcHRhYmxlICYmICFjYWxsLmFuY2VzdG9ycy5sZW5ndGgpLnNsaWNlKC0xKVswXT8uaWQgfTtcbiAgICAgIH0pLCB0aGlzLmNoYW5uZWwuZW1pdChGT1JDRV9SRU1PVU5ULCB7IHN0b3J5SWQsIGlzRGVidWdnaW5nOiAhMCB9KTtcbiAgICB9LCBiYWNrID0gKHsgc3RvcnlJZCB9KSA9PiB7XG4gICAgICBsZXQgbG9nID0gdGhpcy5nZXRMb2coc3RvcnlJZCkuZmlsdGVyKChjYWxsKSA9PiAhY2FsbC5hbmNlc3RvcnMubGVuZ3RoKSwgbGFzdCA9IGxvZy5yZWR1Y2VSaWdodCgocmVzLCBpdGVtLCBpbmRleCkgPT4gcmVzID49IDAgfHwgaXRlbS5zdGF0dXMgPT09IFwid2FpdGluZ1wiID8gcmVzIDogaW5kZXgsIC0xKTtcbiAgICAgIHN0YXJ0KHsgc3RvcnlJZCwgcGxheVVudGlsOiBsb2dbbGFzdCAtIDFdPy5jYWxsSWQgfSk7XG4gICAgfSwgZ290byA9ICh7IHN0b3J5SWQsIGNhbGxJZCB9KSA9PiB7XG4gICAgICBsZXQgeyBjYWxscywgc2hhZG93Q2FsbHMsIHJlc29sdmVycyB9ID0gdGhpcy5nZXRTdGF0ZShzdG9yeUlkKSwgY2FsbCA9IGNhbGxzLmZpbmQoKHsgaWQgfSkgPT4gaWQgPT09IGNhbGxJZCksIHNoYWRvd0NhbGwgPSBzaGFkb3dDYWxscy5maW5kKCh7IGlkIH0pID0+IGlkID09PSBjYWxsSWQpO1xuICAgICAgaWYgKCFjYWxsICYmIHNoYWRvd0NhbGwgJiYgT2JqZWN0LnZhbHVlcyhyZXNvbHZlcnMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGV0IG5leHRJZCA9IHRoaXMuZ2V0TG9nKHN0b3J5SWQpLmZpbmQoKGMpID0+IGMuc3RhdHVzID09PSBcIndhaXRpbmdcIik/LmNhbGxJZDtcbiAgICAgICAgc2hhZG93Q2FsbC5pZCAhPT0gbmV4dElkICYmIHRoaXMuc2V0U3RhdGUoc3RvcnlJZCwgeyBwbGF5VW50aWw6IHNoYWRvd0NhbGwuaWQgfSksIE9iamVjdC52YWx1ZXMocmVzb2x2ZXJzKS5mb3JFYWNoKChyZXNvbHZlKSA9PiByZXNvbHZlKCkpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHN0YXJ0KHsgc3RvcnlJZCwgcGxheVVudGlsOiBjYWxsSWQgfSk7XG4gICAgfSwgbmV4dCA9ICh7IHN0b3J5SWQgfSkgPT4ge1xuICAgICAgbGV0IHsgcmVzb2x2ZXJzIH0gPSB0aGlzLmdldFN0YXRlKHN0b3J5SWQpO1xuICAgICAgaWYgKE9iamVjdC52YWx1ZXMocmVzb2x2ZXJzKS5sZW5ndGggPiAwKVxuICAgICAgICBPYmplY3QudmFsdWVzKHJlc29sdmVycykuZm9yRWFjaCgocmVzb2x2ZSkgPT4gcmVzb2x2ZSgpKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBsZXQgbmV4dElkID0gdGhpcy5nZXRMb2coc3RvcnlJZCkuZmluZCgoYykgPT4gYy5zdGF0dXMgPT09IFwid2FpdGluZ1wiKT8uY2FsbElkO1xuICAgICAgICBuZXh0SWQgPyBzdGFydCh7IHN0b3J5SWQsIHBsYXlVbnRpbDogbmV4dElkIH0pIDogZW5kKHsgc3RvcnlJZCB9KTtcbiAgICAgIH1cbiAgICB9LCBlbmQgPSAoeyBzdG9yeUlkIH0pID0+IHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoc3RvcnlJZCwgeyBwbGF5VW50aWw6IHZvaWQgMCwgaXNEZWJ1Z2dpbmc6ICExIH0pLCBPYmplY3QudmFsdWVzKHRoaXMuZ2V0U3RhdGUoc3RvcnlJZCkucmVzb2x2ZXJzKS5mb3JFYWNoKChyZXNvbHZlKSA9PiByZXNvbHZlKCkpO1xuICAgIH07XG4gICAgdGhpcy5jaGFubmVsLm9uKEVWRU5UUy5TVEFSVCwgc3RhcnQpLCB0aGlzLmNoYW5uZWwub24oRVZFTlRTLkJBQ0ssIGJhY2spLCB0aGlzLmNoYW5uZWwub24oRVZFTlRTLkdPVE8sIGdvdG8pLCB0aGlzLmNoYW5uZWwub24oRVZFTlRTLk5FWFQsIG5leHQpLCB0aGlzLmNoYW5uZWwub24oRVZFTlRTLkVORCwgZW5kKTtcbiAgfVxuICBnZXRTdGF0ZShzdG9yeUlkKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVbc3RvcnlJZF0gfHwgZ2V0SW5pdGlhbFN0YXRlKCk7XG4gIH1cbiAgc2V0U3RhdGUoc3RvcnlJZCwgdXBkYXRlKSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5nZXRTdGF0ZShzdG9yeUlkKSwgcGF0Y2ggPSB0eXBlb2YgdXBkYXRlID09IFwiZnVuY3Rpb25cIiA/IHVwZGF0ZShzdGF0ZSkgOiB1cGRhdGU7XG4gICAgdGhpcy5zdGF0ZSA9IHsgLi4udGhpcy5zdGF0ZSwgW3N0b3J5SWRdOiB7IC4uLnN0YXRlLCAuLi5wYXRjaCB9IH0sIHNjb3BlLndpbmRvdy5wYXJlbnQuX19TVE9SWUJPT0tfQURET05fSU5URVJBQ1RJT05TX0lOU1RSVU1FTlRFUl9TVEFURV9fID0gdGhpcy5zdGF0ZTtcbiAgfVxuICBjbGVhbnVwKCkge1xuICAgIHRoaXMuc3RhdGUgPSBPYmplY3QuZW50cmllcyh0aGlzLnN0YXRlKS5yZWR1Y2UoKGFjYywgW3N0b3J5SWQsIHN0YXRlXSkgPT4ge1xuICAgICAgbGV0IHJldGFpbmVkU3RhdGUgPSBnZXRSZXRhaW5lZFN0YXRlKHN0YXRlKTtcbiAgICAgIHJldHVybiByZXRhaW5lZFN0YXRlICYmIChhY2Nbc3RvcnlJZF0gPSBPYmplY3QuYXNzaWduKGdldEluaXRpYWxTdGF0ZSgpLCByZXRhaW5lZFN0YXRlKSksIGFjYztcbiAgICB9LCB7fSk7XG4gICAgbGV0IHBheWxvYWQgPSB7IGNvbnRyb2xTdGF0ZXM6IGNvbnRyb2xzRGlzYWJsZWQsIGxvZ0l0ZW1zOiBbXSB9O1xuICAgIHRoaXMuY2hhbm5lbC5lbWl0KEVWRU5UUy5TWU5DLCBwYXlsb2FkKSwgc2NvcGUud2luZG93LnBhcmVudC5fX1NUT1JZQk9PS19BRERPTl9JTlRFUkFDVElPTlNfSU5TVFJVTUVOVEVSX1NUQVRFX18gPSB0aGlzLnN0YXRlO1xuICB9XG4gIGdldExvZyhzdG9yeUlkKSB7XG4gICAgbGV0IHsgY2FsbHMsIHNoYWRvd0NhbGxzIH0gPSB0aGlzLmdldFN0YXRlKHN0b3J5SWQpLCBtZXJnZWQgPSBbLi4uc2hhZG93Q2FsbHNdO1xuICAgIGNhbGxzLmZvckVhY2goKGNhbGwsIGluZGV4KSA9PiB7XG4gICAgICBtZXJnZWRbaW5kZXhdID0gY2FsbDtcbiAgICB9KTtcbiAgICBsZXQgc2VlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgcmV0dXJuIG1lcmdlZC5yZWR1Y2VSaWdodCgoYWNjLCBjYWxsKSA9PiAoY2FsbC5hcmdzLmZvckVhY2goKGFyZykgPT4ge1xuICAgICAgYXJnPy5fX2NhbGxJZF9fICYmIHNlZW4uYWRkKGFyZy5fX2NhbGxJZF9fKTtcbiAgICB9KSwgY2FsbC5wYXRoLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgIG5vZGUuX19jYWxsSWRfXyAmJiBzZWVuLmFkZChub2RlLl9fY2FsbElkX18pO1xuICAgIH0pLCAoY2FsbC5pbnRlcmNlcHRhYmxlIHx8IGNhbGwuZXhjZXB0aW9uKSAmJiAhc2Vlbi5oYXMoY2FsbC5pZCkgJiYgKGFjYy51bnNoaWZ0KHsgY2FsbElkOiBjYWxsLmlkLCBzdGF0dXM6IGNhbGwuc3RhdHVzLCBhbmNlc3RvcnM6IGNhbGwuYW5jZXN0b3JzIH0pLCBzZWVuLmFkZChjYWxsLmlkKSksIGFjYyksIFtdKTtcbiAgfVxuICBpbnN0cnVtZW50KG9iaiwgb3B0aW9ucykge1xuICAgIGlmICghaXNJbnN0cnVtZW50YWJsZShvYmopKVxuICAgICAgcmV0dXJuIG9iajtcbiAgICBsZXQgeyBtdXRhdGUgPSAhMSwgcGF0aCA9IFtdIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgIGxldCB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPSBcImZ1bmN0aW9uXCIgPyAoYWNjW2tleV0gPSB0aGlzLmluc3RydW1lbnQodmFsdWUsIHsgLi4ub3B0aW9ucywgcGF0aDogcGF0aC5jb25jYXQoa2V5KSB9KSwgYWNjKSA6IHR5cGVvZiB2YWx1ZS5fX29yaWdpbmFsRm5fXyA9PSBcImZ1bmN0aW9uXCIgPyAoYWNjW2tleV0gPSB2YWx1ZSwgYWNjKSA6IChhY2Nba2V5XSA9ICguLi5hcmdzKSA9PiB0aGlzLnRyYWNrKGtleSwgdmFsdWUsIGFyZ3MsIG9wdGlvbnMpLCBhY2Nba2V5XS5fX29yaWdpbmFsRm5fXyA9IHZhbHVlLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoYWNjW2tleV0sIFwibmFtZVwiLCB7IHZhbHVlOiBrZXksIHdyaXRhYmxlOiAhMSB9KSwgT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA+IDAgJiYgT2JqZWN0LmFzc2lnbihhY2Nba2V5XSwgdGhpcy5pbnN0cnVtZW50KHsgLi4udmFsdWUgfSwgeyAuLi5vcHRpb25zLCBwYXRoOiBwYXRoLmNvbmNhdChrZXkpIH0pKSwgYWNjKTtcbiAgICB9LCBtdXRhdGUgPyBvYmogOiBjb25zdHJ1Y3Qob2JqKSk7XG4gIH1cbiAgdHJhY2sobWV0aG9kLCBmbiwgYXJncywgb3B0aW9ucykge1xuICAgIGxldCBzdG9yeUlkID0gYXJncz8uWzBdPy5fX3N0b3J5SWRfXyB8fCBzY29wZS5fX1NUT1JZQk9PS19QUkVWSUVXX18/LnNlbGVjdGlvblN0b3JlPy5zZWxlY3Rpb24/LnN0b3J5SWQsIHsgY3Vyc29yLCBhbmNlc3RvcnMgfSA9IHRoaXMuZ2V0U3RhdGUoc3RvcnlJZCk7XG4gICAgdGhpcy5zZXRTdGF0ZShzdG9yeUlkLCB7IGN1cnNvcjogY3Vyc29yICsgMSB9KTtcbiAgICBsZXQgaWQgPSBgJHthbmNlc3RvcnMuc2xpY2UoLTEpWzBdIHx8IHN0b3J5SWR9IFske2N1cnNvcn1dICR7bWV0aG9kfWAsIHsgcGF0aCA9IFtdLCBpbnRlcmNlcHQgPSAhMSwgcmV0YWluID0gITEgfSA9IG9wdGlvbnMsIGludGVyY2VwdGFibGUgPSB0eXBlb2YgaW50ZXJjZXB0ID09IFwiZnVuY3Rpb25cIiA/IGludGVyY2VwdChtZXRob2QsIHBhdGgpIDogaW50ZXJjZXB0LCBjYWxsID0geyBpZCwgY3Vyc29yLCBzdG9yeUlkLCBhbmNlc3RvcnMsIHBhdGgsIG1ldGhvZCwgYXJncywgaW50ZXJjZXB0YWJsZSwgcmV0YWluIH0sIHJlc3VsdCA9IChpbnRlcmNlcHRhYmxlICYmICFhbmNlc3RvcnMubGVuZ3RoID8gdGhpcy5pbnRlcmNlcHQgOiB0aGlzLmludm9rZSkuY2FsbCh0aGlzLCBmbiwgY2FsbCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuaW5zdHJ1bWVudChyZXN1bHQsIHsgLi4ub3B0aW9ucywgbXV0YXRlOiAhMCwgcGF0aDogW3sgX19jYWxsSWRfXzogY2FsbC5pZCB9XSB9KTtcbiAgfVxuICBpbnRlcmNlcHQoZm4sIGNhbGwsIG9wdGlvbnMpIHtcbiAgICBsZXQgeyBjaGFpbmVkQ2FsbElkcywgaXNEZWJ1Z2dpbmcsIHBsYXlVbnRpbCB9ID0gdGhpcy5nZXRTdGF0ZShjYWxsLnN0b3J5SWQpLCBpc0NoYWluZWRVcG9uID0gY2hhaW5lZENhbGxJZHMuaGFzKGNhbGwuaWQpO1xuICAgIHJldHVybiAhaXNEZWJ1Z2dpbmcgfHwgaXNDaGFpbmVkVXBvbiB8fCBwbGF5VW50aWwgPyAocGxheVVudGlsID09PSBjYWxsLmlkICYmIHRoaXMuc2V0U3RhdGUoY2FsbC5zdG9yeUlkLCB7IHBsYXlVbnRpbDogdm9pZCAwIH0pLCB0aGlzLmludm9rZShmbiwgY2FsbCwgb3B0aW9ucykpIDogbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoY2FsbC5zdG9yeUlkLCAoeyByZXNvbHZlcnMgfSkgPT4gKHsgaXNMb2NrZWQ6ICExLCByZXNvbHZlcnM6IHsgLi4ucmVzb2x2ZXJzLCBbY2FsbC5pZF06IHJlc29sdmUgfSB9KSk7XG4gICAgfSkudGhlbigoKSA9PiAodGhpcy5zZXRTdGF0ZShjYWxsLnN0b3J5SWQsIChzdGF0ZSkgPT4ge1xuICAgICAgbGV0IHsgW2NhbGwuaWRdOiBfLCAuLi5yZXNvbHZlcnMgfSA9IHN0YXRlLnJlc29sdmVycztcbiAgICAgIHJldHVybiB7IGlzTG9ja2VkOiAhMCwgcmVzb2x2ZXJzIH07XG4gICAgfSksIHRoaXMuaW52b2tlKGZuLCBjYWxsLCBvcHRpb25zKSkpO1xuICB9XG4gIGludm9rZShmbiwgY2FsbCwgb3B0aW9ucykge1xuICAgIGxldCB7IGNhbGxSZWZzQnlSZXN1bHQsIHJlbmRlclBoYXNlIH0gPSB0aGlzLmdldFN0YXRlKGNhbGwuc3RvcnlJZCksIHNlcmlhbGl6ZVZhbHVlcyA9ICh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKGNhbGxSZWZzQnlSZXN1bHQuaGFzKHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIGNhbGxSZWZzQnlSZXN1bHQuZ2V0KHZhbHVlKTtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICByZXR1cm4gdmFsdWUubWFwKHNlcmlhbGl6ZVZhbHVlcyk7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKVxuICAgICAgICByZXR1cm4geyBfX2RhdGVfXzogeyB2YWx1ZTogdmFsdWUudG9JU09TdHJpbmcoKSB9IH07XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBsZXQgeyBuYW1lLCBtZXNzYWdlLCBzdGFjayB9ID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB7IF9fZXJyb3JfXzogeyBuYW1lLCBtZXNzYWdlLCBzdGFjayB9IH07XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgbGV0IHsgZmxhZ3MsIHNvdXJjZSB9ID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB7IF9fcmVnZXhwX186IHsgZmxhZ3MsIHNvdXJjZSB9IH07XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBzY29wZS53aW5kb3cuSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgbGV0IHsgcHJlZml4LCBsb2NhbE5hbWUsIGlkLCBjbGFzc0xpc3QsIGlubmVyVGV4dCB9ID0gdmFsdWUsIGNsYXNzTmFtZXMgPSBBcnJheS5mcm9tKGNsYXNzTGlzdCk7XG4gICAgICAgIHJldHVybiB7IF9fZWxlbWVudF9fOiB7IHByZWZpeCwgbG9jYWxOYW1lLCBpZCwgY2xhc3NOYW1lcywgaW5uZXJUZXh0IH0gfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gXCJmdW5jdGlvblwiID8geyBfX2Z1bmN0aW9uX186IHsgbmFtZTogdmFsdWUubmFtZSB9IH0gOiB0eXBlb2YgdmFsdWUgPT0gXCJzeW1ib2xcIiA/IHsgX19zeW1ib2xfXzogeyBkZXNjcmlwdGlvbjogdmFsdWUuZGVzY3JpcHRpb24gfSB9IDogdHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWU/LmNvbnN0cnVjdG9yPy5uYW1lICYmIHZhbHVlPy5jb25zdHJ1Y3Rvcj8ubmFtZSAhPT0gXCJPYmplY3RcIiA/IHsgX19jbGFzc19fOiB7IG5hbWU6IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfSB9IDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIiA/IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyh2YWx1ZSkubWFwKChba2V5LCB2YWxdKSA9PiBba2V5LCBzZXJpYWxpemVWYWx1ZXModmFsKV0pKSA6IHZhbHVlO1xuICAgIH0sIGluZm8gPSB7IC4uLmNhbGwsIGFyZ3M6IGNhbGwuYXJncy5tYXAoc2VyaWFsaXplVmFsdWVzKSB9O1xuICAgIGNhbGwucGF0aC5mb3JFYWNoKChyZWYpID0+IHtcbiAgICAgIHJlZj8uX19jYWxsSWRfXyAmJiB0aGlzLnNldFN0YXRlKGNhbGwuc3RvcnlJZCwgKHsgY2hhaW5lZENhbGxJZHMgfSkgPT4gKHsgY2hhaW5lZENhbGxJZHM6IG5ldyBTZXQoQXJyYXkuZnJvbShjaGFpbmVkQ2FsbElkcykuY29uY2F0KHJlZi5fX2NhbGxJZF9fKSkgfSkpO1xuICAgIH0pO1xuICAgIGxldCBoYW5kbGVFeGNlcHRpb24gPSAoZSkgPT4ge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBsZXQgeyBuYW1lLCBtZXNzYWdlLCBzdGFjaywgY2FsbElkID0gY2FsbC5pZCB9ID0gZSwgZXhjZXB0aW9uID0geyBuYW1lLCBtZXNzYWdlLCBzdGFjaywgY2FsbElkIH07XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZSh7IC4uLmluZm8sIHN0YXR1czogXCJlcnJvclwiLCBleGNlcHRpb24gfSksIHRoaXMuc2V0U3RhdGUoY2FsbC5zdG9yeUlkLCAoc3RhdGUpID0+ICh7IGNhbGxSZWZzQnlSZXN1bHQ6IG5ldyBNYXAoWy4uLkFycmF5LmZyb20oc3RhdGUuY2FsbFJlZnNCeVJlc3VsdC5lbnRyaWVzKCkpLCBbZSwgeyBfX2NhbGxJZF9fOiBjYWxsLmlkLCByZXRhaW46IGNhbGwucmV0YWluIH1dXSkgfSkpLCBjYWxsLmFuY2VzdG9ycy5sZW5ndGgpXG4gICAgICAgICAgdGhyb3cgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIFwiY2FsbElkXCIpIHx8IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImNhbGxJZFwiLCB7IHZhbHVlOiBjYWxsLmlkIH0pLCBlO1xuICAgICAgICBpZiAoZSAhPT0gYWxyZWFkeUNvbXBsZXRlZEV4Y2VwdGlvbilcbiAgICAgICAgICB0aHJvdyBsb2dnZXIud2FybihlKSwgSUdOT1JFRF9FWENFUFRJT047XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGlmIChyZW5kZXJQaGFzZSA9PT0gXCJwbGF5ZWRcIiAmJiAhY2FsbC5yZXRhaW4pXG4gICAgICAgIHRocm93IGFscmVhZHlDb21wbGV0ZWRFeGNlcHRpb247XG4gICAgICBsZXQgZmluYWxBcmdzID0gKG9wdGlvbnMuZ2V0QXJncyA/IG9wdGlvbnMuZ2V0QXJncyhjYWxsLCB0aGlzLmdldFN0YXRlKGNhbGwuc3RvcnlJZCkpIDogY2FsbC5hcmdzKS5tYXAoKGFyZykgPT4gdHlwZW9mIGFyZyAhPSBcImZ1bmN0aW9uXCIgfHwgT2JqZWN0LmtleXMoYXJnKS5sZW5ndGggPyBhcmcgOiAoLi4uYXJncykgPT4ge1xuICAgICAgICBsZXQgeyBjdXJzb3IsIGFuY2VzdG9ycyB9ID0gdGhpcy5nZXRTdGF0ZShjYWxsLnN0b3J5SWQpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKGNhbGwuc3RvcnlJZCwgeyBjdXJzb3I6IDAsIGFuY2VzdG9yczogWy4uLmFuY2VzdG9ycywgY2FsbC5pZF0gfSk7XG4gICAgICAgIGxldCByZXN0b3JlID0gKCkgPT4gdGhpcy5zZXRTdGF0ZShjYWxsLnN0b3J5SWQsIHsgY3Vyc29yLCBhbmNlc3RvcnMgfSksIHdpbGxSZXN0b3JlID0gITE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IHJlcyA9IGFyZyguLi5hcmdzKTtcbiAgICAgICAgICByZXR1cm4gcmVzIGluc3RhbmNlb2YgUHJvbWlzZSA/ICh3aWxsUmVzdG9yZSA9ICEwLCByZXMuZmluYWxseShyZXN0b3JlKSkgOiByZXM7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgd2lsbFJlc3RvcmUgfHwgcmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICB9KSwgcmVzdWx0ID0gZm4oLi4uZmluYWxBcmdzKTtcbiAgICAgIHJldHVybiByZXN1bHQgJiYgW1wib2JqZWN0XCIsIFwiZnVuY3Rpb25cIiwgXCJzeW1ib2xcIl0uaW5jbHVkZXModHlwZW9mIHJlc3VsdCkgJiYgdGhpcy5zZXRTdGF0ZShjYWxsLnN0b3J5SWQsIChzdGF0ZSkgPT4gKHsgY2FsbFJlZnNCeVJlc3VsdDogbmV3IE1hcChbLi4uQXJyYXkuZnJvbShzdGF0ZS5jYWxsUmVmc0J5UmVzdWx0LmVudHJpZXMoKSksIFtyZXN1bHQsIHsgX19jYWxsSWRfXzogY2FsbC5pZCwgcmV0YWluOiBjYWxsLnJldGFpbiB9XV0pIH0pKSwgdGhpcy51cGRhdGUoeyAuLi5pbmZvLCBzdGF0dXM6IHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UgPyBcImFjdGl2ZVwiIDogXCJkb25lXCIgfSksIHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UgPyByZXN1bHQudGhlbigodmFsdWUpID0+ICh0aGlzLnVwZGF0ZSh7IC4uLmluZm8sIHN0YXR1czogXCJkb25lXCIgfSksIHZhbHVlKSwgaGFuZGxlRXhjZXB0aW9uKSA6IHJlc3VsdDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gaGFuZGxlRXhjZXB0aW9uKGUpO1xuICAgIH1cbiAgfVxuICB1cGRhdGUoY2FsbCkge1xuICAgIHRoaXMuY2hhbm5lbC5lbWl0KEVWRU5UUy5DQUxMLCBjYWxsKSwgdGhpcy5zZXRTdGF0ZShjYWxsLnN0b3J5SWQsICh7IGNhbGxzIH0pID0+IHtcbiAgICAgIGxldCBjYWxsc0J5SWQgPSBjYWxscy5jb25jYXQoY2FsbCkucmVkdWNlKChhLCBjKSA9PiBPYmplY3QuYXNzaWduKGEsIHsgW2MuaWRdOiBjIH0pLCB7fSk7XG4gICAgICByZXR1cm4geyBjYWxsczogT2JqZWN0LnZhbHVlcyhjYWxsc0J5SWQpLnNvcnQoKGEsIGIpID0+IGEuaWQubG9jYWxlQ29tcGFyZShiLmlkLCB2b2lkIDAsIHsgbnVtZXJpYzogITAgfSkpIH07XG4gICAgfSksIHRoaXMuc3luYyhjYWxsLnN0b3J5SWQpO1xuICB9XG4gIHN5bmMoc3RvcnlJZCkge1xuICAgIGxldCBzeW5jaHJvbml6ZSA9ICgpID0+IHtcbiAgICAgIGxldCB7IGlzTG9ja2VkLCBpc1BsYXlpbmcgfSA9IHRoaXMuZ2V0U3RhdGUoc3RvcnlJZCksIGxvZ0l0ZW1zID0gdGhpcy5nZXRMb2coc3RvcnlJZCksIHBhdXNlZEF0ID0gbG9nSXRlbXMuZmlsdGVyKCh7IGFuY2VzdG9ycyB9KSA9PiAhYW5jZXN0b3JzLmxlbmd0aCkuZmluZCgoaXRlbSkgPT4gaXRlbS5zdGF0dXMgPT09IFwid2FpdGluZ1wiKT8uY2FsbElkLCBoYXNBY3RpdmUgPSBsb2dJdGVtcy5zb21lKChpdGVtKSA9PiBpdGVtLnN0YXR1cyA9PT0gXCJhY3RpdmVcIik7XG4gICAgICBpZiAoaXNMb2NrZWQgfHwgaGFzQWN0aXZlIHx8IGxvZ0l0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBsZXQgcGF5bG9hZDIgPSB7IGNvbnRyb2xTdGF0ZXM6IGNvbnRyb2xzRGlzYWJsZWQsIGxvZ0l0ZW1zIH07XG4gICAgICAgIHRoaXMuY2hhbm5lbC5lbWl0KEVWRU5UUy5TWU5DLCBwYXlsb2FkMik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBoYXNQcmV2aW91cyA9IGxvZ0l0ZW1zLnNvbWUoKGl0ZW0pID0+IFtcImRvbmVcIiwgXCJlcnJvclwiXS5pbmNsdWRlcyhpdGVtLnN0YXR1cykpLCBwYXlsb2FkID0geyBjb250cm9sU3RhdGVzOiB7IHN0YXJ0OiBoYXNQcmV2aW91cywgYmFjazogaGFzUHJldmlvdXMsIGdvdG86ICEwLCBuZXh0OiBpc1BsYXlpbmcsIGVuZDogaXNQbGF5aW5nIH0sIGxvZ0l0ZW1zLCBwYXVzZWRBdCB9O1xuICAgICAgdGhpcy5jaGFubmVsLmVtaXQoRVZFTlRTLlNZTkMsIHBheWxvYWQpO1xuICAgIH07XG4gICAgdGhpcy5zZXRTdGF0ZShzdG9yeUlkLCAoeyBzeW5jVGltZW91dCB9KSA9PiAoY2xlYXJUaW1lb3V0KHN5bmNUaW1lb3V0KSwgeyBzeW5jVGltZW91dDogc2V0VGltZW91dChzeW5jaHJvbml6ZSwgMCkgfSkpO1xuICB9XG59O1xuZnVuY3Rpb24gaW5zdHJ1bWVudChvYmosIG9wdGlvbnMgPSB7fSkge1xuICB0cnkge1xuICAgIGxldCBmb3JjZUluc3RydW1lbnQgPSAhMSwgc2tpcEluc3RydW1lbnQgPSAhMTtcbiAgICByZXR1cm4gc2NvcGUud2luZG93LmxvY2F0aW9uPy5zZWFyY2g/LmluY2x1ZGVzKFwiaW5zdHJ1bWVudD10cnVlXCIpID8gZm9yY2VJbnN0cnVtZW50ID0gITAgOiBzY29wZS53aW5kb3cubG9jYXRpb24/LnNlYXJjaD8uaW5jbHVkZXMoXCJpbnN0cnVtZW50PWZhbHNlXCIpICYmIChza2lwSW5zdHJ1bWVudCA9ICEwKSwgc2NvcGUud2luZG93LnBhcmVudCA9PT0gc2NvcGUud2luZG93ICYmICFmb3JjZUluc3RydW1lbnQgfHwgc2tpcEluc3RydW1lbnQgPyBvYmogOiAoc2NvcGUud2luZG93Ll9fU1RPUllCT09LX0FERE9OX0lOVEVSQUNUSU9OU19JTlNUUlVNRU5URVJfXyB8fCAoc2NvcGUud2luZG93Ll9fU1RPUllCT09LX0FERE9OX0lOVEVSQUNUSU9OU19JTlNUUlVNRU5URVJfXyA9IG5ldyBJbnN0cnVtZW50ZXIoKSksIHNjb3BlLndpbmRvdy5fX1NUT1JZQk9PS19BRERPTl9JTlRFUkFDVElPTlNfSU5TVFJVTUVOVEVSX18uaW5zdHJ1bWVudChvYmosIG9wdGlvbnMpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBvbmNlLndhcm4oZSksIG9iajtcbiAgfVxufVxuXG4vLyBzcmMvaW5kZXgudHNcbmltcG9ydCAqIGFzIGRvbVRlc3RpbmdMaWJyYXJ5IGZyb20gXCJAdGVzdGluZy1saWJyYXJ5L2RvbVwiO1xuaW1wb3J0IF91c2VyRXZlbnRPYmogZnJvbSBcIkB0ZXN0aW5nLWxpYnJhcnkvdXNlci1ldmVudFwiO1xuaW1wb3J0IGRlZGVudCBmcm9tIFwidHMtZGVkZW50XCI7XG52YXIgX3VzZXJFdmVudCA9IF91c2VyRXZlbnRPYmouZGVmYXVsdCB8fCBfdXNlckV2ZW50T2JqLCB0ZXN0aW5nTGlicmFyeSA9IGluc3RydW1lbnQoXG4gIHsgLi4uZG9tVGVzdGluZ0xpYnJhcnkgfSxcbiAge1xuICAgIGludGVyY2VwdDogKG1ldGhvZCwgcGF0aCkgPT4gcGF0aFswXSA9PT0gXCJmaXJlRXZlbnRcIiB8fCBtZXRob2Quc3RhcnRzV2l0aChcImZpbmRCeVwiKSB8fCBtZXRob2Quc3RhcnRzV2l0aChcIndhaXRGb3JcIilcbiAgfVxuKTtcbnRlc3RpbmdMaWJyYXJ5LnNjcmVlbiA9IE9iamVjdC5lbnRyaWVzKHRlc3RpbmdMaWJyYXJ5LnNjcmVlbikucmVkdWNlKFxuICAoYWNjLCBba2V5LCB2YWxdKSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkoYWNjLCBrZXksIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gb25jZS53YXJuKGRlZGVudGBcbiAgICAgICAgICBZb3UgYXJlIHVzaW5nIFRlc3RpbmcgTGlicmFyeSdzIFxcYHNjcmVlblxcYCBvYmplY3QuIFVzZSBcXGB3aXRoaW4oY2FudmFzRWxlbWVudClcXGAgaW5zdGVhZC5cbiAgICAgICAgICBNb3JlIGluZm86IGh0dHBzOi8vc3Rvcnlib29rLmpzLm9yZy9kb2NzL3JlYWN0L2Vzc2VudGlhbHMvaW50ZXJhY3Rpb25zXG4gICAgICAgIGApLCB2YWw7XG4gICAgfVxuICB9KSxcbiAgeyAuLi50ZXN0aW5nTGlicmFyeS5zY3JlZW4gfVxuKTtcbnZhciB7XG4gIGJ1aWxkUXVlcmllcyxcbiAgY29uZmlndXJlLFxuICBjcmVhdGVFdmVudCxcbiAgZmluZEFsbEJ5QWx0VGV4dCxcbiAgZmluZEFsbEJ5RGlzcGxheVZhbHVlLFxuICBmaW5kQWxsQnlMYWJlbFRleHQsXG4gIGZpbmRBbGxCeVBsYWNlaG9sZGVyVGV4dCxcbiAgZmluZEFsbEJ5Um9sZSxcbiAgZmluZEFsbEJ5VGVzdElkLFxuICBmaW5kQWxsQnlUZXh0LFxuICBmaW5kQWxsQnlUaXRsZSxcbiAgZmluZEJ5QWx0VGV4dCxcbiAgZmluZEJ5RGlzcGxheVZhbHVlLFxuICBmaW5kQnlMYWJlbFRleHQsXG4gIGZpbmRCeVBsYWNlaG9sZGVyVGV4dCxcbiAgZmluZEJ5Um9sZSxcbiAgZmluZEJ5VGVzdElkLFxuICBmaW5kQnlUZXh0LFxuICBmaW5kQnlUaXRsZSxcbiAgZmlyZUV2ZW50LFxuICBnZXRBbGxCeUFsdFRleHQsXG4gIGdldEFsbEJ5RGlzcGxheVZhbHVlLFxuICBnZXRBbGxCeUxhYmVsVGV4dCxcbiAgZ2V0QWxsQnlQbGFjZWhvbGRlclRleHQsXG4gIGdldEFsbEJ5Um9sZSxcbiAgZ2V0QWxsQnlUZXN0SWQsXG4gIGdldEFsbEJ5VGV4dCxcbiAgZ2V0QWxsQnlUaXRsZSxcbiAgZ2V0QnlBbHRUZXh0LFxuICBnZXRCeURpc3BsYXlWYWx1ZSxcbiAgZ2V0QnlMYWJlbFRleHQsXG4gIGdldEJ5UGxhY2Vob2xkZXJUZXh0LFxuICBnZXRCeVJvbGUsXG4gIGdldEJ5VGVzdElkLFxuICBnZXRCeVRleHQsXG4gIGdldEJ5VGl0bGUsXG4gIGdldENvbmZpZyxcbiAgZ2V0RGVmYXVsdE5vcm1hbGl6ZXIsXG4gIGdldEVsZW1lbnRFcnJvcixcbiAgZ2V0Tm9kZVRleHQsXG4gIGdldFF1ZXJpZXNGb3JFbGVtZW50LFxuICBnZXRSb2xlcyxcbiAgZ2V0U3VnZ2VzdGVkUXVlcnksXG4gIGlzSW5hY2Nlc3NpYmxlLFxuICBsb2dET00sXG4gIGxvZ1JvbGVzLFxuICBwcmV0dHlET00sXG4gIHF1ZXJpZXMsXG4gIHF1ZXJ5QWxsQnlBbHRUZXh0LFxuICBxdWVyeUFsbEJ5QXR0cmlidXRlLFxuICBxdWVyeUFsbEJ5RGlzcGxheVZhbHVlLFxuICBxdWVyeUFsbEJ5TGFiZWxUZXh0LFxuICBxdWVyeUFsbEJ5UGxhY2Vob2xkZXJUZXh0LFxuICBxdWVyeUFsbEJ5Um9sZSxcbiAgcXVlcnlBbGxCeVRlc3RJZCxcbiAgcXVlcnlBbGxCeVRleHQsXG4gIHF1ZXJ5QWxsQnlUaXRsZSxcbiAgcXVlcnlCeUFsdFRleHQsXG4gIHF1ZXJ5QnlBdHRyaWJ1dGUsXG4gIHF1ZXJ5QnlEaXNwbGF5VmFsdWUsXG4gIHF1ZXJ5QnlMYWJlbFRleHQsXG4gIHF1ZXJ5QnlQbGFjZWhvbGRlclRleHQsXG4gIHF1ZXJ5QnlSb2xlLFxuICBxdWVyeUJ5VGVzdElkLFxuICBxdWVyeUJ5VGV4dCxcbiAgcXVlcnlCeVRpdGxlLFxuICBxdWVyeUhlbHBlcnMsXG4gIHNjcmVlbixcbiAgd2FpdEZvcixcbiAgd2FpdEZvckVsZW1lbnRUb0JlUmVtb3ZlZCxcbiAgd2l0aGluLFxuICBwcmV0dHlGb3JtYXRcbn0gPSB0ZXN0aW5nTGlicmFyeSwgdXNlckV2ZW50ID0gaW5zdHJ1bWVudChcbiAgeyB1c2VyRXZlbnQ6IF91c2VyRXZlbnQgfSxcbiAgeyBpbnRlcmNlcHQ6ICEwIH1cbikudXNlckV2ZW50O1xuZXhwb3J0IHtcbiAgYnVpbGRRdWVyaWVzLFxuICBjb25maWd1cmUsXG4gIGNyZWF0ZUV2ZW50LFxuICBmaW5kQWxsQnlBbHRUZXh0LFxuICBmaW5kQWxsQnlEaXNwbGF5VmFsdWUsXG4gIGZpbmRBbGxCeUxhYmVsVGV4dCxcbiAgZmluZEFsbEJ5UGxhY2Vob2xkZXJUZXh0LFxuICBmaW5kQWxsQnlSb2xlLFxuICBmaW5kQWxsQnlUZXN0SWQsXG4gIGZpbmRBbGxCeVRleHQsXG4gIGZpbmRBbGxCeVRpdGxlLFxuICBmaW5kQnlBbHRUZXh0LFxuICBmaW5kQnlEaXNwbGF5VmFsdWUsXG4gIGZpbmRCeUxhYmVsVGV4dCxcbiAgZmluZEJ5UGxhY2Vob2xkZXJUZXh0LFxuICBmaW5kQnlSb2xlLFxuICBmaW5kQnlUZXN0SWQsXG4gIGZpbmRCeVRleHQsXG4gIGZpbmRCeVRpdGxlLFxuICBmaXJlRXZlbnQsXG4gIGdldEFsbEJ5QWx0VGV4dCxcbiAgZ2V0QWxsQnlEaXNwbGF5VmFsdWUsXG4gIGdldEFsbEJ5TGFiZWxUZXh0LFxuICBnZXRBbGxCeVBsYWNlaG9sZGVyVGV4dCxcbiAgZ2V0QWxsQnlSb2xlLFxuICBnZXRBbGxCeVRlc3RJZCxcbiAgZ2V0QWxsQnlUZXh0LFxuICBnZXRBbGxCeVRpdGxlLFxuICBnZXRCeUFsdFRleHQsXG4gIGdldEJ5RGlzcGxheVZhbHVlLFxuICBnZXRCeUxhYmVsVGV4dCxcbiAgZ2V0QnlQbGFjZWhvbGRlclRleHQsXG4gIGdldEJ5Um9sZSxcbiAgZ2V0QnlUZXN0SWQsXG4gIGdldEJ5VGV4dCxcbiAgZ2V0QnlUaXRsZSxcbiAgZ2V0Q29uZmlnLFxuICBnZXREZWZhdWx0Tm9ybWFsaXplcixcbiAgZ2V0RWxlbWVudEVycm9yLFxuICBnZXROb2RlVGV4dCxcbiAgZ2V0UXVlcmllc0ZvckVsZW1lbnQsXG4gIGdldFJvbGVzLFxuICBnZXRTdWdnZXN0ZWRRdWVyeSxcbiAgaXNJbmFjY2Vzc2libGUsXG4gIGxvZ0RPTSxcbiAgbG9nUm9sZXMsXG4gIHByZXR0eURPTSxcbiAgcHJldHR5Rm9ybWF0LFxuICBxdWVyaWVzLFxuICBxdWVyeUFsbEJ5QWx0VGV4dCxcbiAgcXVlcnlBbGxCeUF0dHJpYnV0ZSxcbiAgcXVlcnlBbGxCeURpc3BsYXlWYWx1ZSxcbiAgcXVlcnlBbGxCeUxhYmVsVGV4dCxcbiAgcXVlcnlBbGxCeVBsYWNlaG9sZGVyVGV4dCxcbiAgcXVlcnlBbGxCeVJvbGUsXG4gIHF1ZXJ5QWxsQnlUZXN0SWQsXG4gIHF1ZXJ5QWxsQnlUZXh0LFxuICBxdWVyeUFsbEJ5VGl0bGUsXG4gIHF1ZXJ5QnlBbHRUZXh0LFxuICBxdWVyeUJ5QXR0cmlidXRlLFxuICBxdWVyeUJ5RGlzcGxheVZhbHVlLFxuICBxdWVyeUJ5TGFiZWxUZXh0LFxuICBxdWVyeUJ5UGxhY2Vob2xkZXJUZXh0LFxuICBxdWVyeUJ5Um9sZSxcbiAgcXVlcnlCeVRlc3RJZCxcbiAgcXVlcnlCeVRleHQsXG4gIHF1ZXJ5QnlUaXRsZSxcbiAgcXVlcnlIZWxwZXJzLFxuICBzY3JlZW4sXG4gIHVzZXJFdmVudCxcbiAgd2FpdEZvcixcbiAgd2FpdEZvckVsZW1lbnRUb0JlUmVtb3ZlZCxcbiAgd2l0aGluXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@storybook/testing-library/dist/index.mjs\n")},"./node_modules/@testing-library/dom/dist/event-map.js":(__unused_webpack_module,exports)=>{"use strict";eval("var __webpack_unused_export__;\n\n\n__webpack_unused_export__ = ({\n  value: true\n});\nexports.Hx = __webpack_unused_export__ = void 0;\nconst eventMap = {\n  // Clipboard Events\n  copy: {\n    EventType: 'ClipboardEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  cut: {\n    EventType: 'ClipboardEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  paste: {\n    EventType: 'ClipboardEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  // Composition Events\n  compositionEnd: {\n    EventType: 'CompositionEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  compositionStart: {\n    EventType: 'CompositionEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  compositionUpdate: {\n    EventType: 'CompositionEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  // Keyboard Events\n  keyDown: {\n    EventType: 'KeyboardEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      charCode: 0,\n      composed: true\n    }\n  },\n  keyPress: {\n    EventType: 'KeyboardEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      charCode: 0,\n      composed: true\n    }\n  },\n  keyUp: {\n    EventType: 'KeyboardEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      charCode: 0,\n      composed: true\n    }\n  },\n  // Focus Events\n  focus: {\n    EventType: 'FocusEvent',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false,\n      composed: true\n    }\n  },\n  blur: {\n    EventType: 'FocusEvent',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false,\n      composed: true\n    }\n  },\n  focusIn: {\n    EventType: 'FocusEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false,\n      composed: true\n    }\n  },\n  focusOut: {\n    EventType: 'FocusEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false,\n      composed: true\n    }\n  },\n  // Form Events\n  change: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false\n    }\n  },\n  input: {\n    EventType: 'InputEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false,\n      composed: true\n    }\n  },\n  invalid: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: true\n    }\n  },\n  submit: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true\n    }\n  },\n  reset: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true\n    }\n  },\n  // Mouse Events\n  click: {\n    EventType: 'MouseEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      button: 0,\n      composed: true\n    }\n  },\n  contextMenu: {\n    EventType: 'MouseEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  dblClick: {\n    EventType: 'MouseEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  drag: {\n    EventType: 'DragEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  dragEnd: {\n    EventType: 'DragEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false,\n      composed: true\n    }\n  },\n  dragEnter: {\n    EventType: 'DragEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  dragExit: {\n    EventType: 'DragEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false,\n      composed: true\n    }\n  },\n  dragLeave: {\n    EventType: 'DragEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false,\n      composed: true\n    }\n  },\n  dragOver: {\n    EventType: 'DragEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  dragStart: {\n    EventType: 'DragEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  drop: {\n    EventType: 'DragEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  mouseDown: {\n    EventType: 'MouseEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  mouseEnter: {\n    EventType: 'MouseEvent',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false,\n      composed: true\n    }\n  },\n  mouseLeave: {\n    EventType: 'MouseEvent',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false,\n      composed: true\n    }\n  },\n  mouseMove: {\n    EventType: 'MouseEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  mouseOut: {\n    EventType: 'MouseEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  mouseOver: {\n    EventType: 'MouseEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  mouseUp: {\n    EventType: 'MouseEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  // Selection Events\n  select: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false\n    }\n  },\n  // Touch Events\n  touchCancel: {\n    EventType: 'TouchEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false,\n      composed: true\n    }\n  },\n  touchEnd: {\n    EventType: 'TouchEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  touchMove: {\n    EventType: 'TouchEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  touchStart: {\n    EventType: 'TouchEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  // UI Events\n  resize: {\n    EventType: 'UIEvent',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  scroll: {\n    EventType: 'UIEvent',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  // Wheel Events\n  wheel: {\n    EventType: 'WheelEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  // Media Events\n  abort: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  canPlay: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  canPlayThrough: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  durationChange: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  emptied: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  encrypted: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  ended: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  loadedData: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  loadedMetadata: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  loadStart: {\n    EventType: 'ProgressEvent',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  pause: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  play: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  playing: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  progress: {\n    EventType: 'ProgressEvent',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  rateChange: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  seeked: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  seeking: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  stalled: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  suspend: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  timeUpdate: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  volumeChange: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  waiting: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  // Events\n  load: {\n    // TODO: load events can be UIEvent or Event depending on what generated them\n    // This is where this abstraction breaks down.\n    // But the common targets are <img />, <script /> and window.\n    // Neither of these targets receive a UIEvent\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  error: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  // Animation Events\n  animationStart: {\n    EventType: 'AnimationEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false\n    }\n  },\n  animationEnd: {\n    EventType: 'AnimationEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false\n    }\n  },\n  animationIteration: {\n    EventType: 'AnimationEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false\n    }\n  },\n  // Transition Events\n  transitionCancel: {\n    EventType: 'TransitionEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false\n    }\n  },\n  transitionEnd: {\n    EventType: 'TransitionEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true\n    }\n  },\n  transitionRun: {\n    EventType: 'TransitionEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false\n    }\n  },\n  transitionStart: {\n    EventType: 'TransitionEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false\n    }\n  },\n  // pointer events\n  pointerOver: {\n    EventType: 'PointerEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  pointerEnter: {\n    EventType: 'PointerEvent',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  pointerDown: {\n    EventType: 'PointerEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  pointerMove: {\n    EventType: 'PointerEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  pointerUp: {\n    EventType: 'PointerEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  pointerCancel: {\n    EventType: 'PointerEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false,\n      composed: true\n    }\n  },\n  pointerOut: {\n    EventType: 'PointerEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  pointerLeave: {\n    EventType: 'PointerEvent',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  gotPointerCapture: {\n    EventType: 'PointerEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false,\n      composed: true\n    }\n  },\n  lostPointerCapture: {\n    EventType: 'PointerEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false,\n      composed: true\n    }\n  },\n  // history events\n  popState: {\n    EventType: 'PopStateEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false\n    }\n  },\n  // window events\n  offline: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  online: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  }\n};\nexports.Hx = eventMap;\nconst eventAliasMap = {\n  doubleClick: 'dblClick'\n};\n__webpack_unused_export__ = eventAliasMap;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS9kb20vZGlzdC9ldmVudC1tYXAuanMiLCJtYXBwaW5ncyI6IjtBQUFhOztBQUViLDZCQUE2QztBQUM3QztBQUNBLENBQUMsQ0FBQztBQUNGLFVBQWdCLEdBQUcseUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EseUJBQXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVhZnlncmVlbi11aS8uL25vZGVfbW9kdWxlcy9AdGVzdGluZy1saWJyYXJ5L2RvbS9kaXN0L2V2ZW50LW1hcC5qcz9jOThjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5ldmVudE1hcCA9IGV4cG9ydHMuZXZlbnRBbGlhc01hcCA9IHZvaWQgMDtcbmNvbnN0IGV2ZW50TWFwID0ge1xuICAvLyBDbGlwYm9hcmQgRXZlbnRzXG4gIGNvcHk6IHtcbiAgICBFdmVudFR5cGU6ICdDbGlwYm9hcmRFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIGN1dDoge1xuICAgIEV2ZW50VHlwZTogJ0NsaXBib2FyZEV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgcGFzdGU6IHtcbiAgICBFdmVudFR5cGU6ICdDbGlwYm9hcmRFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIC8vIENvbXBvc2l0aW9uIEV2ZW50c1xuICBjb21wb3NpdGlvbkVuZDoge1xuICAgIEV2ZW50VHlwZTogJ0NvbXBvc2l0aW9uRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBjb21wb3NpdGlvblN0YXJ0OiB7XG4gICAgRXZlbnRUeXBlOiAnQ29tcG9zaXRpb25FdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIGNvbXBvc2l0aW9uVXBkYXRlOiB7XG4gICAgRXZlbnRUeXBlOiAnQ29tcG9zaXRpb25FdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIC8vIEtleWJvYXJkIEV2ZW50c1xuICBrZXlEb3duOiB7XG4gICAgRXZlbnRUeXBlOiAnS2V5Ym9hcmRFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY2hhckNvZGU6IDAsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAga2V5UHJlc3M6IHtcbiAgICBFdmVudFR5cGU6ICdLZXlib2FyZEV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBjaGFyQ29kZTogMCxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBrZXlVcDoge1xuICAgIEV2ZW50VHlwZTogJ0tleWJvYXJkRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGNoYXJDb2RlOiAwLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIC8vIEZvY3VzIEV2ZW50c1xuICBmb2N1czoge1xuICAgIEV2ZW50VHlwZTogJ0ZvY3VzRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIGJsdXI6IHtcbiAgICBFdmVudFR5cGU6ICdGb2N1c0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBmb2N1c0luOiB7XG4gICAgRXZlbnRUeXBlOiAnRm9jdXNFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBmb2N1c091dDoge1xuICAgIEV2ZW50VHlwZTogJ0ZvY3VzRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2UsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgLy8gRm9ybSBFdmVudHNcbiAgY2hhbmdlOiB7XG4gICAgRXZlbnRUeXBlOiAnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIGlucHV0OiB7XG4gICAgRXZlbnRUeXBlOiAnSW5wdXRFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBpbnZhbGlkOiB7XG4gICAgRXZlbnRUeXBlOiAnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9XG4gIH0sXG4gIHN1Ym1pdDoge1xuICAgIEV2ZW50VHlwZTogJ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9XG4gIH0sXG4gIHJlc2V0OiB7XG4gICAgRXZlbnRUeXBlOiAnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgLy8gTW91c2UgRXZlbnRzXG4gIGNsaWNrOiB7XG4gICAgRXZlbnRUeXBlOiAnTW91c2VFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgYnV0dG9uOiAwLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIGNvbnRleHRNZW51OiB7XG4gICAgRXZlbnRUeXBlOiAnTW91c2VFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIGRibENsaWNrOiB7XG4gICAgRXZlbnRUeXBlOiAnTW91c2VFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIGRyYWc6IHtcbiAgICBFdmVudFR5cGU6ICdEcmFnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBkcmFnRW5kOiB7XG4gICAgRXZlbnRUeXBlOiAnRHJhZ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIGRyYWdFbnRlcjoge1xuICAgIEV2ZW50VHlwZTogJ0RyYWdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIGRyYWdFeGl0OiB7XG4gICAgRXZlbnRUeXBlOiAnRHJhZ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIGRyYWdMZWF2ZToge1xuICAgIEV2ZW50VHlwZTogJ0RyYWdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBkcmFnT3Zlcjoge1xuICAgIEV2ZW50VHlwZTogJ0RyYWdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIGRyYWdTdGFydDoge1xuICAgIEV2ZW50VHlwZTogJ0RyYWdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIGRyb3A6IHtcbiAgICBFdmVudFR5cGU6ICdEcmFnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBtb3VzZURvd246IHtcbiAgICBFdmVudFR5cGU6ICdNb3VzZUV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgbW91c2VFbnRlcjoge1xuICAgIEV2ZW50VHlwZTogJ01vdXNlRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIG1vdXNlTGVhdmU6IHtcbiAgICBFdmVudFR5cGU6ICdNb3VzZUV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBtb3VzZU1vdmU6IHtcbiAgICBFdmVudFR5cGU6ICdNb3VzZUV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgbW91c2VPdXQ6IHtcbiAgICBFdmVudFR5cGU6ICdNb3VzZUV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgbW91c2VPdmVyOiB7XG4gICAgRXZlbnRUeXBlOiAnTW91c2VFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIG1vdXNlVXA6IHtcbiAgICBFdmVudFR5cGU6ICdNb3VzZUV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgLy8gU2VsZWN0aW9uIEV2ZW50c1xuICBzZWxlY3Q6IHtcbiAgICBFdmVudFR5cGU6ICdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgLy8gVG91Y2ggRXZlbnRzXG4gIHRvdWNoQ2FuY2VsOiB7XG4gICAgRXZlbnRUeXBlOiAnVG91Y2hFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICB0b3VjaEVuZDoge1xuICAgIEV2ZW50VHlwZTogJ1RvdWNoRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICB0b3VjaE1vdmU6IHtcbiAgICBFdmVudFR5cGU6ICdUb3VjaEV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgdG91Y2hTdGFydDoge1xuICAgIEV2ZW50VHlwZTogJ1RvdWNoRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICAvLyBVSSBFdmVudHNcbiAgcmVzaXplOiB7XG4gICAgRXZlbnRUeXBlOiAnVUlFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHNjcm9sbDoge1xuICAgIEV2ZW50VHlwZTogJ1VJRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICAvLyBXaGVlbCBFdmVudHNcbiAgd2hlZWw6IHtcbiAgICBFdmVudFR5cGU6ICdXaGVlbEV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgLy8gTWVkaWEgRXZlbnRzXG4gIGFib3J0OiB7XG4gICAgRXZlbnRUeXBlOiAnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICBjYW5QbGF5OiB7XG4gICAgRXZlbnRUeXBlOiAnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICBjYW5QbGF5VGhyb3VnaDoge1xuICAgIEV2ZW50VHlwZTogJ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgZHVyYXRpb25DaGFuZ2U6IHtcbiAgICBFdmVudFR5cGU6ICdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIGVtcHRpZWQ6IHtcbiAgICBFdmVudFR5cGU6ICdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIGVuY3J5cHRlZDoge1xuICAgIEV2ZW50VHlwZTogJ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgZW5kZWQ6IHtcbiAgICBFdmVudFR5cGU6ICdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIGxvYWRlZERhdGE6IHtcbiAgICBFdmVudFR5cGU6ICdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIGxvYWRlZE1ldGFkYXRhOiB7XG4gICAgRXZlbnRUeXBlOiAnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICBsb2FkU3RhcnQ6IHtcbiAgICBFdmVudFR5cGU6ICdQcm9ncmVzc0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgcGF1c2U6IHtcbiAgICBFdmVudFR5cGU6ICdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHBsYXk6IHtcbiAgICBFdmVudFR5cGU6ICdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHBsYXlpbmc6IHtcbiAgICBFdmVudFR5cGU6ICdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHByb2dyZXNzOiB7XG4gICAgRXZlbnRUeXBlOiAnUHJvZ3Jlc3NFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHJhdGVDaGFuZ2U6IHtcbiAgICBFdmVudFR5cGU6ICdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHNlZWtlZDoge1xuICAgIEV2ZW50VHlwZTogJ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgc2Vla2luZzoge1xuICAgIEV2ZW50VHlwZTogJ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgc3RhbGxlZDoge1xuICAgIEV2ZW50VHlwZTogJ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgc3VzcGVuZDoge1xuICAgIEV2ZW50VHlwZTogJ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgdGltZVVwZGF0ZToge1xuICAgIEV2ZW50VHlwZTogJ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgdm9sdW1lQ2hhbmdlOiB7XG4gICAgRXZlbnRUeXBlOiAnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICB3YWl0aW5nOiB7XG4gICAgRXZlbnRUeXBlOiAnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICAvLyBFdmVudHNcbiAgbG9hZDoge1xuICAgIC8vIFRPRE86IGxvYWQgZXZlbnRzIGNhbiBiZSBVSUV2ZW50IG9yIEV2ZW50IGRlcGVuZGluZyBvbiB3aGF0IGdlbmVyYXRlZCB0aGVtXG4gICAgLy8gVGhpcyBpcyB3aGVyZSB0aGlzIGFic3RyYWN0aW9uIGJyZWFrcyBkb3duLlxuICAgIC8vIEJ1dCB0aGUgY29tbW9uIHRhcmdldHMgYXJlIDxpbWcgLz4sIDxzY3JpcHQgLz4gYW5kIHdpbmRvdy5cbiAgICAvLyBOZWl0aGVyIG9mIHRoZXNlIHRhcmdldHMgcmVjZWl2ZSBhIFVJRXZlbnRcbiAgICBFdmVudFR5cGU6ICdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIGVycm9yOiB7XG4gICAgRXZlbnRUeXBlOiAnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICAvLyBBbmltYXRpb24gRXZlbnRzXG4gIGFuaW1hdGlvblN0YXJ0OiB7XG4gICAgRXZlbnRUeXBlOiAnQW5pbWF0aW9uRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIGFuaW1hdGlvbkVuZDoge1xuICAgIEV2ZW50VHlwZTogJ0FuaW1hdGlvbkV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICBhbmltYXRpb25JdGVyYXRpb246IHtcbiAgICBFdmVudFR5cGU6ICdBbmltYXRpb25FdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgLy8gVHJhbnNpdGlvbiBFdmVudHNcbiAgdHJhbnNpdGlvbkNhbmNlbDoge1xuICAgIEV2ZW50VHlwZTogJ1RyYW5zaXRpb25FdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgdHJhbnNpdGlvbkVuZDoge1xuICAgIEV2ZW50VHlwZTogJ1RyYW5zaXRpb25FdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgfVxuICB9LFxuICB0cmFuc2l0aW9uUnVuOiB7XG4gICAgRXZlbnRUeXBlOiAnVHJhbnNpdGlvbkV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICB0cmFuc2l0aW9uU3RhcnQ6IHtcbiAgICBFdmVudFR5cGU6ICdUcmFuc2l0aW9uRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIC8vIHBvaW50ZXIgZXZlbnRzXG4gIHBvaW50ZXJPdmVyOiB7XG4gICAgRXZlbnRUeXBlOiAnUG9pbnRlckV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgcG9pbnRlckVudGVyOiB7XG4gICAgRXZlbnRUeXBlOiAnUG9pbnRlckV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgcG9pbnRlckRvd246IHtcbiAgICBFdmVudFR5cGU6ICdQb2ludGVyRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBwb2ludGVyTW92ZToge1xuICAgIEV2ZW50VHlwZTogJ1BvaW50ZXJFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIHBvaW50ZXJVcDoge1xuICAgIEV2ZW50VHlwZTogJ1BvaW50ZXJFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIHBvaW50ZXJDYW5jZWw6IHtcbiAgICBFdmVudFR5cGU6ICdQb2ludGVyRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2UsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgcG9pbnRlck91dDoge1xuICAgIEV2ZW50VHlwZTogJ1BvaW50ZXJFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIHBvaW50ZXJMZWF2ZToge1xuICAgIEV2ZW50VHlwZTogJ1BvaW50ZXJFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIGdvdFBvaW50ZXJDYXB0dXJlOiB7XG4gICAgRXZlbnRUeXBlOiAnUG9pbnRlckV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIGxvc3RQb2ludGVyQ2FwdHVyZToge1xuICAgIEV2ZW50VHlwZTogJ1BvaW50ZXJFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICAvLyBoaXN0b3J5IGV2ZW50c1xuICBwb3BTdGF0ZToge1xuICAgIEV2ZW50VHlwZTogJ1BvcFN0YXRlRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIC8vIHdpbmRvdyBldmVudHNcbiAgb2ZmbGluZToge1xuICAgIEV2ZW50VHlwZTogJ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgb25saW5lOiB7XG4gICAgRXZlbnRUeXBlOiAnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9XG59O1xuZXhwb3J0cy5ldmVudE1hcCA9IGV2ZW50TWFwO1xuY29uc3QgZXZlbnRBbGlhc01hcCA9IHtcbiAgZG91YmxlQ2xpY2s6ICdkYmxDbGljaydcbn07XG5leHBvcnRzLmV2ZW50QWxpYXNNYXAgPSBldmVudEFsaWFzTWFwOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@testing-library/dom/dist/event-map.js\n")},"./node_modules/@testing-library/dom/dist/helpers.js":(__unused_webpack_module,exports)=>{"use strict";eval("var __webpack_unused_export__;\n\n\n__webpack_unused_export__ = ({\n  value: true\n});\n__webpack_unused_export__ = void 0;\n__webpack_unused_export__ = checkContainerType;\n__webpack_unused_export__ = getDocument;\nexports.M2 = getWindowFromNode;\n__webpack_unused_export__ = jestFakeTimersAreEnabled;\n// Constant node.nodeType for text nodes, see:\n// https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType#Node_type_constants\nconst TEXT_NODE = 3;\n__webpack_unused_export__ = TEXT_NODE;\nfunction jestFakeTimersAreEnabled() {\n  /* istanbul ignore else */\n  // eslint-disable-next-line\n  if (typeof jest !== 'undefined' && jest !== null) {\n    return (\n      // legacy timers\n      setTimeout._isMockFunction === true ||\n      // modern timers\n      // eslint-disable-next-line prefer-object-has-own -- not supported by our support matrix\n      Object.prototype.hasOwnProperty.call(setTimeout, 'clock')\n    );\n  }\n  // istanbul ignore next\n  return false;\n}\nfunction getDocument() {\n  /* istanbul ignore if */\n  if (typeof window === 'undefined') {\n    throw new Error('Could not find default container');\n  }\n  return window.document;\n}\nfunction getWindowFromNode(node) {\n  if (node.defaultView) {\n    // node is document\n    return node.defaultView;\n  } else if (node.ownerDocument && node.ownerDocument.defaultView) {\n    // node is a DOM node\n    return node.ownerDocument.defaultView;\n  } else if (node.window) {\n    // node is window\n    return node.window;\n  } else if (node.ownerDocument && node.ownerDocument.defaultView === null) {\n    throw new Error(`It looks like the window object is not available for the provided node.`);\n  } else if (node.then instanceof Function) {\n    throw new Error(`It looks like you passed a Promise object instead of a DOM node. Did you do something like \\`fireEvent.click(screen.findBy...\\` when you meant to use a \\`getBy\\` query \\`fireEvent.click(screen.getBy...\\`, or await the findBy query \\`fireEvent.click(await screen.findBy...\\`?`);\n  } else if (Array.isArray(node)) {\n    throw new Error(`It looks like you passed an Array instead of a DOM node. Did you do something like \\`fireEvent.click(screen.getAllBy...\\` when you meant to use a \\`getBy\\` query \\`fireEvent.click(screen.getBy...\\`?`);\n  } else if (typeof node.debug === 'function' && typeof node.logTestingPlaygroundURL === 'function') {\n    throw new Error(`It looks like you passed a \\`screen\\` object. Did you do something like \\`fireEvent.click(screen, ...\\` when you meant to use a query, e.g. \\`fireEvent.click(screen.getBy..., \\`?`);\n  } else {\n    // The user passed something unusual to a calling function\n    throw new Error(`The given node is not an Element, the node type is: ${typeof node}.`);\n  }\n}\nfunction checkContainerType(container) {\n  if (!container || !(typeof container.querySelector === 'function') || !(typeof container.querySelectorAll === 'function')) {\n    throw new TypeError(`Expected container to be an Element, a Document or a DocumentFragment but got ${getTypeName(container)}.`);\n  }\n  function getTypeName(object) {\n    if (typeof object === 'object') {\n      return object === null ? 'null' : object.constructor.name;\n    }\n    return typeof object;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS9kb20vZGlzdC9oZWxwZXJzLmpzIiwibWFwcGluZ3MiOiI7QUFBYTs7QUFFYiw2QkFBNkM7QUFDN0M7QUFDQSxDQUFDLENBQUM7QUFDRix5QkFBaUI7QUFDakIseUJBQTBCO0FBQzFCLHlCQUFtQjtBQUNuQixVQUF5QjtBQUN6Qix5QkFBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EseUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsMkVBQTJFLFlBQVk7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsdUJBQXVCO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL0B0ZXN0aW5nLWxpYnJhcnkvZG9tL2Rpc3QvaGVscGVycy5qcz9hYTU3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5URVhUX05PREUgPSB2b2lkIDA7XG5leHBvcnRzLmNoZWNrQ29udGFpbmVyVHlwZSA9IGNoZWNrQ29udGFpbmVyVHlwZTtcbmV4cG9ydHMuZ2V0RG9jdW1lbnQgPSBnZXREb2N1bWVudDtcbmV4cG9ydHMuZ2V0V2luZG93RnJvbU5vZGUgPSBnZXRXaW5kb3dGcm9tTm9kZTtcbmV4cG9ydHMuamVzdEZha2VUaW1lcnNBcmVFbmFibGVkID0gamVzdEZha2VUaW1lcnNBcmVFbmFibGVkO1xuLy8gQ29uc3RhbnQgbm9kZS5ub2RlVHlwZSBmb3IgdGV4dCBub2Rlcywgc2VlOlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05vZGUvbm9kZVR5cGUjTm9kZV90eXBlX2NvbnN0YW50c1xuY29uc3QgVEVYVF9OT0RFID0gMztcbmV4cG9ydHMuVEVYVF9OT0RFID0gVEVYVF9OT0RFO1xuZnVuY3Rpb24gamVzdEZha2VUaW1lcnNBcmVFbmFibGVkKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgaWYgKHR5cGVvZiBqZXN0ICE9PSAndW5kZWZpbmVkJyAmJiBqZXN0ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIC8vIGxlZ2FjeSB0aW1lcnNcbiAgICAgIHNldFRpbWVvdXQuX2lzTW9ja0Z1bmN0aW9uID09PSB0cnVlIHx8XG4gICAgICAvLyBtb2Rlcm4gdGltZXJzXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLW9iamVjdC1oYXMtb3duIC0tIG5vdCBzdXBwb3J0ZWQgYnkgb3VyIHN1cHBvcnQgbWF0cml4XG4gICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0VGltZW91dCwgJ2Nsb2NrJylcbiAgICApO1xuICB9XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldERvY3VtZW50KCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBkZWZhdWx0IGNvbnRhaW5lcicpO1xuICB9XG4gIHJldHVybiB3aW5kb3cuZG9jdW1lbnQ7XG59XG5mdW5jdGlvbiBnZXRXaW5kb3dGcm9tTm9kZShub2RlKSB7XG4gIGlmIChub2RlLmRlZmF1bHRWaWV3KSB7XG4gICAgLy8gbm9kZSBpcyBkb2N1bWVudFxuICAgIHJldHVybiBub2RlLmRlZmF1bHRWaWV3O1xuICB9IGVsc2UgaWYgKG5vZGUub3duZXJEb2N1bWVudCAmJiBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpIHtcbiAgICAvLyBub2RlIGlzIGEgRE9NIG5vZGVcbiAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICB9IGVsc2UgaWYgKG5vZGUud2luZG93KSB7XG4gICAgLy8gbm9kZSBpcyB3aW5kb3dcbiAgICByZXR1cm4gbm9kZS53aW5kb3c7XG4gIH0gZWxzZSBpZiAobm9kZS5vd25lckRvY3VtZW50ICYmIG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSXQgbG9va3MgbGlrZSB0aGUgd2luZG93IG9iamVjdCBpcyBub3QgYXZhaWxhYmxlIGZvciB0aGUgcHJvdmlkZWQgbm9kZS5gKTtcbiAgfSBlbHNlIGlmIChub2RlLnRoZW4gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgSXQgbG9va3MgbGlrZSB5b3UgcGFzc2VkIGEgUHJvbWlzZSBvYmplY3QgaW5zdGVhZCBvZiBhIERPTSBub2RlLiBEaWQgeW91IGRvIHNvbWV0aGluZyBsaWtlIFxcYGZpcmVFdmVudC5jbGljayhzY3JlZW4uZmluZEJ5Li4uXFxgIHdoZW4geW91IG1lYW50IHRvIHVzZSBhIFxcYGdldEJ5XFxgIHF1ZXJ5IFxcYGZpcmVFdmVudC5jbGljayhzY3JlZW4uZ2V0QnkuLi5cXGAsIG9yIGF3YWl0IHRoZSBmaW5kQnkgcXVlcnkgXFxgZmlyZUV2ZW50LmNsaWNrKGF3YWl0IHNjcmVlbi5maW5kQnkuLi5cXGA/YCk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSXQgbG9va3MgbGlrZSB5b3UgcGFzc2VkIGFuIEFycmF5IGluc3RlYWQgb2YgYSBET00gbm9kZS4gRGlkIHlvdSBkbyBzb21ldGhpbmcgbGlrZSBcXGBmaXJlRXZlbnQuY2xpY2soc2NyZWVuLmdldEFsbEJ5Li4uXFxgIHdoZW4geW91IG1lYW50IHRvIHVzZSBhIFxcYGdldEJ5XFxgIHF1ZXJ5IFxcYGZpcmVFdmVudC5jbGljayhzY3JlZW4uZ2V0QnkuLi5cXGA/YCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUuZGVidWcgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG5vZGUubG9nVGVzdGluZ1BsYXlncm91bmRVUkwgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEl0IGxvb2tzIGxpa2UgeW91IHBhc3NlZCBhIFxcYHNjcmVlblxcYCBvYmplY3QuIERpZCB5b3UgZG8gc29tZXRoaW5nIGxpa2UgXFxgZmlyZUV2ZW50LmNsaWNrKHNjcmVlbiwgLi4uXFxgIHdoZW4geW91IG1lYW50IHRvIHVzZSBhIHF1ZXJ5LCBlLmcuIFxcYGZpcmVFdmVudC5jbGljayhzY3JlZW4uZ2V0QnkuLi4sIFxcYD9gKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGUgdXNlciBwYXNzZWQgc29tZXRoaW5nIHVudXN1YWwgdG8gYSBjYWxsaW5nIGZ1bmN0aW9uXG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZ2l2ZW4gbm9kZSBpcyBub3QgYW4gRWxlbWVudCwgdGhlIG5vZGUgdHlwZSBpczogJHt0eXBlb2Ygbm9kZX0uYCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrQ29udGFpbmVyVHlwZShjb250YWluZXIpIHtcbiAgaWYgKCFjb250YWluZXIgfHwgISh0eXBlb2YgY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IgPT09ICdmdW5jdGlvbicpIHx8ICEodHlwZW9mIGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsID09PSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGNvbnRhaW5lciB0byBiZSBhbiBFbGVtZW50LCBhIERvY3VtZW50IG9yIGEgRG9jdW1lbnRGcmFnbWVudCBidXQgZ290ICR7Z2V0VHlwZU5hbWUoY29udGFpbmVyKX0uYCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0VHlwZU5hbWUob2JqZWN0KSB7XG4gICAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09PSBudWxsID8gJ251bGwnIDogb2JqZWN0LmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0O1xuICB9XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@testing-library/dom/dist/helpers.js\n")},"./node_modules/date-fns/esm/isAfter/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Z: () => (/* binding */ isAfter)\n/* harmony export */ });\n/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/date-fns/esm/toDate/index.js");\n/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/date-fns/esm/_lib/requiredArgs/index.js");\n\n\n/**\n * @name isAfter\n * @category Common Helpers\n * @summary Is the first date after the second one?\n *\n * @description\n * Is the first date after the second one?\n *\n * @param {Date|Number} date - the date that should be after the other one to return true\n * @param {Date|Number} dateToCompare - the date to compare with\n * @returns {Boolean} the first date is after the second date\n * @throws {TypeError} 2 arguments required\n *\n * @example\n * // Is 10 July 1989 after 11 February 1987?\n * const result = isAfter(new Date(1989, 6, 10), new Date(1987, 1, 11))\n * //=> true\n */\nfunction isAfter(dirtyDate, dirtyDateToCompare) {\n  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(2, arguments);\n  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(dirtyDate);\n  var dateToCompare = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(dirtyDateToCompare);\n  return date.getTime() > dateToCompare.getTime();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2lzQWZ0ZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBd0M7QUFDaUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsYUFBYSxTQUFTO0FBQ3RCLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmLEVBQUUsK0VBQVk7QUFDZCxhQUFhLHFFQUFNO0FBQ25CLHNCQUFzQixxRUFBTTtBQUM1QjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVhZnlncmVlbi11aS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vaXNBZnRlci9pbmRleC5qcz8xMjEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0b0RhdGUgZnJvbSBcIi4uL3RvRGF0ZS9pbmRleC5qc1wiO1xuaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vX2xpYi9yZXF1aXJlZEFyZ3MvaW5kZXguanNcIjtcbi8qKlxuICogQG5hbWUgaXNBZnRlclxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBJcyB0aGUgZmlyc3QgZGF0ZSBhZnRlciB0aGUgc2Vjb25kIG9uZT9cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIElzIHRoZSBmaXJzdCBkYXRlIGFmdGVyIHRoZSBzZWNvbmQgb25lP1xuICpcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGUgLSB0aGUgZGF0ZSB0aGF0IHNob3VsZCBiZSBhZnRlciB0aGUgb3RoZXIgb25lIHRvIHJldHVybiB0cnVlXG4gKiBAcGFyYW0ge0RhdGV8TnVtYmVyfSBkYXRlVG9Db21wYXJlIC0gdGhlIGRhdGUgdG8gY29tcGFyZSB3aXRoXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gdGhlIGZpcnN0IGRhdGUgaXMgYWZ0ZXIgdGhlIHNlY29uZCBkYXRlXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDIgYXJndW1lbnRzIHJlcXVpcmVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIElzIDEwIEp1bHkgMTk4OSBhZnRlciAxMSBGZWJydWFyeSAxOTg3P1xuICogY29uc3QgcmVzdWx0ID0gaXNBZnRlcihuZXcgRGF0ZSgxOTg5LCA2LCAxMCksIG5ldyBEYXRlKDE5ODcsIDEsIDExKSlcbiAqIC8vPT4gdHJ1ZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0FmdGVyKGRpcnR5RGF0ZSwgZGlydHlEYXRlVG9Db21wYXJlKSB7XG4gIHJlcXVpcmVkQXJncygyLCBhcmd1bWVudHMpO1xuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUpO1xuICB2YXIgZGF0ZVRvQ29tcGFyZSA9IHRvRGF0ZShkaXJ0eURhdGVUb0NvbXBhcmUpO1xuICByZXR1cm4gZGF0ZS5nZXRUaW1lKCkgPiBkYXRlVG9Db21wYXJlLmdldFRpbWUoKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/date-fns/esm/isAfter/index.js\n')},"./node_modules/mockdate/lib/mockdate.js":function(__unused_webpack_module,exports){eval("(function (global, factory) {\n     true ? factory(exports) :\n    0;\n}(this, (function (exports) { 'use strict';\n\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation.\r\n\r\n    Permission to use, copy, modify, and/or distribute this software for any\r\n    purpose with or without fee is hereby granted.\r\n\r\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n    PERFORMANCE OF THIS SOFTWARE.\r\n    ***************************************************************************** */\r\n    /* global Reflect, Promise */\r\n\r\n    var extendStatics = function(d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n\r\n    function __extends(d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    }\n\n    var RealDate = Date;\r\n    var now = null;\r\n    var MockDate = /** @class */ (function (_super) {\r\n        __extends(Date, _super);\r\n        function Date(y, m, d, h, M, s, ms) {\r\n            _super.call(this) || this;\r\n            var date;\r\n            switch (arguments.length) {\r\n                case 0:\r\n                    if (now !== null) {\r\n                        date = new RealDate(now.valueOf());\r\n                    }\r\n                    else {\r\n                        date = new RealDate();\r\n                    }\r\n                    break;\r\n                case 1:\r\n                    date = new RealDate(y);\r\n                    break;\r\n                default:\r\n                    d = typeof d === 'undefined' ? 1 : d;\r\n                    h = h || 0;\r\n                    M = M || 0;\r\n                    s = s || 0;\r\n                    ms = ms || 0;\r\n                    date = new RealDate(y, m, d, h, M, s, ms);\r\n                    break;\r\n            }\r\n            return date;\r\n        }\r\n        return Date;\r\n    }(RealDate));\r\n    MockDate.prototype = RealDate.prototype;\r\n    MockDate.UTC = RealDate.UTC;\r\n    MockDate.now = function () {\r\n        return new MockDate().valueOf();\r\n    };\r\n    MockDate.parse = function (dateString) {\r\n        return RealDate.parse(dateString);\r\n    };\r\n    MockDate.toString = function () {\r\n        return RealDate.toString();\r\n    };\r\n    function set(date) {\r\n        var dateObj = new Date(date.valueOf());\r\n        if (isNaN(dateObj.getTime())) {\r\n            throw new TypeError('mockdate: The time set is an invalid date: ' + date);\r\n        }\r\n        // @ts-ignore\r\n        Date = MockDate;\r\n        now = dateObj.valueOf();\r\n    }\r\n    function reset() {\r\n        Date = RealDate;\r\n    }\r\n    var mockdate = {\r\n        set: set,\r\n        reset: reset,\r\n    };\n\n    exports.default = mockdate;\n    exports.reset = reset;\n    exports.set = set;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9ja2RhdGUvbGliL21vY2tkYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsSUFBSSxLQUE0RDtBQUNoRSxJQUFJLENBQ3lHO0FBQzdHLENBQUMsNkJBQTZCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbURBQW1ELGFBQWE7O0FBRWhFLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWFmeWdyZWVuLXVpLy4vbm9kZV9tb2R1bGVzL21vY2tkYXRlL2xpYi9tb2NrZGF0ZS5qcz9jNGExIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gICAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuTW9ja0RhdGUgPSB7fSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcbiAgICBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxuICAgIHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcbiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcbiAgICBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuICAgIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuICAgIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG4gICAgTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuICAgIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuICAgIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4gICAgLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9XG5cbiAgICB2YXIgUmVhbERhdGUgPSBEYXRlO1xyXG4gICAgdmFyIG5vdyA9IG51bGw7XHJcbiAgICB2YXIgTW9ja0RhdGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKERhdGUsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcykge1xyXG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgZGF0ZTtcclxuICAgICAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vdyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlID0gbmV3IFJlYWxEYXRlKG5vdy52YWx1ZU9mKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBSZWFsRGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICBkYXRlID0gbmV3IFJlYWxEYXRlKHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBkID0gdHlwZW9mIGQgPT09ICd1bmRlZmluZWQnID8gMSA6IGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaCA9IGggfHwgMDtcclxuICAgICAgICAgICAgICAgICAgICBNID0gTSB8fCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHMgPSBzIHx8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgbXMgPSBtcyB8fCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGUgPSBuZXcgUmVhbERhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gRGF0ZTtcclxuICAgIH0oUmVhbERhdGUpKTtcclxuICAgIE1vY2tEYXRlLnByb3RvdHlwZSA9IFJlYWxEYXRlLnByb3RvdHlwZTtcclxuICAgIE1vY2tEYXRlLlVUQyA9IFJlYWxEYXRlLlVUQztcclxuICAgIE1vY2tEYXRlLm5vdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE1vY2tEYXRlKCkudmFsdWVPZigpO1xyXG4gICAgfTtcclxuICAgIE1vY2tEYXRlLnBhcnNlID0gZnVuY3Rpb24gKGRhdGVTdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gUmVhbERhdGUucGFyc2UoZGF0ZVN0cmluZyk7XHJcbiAgICB9O1xyXG4gICAgTW9ja0RhdGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFJlYWxEYXRlLnRvU3RyaW5nKCk7XHJcbiAgICB9O1xyXG4gICAgZnVuY3Rpb24gc2V0KGRhdGUpIHtcclxuICAgICAgICB2YXIgZGF0ZU9iaiA9IG5ldyBEYXRlKGRhdGUudmFsdWVPZigpKTtcclxuICAgICAgICBpZiAoaXNOYU4oZGF0ZU9iai5nZXRUaW1lKCkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21vY2tkYXRlOiBUaGUgdGltZSBzZXQgaXMgYW4gaW52YWxpZCBkYXRlOiAnICsgZGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICBEYXRlID0gTW9ja0RhdGU7XHJcbiAgICAgICAgbm93ID0gZGF0ZU9iai52YWx1ZU9mKCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZXNldCgpIHtcclxuICAgICAgICBEYXRlID0gUmVhbERhdGU7XHJcbiAgICB9XHJcbiAgICB2YXIgbW9ja2RhdGUgPSB7XHJcbiAgICAgICAgc2V0OiBzZXQsXHJcbiAgICAgICAgcmVzZXQ6IHJlc2V0LFxyXG4gICAgfTtcblxuICAgIGV4cG9ydHMuZGVmYXVsdCA9IG1vY2tkYXRlO1xuICAgIGV4cG9ydHMucmVzZXQgPSByZXNldDtcbiAgICBleHBvcnRzLnNldCA9IHNldDtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mockdate/lib/mockdate.js\n")}}]);